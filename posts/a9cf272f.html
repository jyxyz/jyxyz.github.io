<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++笔记-网易云课堂翁恺老师 | 一杯热牛奶</title><meta name="keywords" content="C++"><meta name="author" content="阿耶"><meta name="copyright" content="阿耶"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="网易云课堂翁恺老师《面向对象程序设计-C++》的个人笔记。内容意在C++编程思想，而轻语法。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++笔记-网易云课堂翁恺老师">
<meta property="og:url" content="https://jyxyz.github.io/posts/a9cf272f.html">
<meta property="og:site_name" content="一杯热牛奶">
<meta property="og:description" content="网易云课堂翁恺老师《面向对象程序设计-C++》的个人笔记。内容意在C++编程思想，而轻语法。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jyxyz.github.io/img/default.jpg">
<meta property="article:published_time" content="2020-04-02T13:31:22.000Z">
<meta property="article:modified_time" content="2020-07-10T13:29:44.000Z">
<meta property="article:author" content="阿耶">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jyxyz.github.io/img/default.jpg"><link rel="shortcut icon" href="/img/portrait.png"><link rel="canonical" href="https://jyxyz.github.io/posts/a9cf272f"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":270},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: 阿耶","link":"链接: ","source":"来源: 一杯热牛奶","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#BEE5D3","bgDark":"#BEE5D3","position":"bottom-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++笔记-网易云课堂翁恺老师',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-07-10 21:29:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/copyright.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/heoMainColor.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/poem.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/portrait.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">一杯热牛奶</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">C++笔记-网易云课堂翁恺老师</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-02T13:31:22.000Z" title="发表于 2020-04-02 21:31:22">2020-04-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-07-10T13:29:44.000Z" title="更新于 2020-07-10 21:29:44">2020-07-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">28k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>130分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++笔记-网易云课堂翁恺老师"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/a9cf272f.html#post-comment"><span id="twikoo-count"></span></a></span></div></div></div><article class="post-content" id="article-container"><h2 id="良好的程序风格建议">良好的程序风格建议</h2>
<ul>
<li>消灭所有的warning，它是隐藏的error。当然，级别不一样。</li>
<li>每个类对应一个.h和一个.cpp文件</li>
<li>建议：类里所有成员变量都在Initializer list初始化，父类的构造函数调用也要放这里</li>
<li>建议：坚决不用default value</li>
<li>每写一个类，不管当前有用没有，把default constructor，virtual destructor，copy constructor写下来</li>
<li>尽量少用（运算符重载里讲的）类型转换，更倾向于使用显示的函数，方便代码阅读</li>
</ul>
<h2 id="基本概念">基本概念</h2>
<h3 id="什么是对象">什么是对象</h3>
<ul>
<li>
<p>What is an object?</p>
<ul>
<li>Object对象=Entity东西</li>
<li>Object may be visible or invisible，对象可以是实体(eg.杯子)也可以是虚物(eg.我说的话，但可被加工、记录)</li>
<li>Object is variable in programming languages.在程序设计语言中，对象以变量形式出现</li>
</ul>
</li>
<li>
<p>Object=Attributes属性+Services服务</p>
<ul>
<li>Data=the propertied or status</li>
<li>Operations：the functions</li>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200416141954690.png" alt="image-20200416141954690" style="zoom:50%;" />
</li>
<li><strong>！！只能通过对象提供的服务去接触里面的属性！！</strong></li>
</ul>
</li>
<li>
<p>Mapping</p>
<ul>
<li>From the problem space to the solution one.</li>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200416144904543.png" alt="image-20200416144904543" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>面向过程 vs. 面向对象</p>
<ul>
<li>按时间顺序发送的流程 vs. 存在什么</li>
</ul>
</li>
<li>
<p>What is object-oriented?</p>
<ul>
<li>
<p>物件导向，从对象出发来考虑、分析、解决问题</p>
</li>
<li>
<p>A way to organize 是一种用来组合设计和实现的方式</p>
<ul>
<li>Designs  设计，找到问题的解决思路</li>
<li>Implementations  实现，把代码写出来</li>
</ul>
</li>
<li>
<p>Objects,not control or data flow,are the primary focus of the design and implementation.</p>
<p>对象，是我们设计和实现主要关注的东西，而不是控制或数据流转（它的过程）</p>
</li>
<li>
<p>To focus on things,not operations.</p>
</li>
</ul>
</li>
</ul>
<h3 id="面向对象基本原理">面向对象基本原理</h3>
<ul>
<li>
<p>Object Oriented Programming</p>
<ul>
<li>Objects send and receive messages(objects do things!)</li>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200416150129871.png" alt="image-20200416150129871" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>Objects send messages</p>
<ul>
<li>
<p>Messages are</p>
<ul>
<li>Composed by the sender  sender表达你要干什么</li>
<li>Interpreted by the receiver  实不实现，由receiver接受者决定</li>
<li>Implemented by methods</li>
</ul>
</li>
<li>
<p>Messages</p>
<ul>
<li>
<p>May cause receiver to change state  消息可能会让接受者改变状态</p>
</li>
<li>
<p>May return results</p>
<p>消息可能返回结果，可以通过消息本身返回结果（函数有返回值）or通过另外一个消息去读取你的结果（不过在OOP本意里，你的结果（状态）我是另外去读的）</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Object vs. Class东西的总类</p>
<ul>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200416151311319.png" alt="image-20200416151311319" style="zoom:50%;" />
</li>
<li>Object(cat)   实体
<ul>
<li>Represent things,events,or concepts</li>
<li>Respond to messages at run-time</li>
</ul>
</li>
<li>Classes(cat class)  概念
<ul>
<li>Define properties of instances</li>
<li>Act like types in C++</li>
</ul>
</li>
</ul>
</li>
<li>
<p>OOP Characteristics  OOP五大原则</p>
<ol>
<li>Everything is an object.一切都是对象</li>
<li>A program is a bunch of objects telling each other <strong>what</strong> to do by sending messages.
<ul>
<li>程序是一堆对象以消息的方式告诉别人要去做什么</li>
<li>what to do而不是how to do，怎么做由接受者决定。人日常打交道也是what to do，告诉你要去做什么，不会去教你怎么做</li>
</ul>
</li>
<li>Each object has its own memory made up of other objects.
<ul>
<li>每一个对象有它自己的内存，对象里也有自己的对象；对象里面有对象</li>
<li>对象可以细分下去，但为了某种大局，分到一定程度就可以了。这叫抽象，屏蔽细节</li>
</ul>
</li>
<li>Every object has a type.
<ul>
<li>所有对象都有它自己的类型</li>
<li>对于OOP来说，先有类型后有对象，任何东西都是由某个类型定义出来的</li>
</ul>
</li>
<li>All objects of a particular type can receive the same messages.
<ul>
<li>正过来：一个特定类型的所有对象可以接收相同的消息</li>
<li>反过来：所有可以接收相同消息的对象可以被认为是相同的类型</li>
</ul>
</li>
</ol>
</li>
<li>
<p>An object has an interface</p>
<ul>
<li>The interface is the way it receives messages.  对象都是以接口和外界打交道</li>
<li>It is defined in the class the object belong to.  这个接口也定义了它是哪一类</li>
</ul>
</li>
<li>
<p>Functions of the interface</p>
<ul>
<li>Communication  通信、交流</li>
<li>Protection  接口能对内部的Attribute进行保护</li>
</ul>
</li>
<li>
<p>The Hidden Implementation</p>
<ul>
<li>Inner part of an object,data members to present its state,and the actions it takes when messages is hidden.</li>
<li>Class creators（写类的人） vs. Client programmers （用别人写完现有的类去写东西）
<ul>
<li>Keep client programmers’ hands off portions they should not touch.</li>
<li>Allow the class creators to change the internal working of the class without worrying about it will affect the client programmers.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Encapsulation 分装</p>
<ul>
<li>bundle data and methods dealing with these data together in an object</li>
<li>Hide the details of the data and the action</li>
<li>Restrict only access to the publicized methods.</li>
</ul>
</li>
</ul>
<h3 id="自动售票机例子">自动售票机例子</h3>
<ul>
<li>
<p>::resolver域的解析符</p>
<ul>
<li>
<p><Class Name>::<function name></p>
</li>
<li>
<p>::<function name></p>
</li>
<li>
<pre><code class="language-c++">void S::f() &#123;::f( ); // Would be recursive otherwise!  全局的f()::a++; // Select the global a   全局的aa--; //The a at class scope    用类里的成员变量a&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 头文件	</span><br><span class="line"></span><br><span class="line">+ Definition of a class </span><br><span class="line">  + In C++, separated .h and .cpp files are used to define one class.</span><br><span class="line">  + Class declaration and prototypes in that class are in the header file (.h).类的声明放.h</span><br><span class="line">  + All the bodies of these functions are in the source file (.cpp). 类中函数body部分放.cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ The header files</span><br><span class="line">  + If a function is declared in a header file, you must include the header file everywhere the function is used and where the function is defined.</span><br><span class="line">    + 一个函数在头文件中声明，要在所有用到这个函数以及定义这个函数body的文件中#include这个头文件</span><br><span class="line">  + If a class is declared in a header file, you must include the header file everywhere the class is used and where class member functions are defined.</span><br><span class="line">    + 一个类在头文件中声明，要在所有用到这个类以及定义这个类实体的文件中#include这个头文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Header = interface</span><br><span class="line">  + The header is a contract between you and the user of your code.</span><br><span class="line">    + 程序员通过.h告诉使用者这个类长什么样子，你怎样去用。然后使用者#include这个类的头文件去做事情。这是程序员和使用这个类的人之间的一种合同</span><br><span class="line">  + The compile enforces the contract by requiring you to declare all structures and functions before they are used.</span><br><span class="line">    + 编译器会强化这种合同，你在使用所有结构和函数之前必须要声明它们，否则无法使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Structure of C++ program</span><br><span class="line"></span><br><span class="line">  + &lt;img src=&quot;/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200416170958761.png&quot; alt=&quot;image-20200416170958761&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  + 各种后缀名文件</span><br><span class="line">    + .h</span><br><span class="line">    + .cpp</span><br><span class="line">    + .ii编译预处理后的文件</span><br><span class="line">    + .o目标代码</span><br><span class="line">    + .out最终可执行程序</span><br><span class="line">    + .s汇编</span><br><span class="line">    + 编译顺序</span><br><span class="line">      + $.cpp\ \ 预编译处理指令\longrightarrow.ii\ \ 编译器\longrightarrow.s\ \ 汇编器\longrightarrow.o\ \ \ ld链接器 \longrightarrow .out$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Declarations vs. Definitions</span><br><span class="line"></span><br><span class="line">  + A.cpp file is a compile unit</span><br><span class="line"></span><br><span class="line">    + 一个.cpp文件是一个编译单元，编译时候只针对这个.cpp文件进行编译</span><br><span class="line"></span><br><span class="line">  + Only declarations are allowed to be in .h  </span><br><span class="line"></span><br><span class="line">    只能在.h放声明。如果放了定义，有多个.cpp#include了这个.h，编译能过（因为每个.cpp是一个编译单元），但链接器那关会出问题，duplicate symbol</span><br><span class="line"></span><br><span class="line">    + extern variables 全局变量声明(extern int i;前面加extern是声明)</span><br><span class="line">    + function prototypes 函数原型（没有&#123;&#125;的是声明）</span><br><span class="line">    + class/struct declaration 类/结构体声明（类/结构体没有叫定义的东西）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ #include</span><br><span class="line"></span><br><span class="line">  + #include is to insert the included file into the .cpp file at where the #include statement is.</span><br><span class="line"></span><br><span class="line">    #编译预处理，把你#的头文件里的**文本插入**进来，形成一个编译前的大文件</span><br><span class="line"></span><br><span class="line">    + #include“xx.h&quot;&quot;：first search in the current directory, then the directories declared somewhere.  </span><br><span class="line"></span><br><span class="line">      先从那个#include了的文件的当前目录找这个.h</span><br><span class="line"></span><br><span class="line">    + #include &lt;xx.h&gt;:search in the specified directories.  </span><br><span class="line"></span><br><span class="line">      去系统目录找(编译器所认定的头文件所在的目录windows没统一目录，通常在编译器安装的目录下；UNIX在  /usr/include/)</span><br><span class="line"></span><br><span class="line">    + #include &lt;xx&gt; :same as #include &lt; &lt;xx.h&gt;（做文本插入功能，管你后缀是啥）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Standard header file structure</span><br><span class="line"></span><br><span class="line">  + #ifndef HEADER_ FLAG</span><br><span class="line">    #define HEADER_ FLAG</span><br><span class="line">    // Type declaration here.. .</span><br><span class="line">    #endif   // HEADER_ _FLAG </span><br><span class="line"></span><br><span class="line">  为了防止在同一个.cpp文件里多次#include了一个.h，而出现那个.h里类的声明重复出现的问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Tips for header</span><br><span class="line">  1. One class declaration per header file  一个头文件只放一个类</span><br><span class="line">  2. Associated with one source file in the same prefix of file name.</span><br><span class="line">  3. The contents of a header file is surrounded with #ifndef #define #endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 时钟的例子</span><br><span class="line"></span><br><span class="line">+ Abstract	抽象</span><br><span class="line"></span><br><span class="line">  + Abstraction is the ability to ignore details of parts to focus attention on a higher level of a problem.	</span><br><span class="line"></span><br><span class="line">    忽略细节</span><br><span class="line"></span><br><span class="line">  + Modularization is the process of dividing a whole into well-defined parts, which can be built and examined separately, and which interact in well-defined ways.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 成员变量</span><br><span class="line"></span><br><span class="line">+ local variable</span><br><span class="line"></span><br><span class="line">  + Local variables are defined inside a method,have a scope limited to the method to which they belong.	</span><br><span class="line"></span><br><span class="line">    在函数内部定义的变量叫本地变量，它只在这个函数执行时有效</span><br><span class="line"></span><br><span class="line">  + A local variable of the same name as a field will prevent the field being accessed from within a method.  </span><br><span class="line"></span><br><span class="line">    函数里本地变量和成员变量同名，最近原则，按照最近的定义来，所以成员变量被屏蔽</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Fields成员变量，parameters函数的形参，local variables本地变量</span><br><span class="line">  + All three kinds of variable are able to store a value that is appropriate to their defined type.</span><br><span class="line">  + Fields are defined outside constructors and methods.</span><br><span class="line">  + Fields are used to store data that persists throughout the life of an object.成员变量在谋某个对象的生存期一直存在，它的作用域是类的作用域，在整个类的所有成员函数都可以直接使用这些成员变量As such, they maintain the current state of an object. They have a lifetime that lasts as long as their object lasts.</span><br><span class="line">  + Fields have class scope: their accessibility extends throughout the whole class, and so they can be used within any of the constructors or methods of the class in which they are defined.</span><br><span class="line">  + parameters和local varibles完全一样，存储都是本地存储，存放在堆栈stack，进入函数前不存在，离开函数不存在，具体位置是不一样的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ 成员变量在类定义的每一个对象里。类是declaration，这里有一个，有这么个东西，但不指出在哪里。类是概念、虚的、观点，不拥有变量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ 函数是属于类的，不是属于对象的</span><br><span class="line"></span><br><span class="line">~~~c++</span><br><span class="line">#include &lt;iostream&gt;using namespace std;class A&#123;public:    A():i(10)&#123;&#125;    void f();private:    int i;&#125;;void A::f()&#123;    i=20;    cout&gt;&gt;i&gt;&gt;endl;&#125;int main()&#123;    A a;    A aa;    a.f();    aa.f();        return 0;&#125;------------------------------------------------------------------------------------------------f()如何知道是哪个对象的i去调用它？------------------------------------------------------------------------------------------------//c的代码如何实现谁调它？struct B&#123;    int i;&#125;;void f(struct B* p)&#123;    p-&gt;i=20;    cout&lt;&lt;p-&gt;i&lt;&lt;endl;&#125;//从这里得到启发，猜测通过传对象的地址给类里的函数（如下）------------------------------------------------------------------------------------------------void A::f(A* p)&#123;    p-&gt;i=20;    cout&gt;&gt;p-&gt;i&gt;&gt;endl;&#125;    int main()&#123;    ....    A::f(&amp;a);&#125;    ------------------------------------------------------------------------------------------------//证明过程：#include &lt;stdio.h&gt;class A&#123;public:    A():i(10)&#123;&#125;    void f();private:    int i;&#125;;void A::f()&#123;    i=20;    printf(&quot;A::f()--&amp;i=%p\n&quot;,&amp;i);&#125;int main()&#123;    A a;    printf(&quot;&amp;a=%p\n&quot;,&amp;a);    printf(&quot;&amp;a.i=%p\n&quot;,&amp;(a.i));    a.f();        A aa;    printf(&quot;&amp;aa=%p\n&quot;,&amp;aa);    aa.f();        return 0;&#125;------------------------------------------------------------------------------------------------//运行结果：Kai-MBA:cc wengkai$ g++ -m32 a.cppKai-MBA:cc wengkai$ ./a.out&amp;a=0xbff99c58&amp;a.i=0xbff99c58A::f()--&amp;i=0xbff99c58&amp;aa=0xbff99c50.A::f()--&amp;i=0xbff99c50//不同对象去调同一个函数，这个函数知道是哪个对象调它------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
<li>
<p>Call functions in a class</p>
<p>Point a;</p>
<p>a. print();</p>
<ul>
<li>There is a relationship with the function be called and the variable calls it.</li>
<li>The function itself knows it is doing something with the variable.</li>
</ul>
</li>
<li>
<p>this: the hidden parameter</p>
<ul>
<li>
<p>this is a hidden parameter for all member functions,with the type of the class</p>
<p>void Point::print()     --&gt; (can be regarded as)     void Point::print(Point *p)</p>
</li>
</ul>
</li>
<li>
<p>this: pointer to the caller</p>
<ul>
<li>Inside member functions, you can use <strong>this</strong> as the pointer to the variable that calls the function.</li>
<li>this is a natural local variable of all class member functions that you can not define, but can use it directly.</li>
</ul>
</li>
</ul>
<h3 id="构造与析构">构造与析构</h3>
<ul>
<li>
<p>没给对象初始化，对象的值是内存中随机的值（为了效率）。而JAVA的值是0</p>
<p>（visual studio，未初始化内存，Debug模式下编译时会往内存塞两个0xCD，连起来是国标码的“烫”，表名你未初始化内存）</p>
</li>
<li>
<p>Guaranteed initialization with the constructor （加入一种机制，哪怕初级程序员也能提醒他去做，即构造器（constructor））</p>
<ul>
<li>If a class has a constructor, the compiler automatically calls that constructor at the point an object is created, before client programmers can get their hands on the object.	在对象被创建时自动调用</li>
<li>The name of the constructor is the same as the name of the class.  构造函数和类名字一样，无返回类型</li>
</ul>
</li>
<li>
<p>How a constructor does?</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200421174716835.png" alt="image-20200421174716835" style="zoom:50%;" />
<p>X a;的时候实际上是作a.X();</p>
</li>
<li>
<p>Constructors with arguments  构造函数带参数</p>
<ul>
<li>
<p>The constructor can have arguments to allow you to specify how an object is created, give it initialization values, and so on.</p>
<p>Tree(int i) {…}</p>
<p>Tree t(12);</p>
</li>
</ul>
</li>
<li>
<p>The destructor</p>
<ul>
<li>
<p>In C++, cleanup is as important as initialization and is therefore guaranteed with the destructor.</p>
</li>
<li>
<p>The destructor is named after the name of the class with a leading tilde (~).The destructor never has any arguments.</p>
</li>
<li>
<p>都析构了，没法给参数</p>
</li>
<li>
<p>析构函数用来处理先前内部申请的资源</p>
</li>
<li>
<pre><code class="language-c++">class Y&#123;public:    ~Y();&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ When is a destructor called?</span><br><span class="line"></span><br><span class="line">  + The destructor is called automatically by the compiler when the object goes out of scope.</span><br><span class="line"></span><br><span class="line">  + The only evidence for a destructor call is the closing brace of the scope that surrounds the object.</span><br><span class="line"></span><br><span class="line">    对象在关闭的大括号时调用析构函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 对象初始化</span><br><span class="line"></span><br><span class="line">+ Storage allocation</span><br><span class="line"></span><br><span class="line">  + The compiler allocates all the storage for a scope at the opening brace of that scope.</span><br><span class="line"></span><br><span class="line">    编译器在大括号开始的地方，分配大括号里所有变量的空间</span><br><span class="line"></span><br><span class="line">  + The constructor call doesn&#x27;t happen until the sequence point where the object is defined.</span><br><span class="line"></span><br><span class="line">    构造器要在对象的定义时才调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Aggregate initialization  数组初始化</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  int a[5]=&#123;1,2，3，4,5&#125;;int b[6] = &#123;5&#125;;//第一个是5，其余是0int c[]=&#123;1，2,3,4&#125;;-sizeof C / sizeof *c//整个数组大小/某个单元大小=个数    struct X&#123; int i;float f;char c; &#125;;-X x1=&#123;1, 2.2，&#x27;c&#x27; &#125;;X x2[3] = &#123; &#123;1，1.1， &#x27;a&#x27;&#125;，&#123;2, 2.2， &#x27;b&#x27;&#125; &#125;;struct Y &#123; float f; int i; Y(int a); &#125;;Y y1[] = &#123; Y(1)，Y(2)，Y(3) &#125;;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
<li>
<p>The default constructor   缺省无参构造函数</p>
<ul>
<li>
<p>A default constructor is one that can be called with no arguments.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> &#123;</span>     <span class="keyword">float</span> f;    <span class="keyword">int</span> i;    <span class="built_in">Y</span>(<span class="keyword">int</span> a); &#125;;Y y1[] = &#123; <span class="built_in">Y</span>(<span class="number">1</span>)，<span class="built_in">Y</span>(<span class="number">2</span>)，<span class="built_in">Y</span>(<span class="number">3</span>) &#125;;<span class="comment">//okY y2[2]=&#123;Y(1)&#125;;//error  没给第二个参数----------------------------------------------------------------------------------------报错：    no matching function for call to ‘A::A()’    </span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="new-delete">new	&amp;	delete</h3>
<ul>
<li>
<p>Dynamic memory allocation 	 c++引入两个运算符（运算一定有结果）</p>
<ul>
<li>new  运算的结果是地址
<ul>
<li>new int</li>
<li>new Stach;  分配类Stach的空间，分配后调用构造函数</li>
<li>new int[10];</li>
</ul>
</li>
<li>delete    给地址给它，delete掉。先调用析构函数，然后delete掉
<ul>
<li>delete p;</li>
<li>delete[]  p;</li>
</ul>
</li>
<li>new&lt;-&gt;delete               new p[ ]&lt;-&gt;delete [ ] p</li>
</ul>
</li>
<li>
<p>new and delete</p>
<ul>
<li>new is the way to allocate memory as a program runs. Pointers become the only access to that memory  指针是访问这块内存的唯一方式</li>
<li>delete enables you to return memory to the memory pool when you are finished with it.</li>
</ul>
</li>
<li>
<p>Dynamic Arrays  动态数组</p>
<ul>
<li>int* psome = new int [10];
<ul>
<li>The new operator returns the address of the first element of the block.</li>
</ul>
</li>
<li>delete[ ] psome;
<ul>
<li>The presence of the brackets tells the program that it should free the whole array, not just the element</li>
</ul>
</li>
</ul>
</li>
<li>
<p>The new-delete mech.</p>
<ul>
<li>new在堆里找块空地，同时会有张表记录申请多大的空间（字节为单位），以及申请的地址是多少</li>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200421212515639.png" alt="image-20200421212515639" style="zoom:67%;" />
</li>
<li>编译时，通过q的类型知道是一个类，要析构，所以先析构，后delete</li>
<li>delete的时候找这个表，然后读表上的地址，收回表上记录的字节大小，同时把表抹掉</li>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/wps2.jpg" alt="wps2" style="zoom:67%;" />
</li>
<li>new p[ ]但delete p，只会调用第一个析构（即p所指的那个对象的析构），但空间是全都回收（空间回收和表有关）
<ul>
<li>[ ]告诉它由多个对象，具体多少个它自己会算</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Tips for new and delete</p>
<ul>
<li>
<p>Don’t use <strong>delete</strong> to free memory that <strong>new</strong> didn’t allocate. 不要用delete去free不是new出来的空间，因为没那个表</p>
</li>
<li>
<p>Don’t use <strong>delete</strong> to free the same block of memory twice in succession. 不要delete同一块</p>
</li>
<li>
<p>Use <strong>delete [ ]</strong> if you used <strong>new [ ]</strong> to allocate an array.</p>
</li>
<li>
<p>Use <strong>delete</strong> (no brackets) if you used <strong>new</strong> to allocate a single entity.</p>
</li>
<li>
<p>It’s safe to apply <strong>delete</strong> to the null pointer (nothing happens).  delete空指针是安全的，（delete前判断一下，若空则不做事情）</p>
<ul>
<li>
<p>留这个口子为了代码好写</p>
</li>
<li>
<p>eg.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">private</span>:    <span class="keyword">int</span> *p;<span class="keyword">public</span>:    <span class="built_in">A</span>()&#123;        p=<span class="number">0</span>;        ...&#125;    ~<span class="built_in">A</span>()    &#123;        <span class="comment">//if (p)  但还是建议加上这行，稳妥，保险。如果new了不delete会发生内存泄漏        delete p;        ...    &#125;        void f()    &#123;        p=new int;    &#125;    &#125;;void f()不一定被调用，所以delete了空指针，因为留了这个口子，所以这样没事</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="访问限制">访问限制</h3>
<ul>
<li>
<p>Setting limits</p>
<ul>
<li>to keep the client programmer’s hands off members they shouldn’t touch.</li>
<li>to allow the library designer（写这个类的人） to change the internal workings of the structure without worrying about how it will affect the client programmer.</li>
</ul>
</li>
<li>
<p>C++ access control</p>
<ul>
<li>
<p>The members of a class can be cataloged,marked as:</p>
<p>-public  任何人</p>
<p>-private  只有类的成员函数可以访问这些成员变量或者成员函数</p>
<p>-protected  只有类自己以及子子孙孙可以</p>
</li>
</ul>
</li>
<li>
<p>public</p>
<ul>
<li>public means all member declarations that follow are available to everyone.</li>
</ul>
</li>
<li>
<p>private</p>
<ul>
<li>The private keyword means that no one can access that menber except inside function members of that type.</li>
<li>private是对类而言的，而不是对象。<strong>同一个类里的不同对象是可以互相访问的</strong></li>
</ul>
</li>
<li>
<p>public和private权限仅仅在编译时刻编译器来检查，运行时没人管了</p>
</li>
<li>
<p>Friends</p>
<ul>
<li>
<p>to explicitly grant access to a function that isn’t a member of the structure</p>
</li>
<li>
<p>The class itself controls which code has access to its members.</p>
</li>
<li>
<p>Can declare a global function as a <strong>friend</strong>, as well as a member function of another class,or even an entire class, as a <strong>friend</strong>.</p>
</li>
<li>
<pre><code class="language-c++">//: C05:Friend. cpp// From Thinking in C++, 2nd Edition// Available at http ://www.BruceEckel.com// (c) Bruce Eckel 2000// Copyright notice in Copyright.txt// Friend allows special access// Declaration (incomplete type specification): struct X;//前向声明，告诉编译器X是个东西，但不需要知道X具体什么样struct Y &#123;	void f(X*);//因为后面Y里用到了X，要让编译通过&#125;;struct X &#123; // Definitionprivate:int i;public:	void initialize();	friend void g(X*，int); // Global friend	friend void Y::f(X*); // Struct member friend   //X里面用到了Y里的f()，所以Y要在struct X前面声明	friend struct Z; // Entire struct is a friend	friend void h();&#125;;void x::initialize() &#123;	i=0;&#125;void g(X* x，int i) &#123;	x-&gt;i = i;&#125;void Y::f(X* x) &#123;	x-&gt;i = 47;&#125;struct Z &#123;private:	int j;&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + 已经封装的一个类，比如系统库那你没办法去friend了</span><br><span class="line"></span><br><span class="line">  + friend授权是编译时候检查</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ class vs. struct</span><br><span class="line">  + **class** defaults to **private **     class缺省访问属性默认为private</span><br><span class="line">  + **struct** defaults to **public**      struct 默认为public</span><br><span class="line">  + 在c++首选用class，除非那个类简单到无以复加，只是表达几个数字组合，用struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 初始化列表</span><br><span class="line"></span><br><span class="line">+ Initializer list</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  class Point &#123;private :	const float X，y;	Point(float xa = 0.0，float ya = 0.0): y(ya)，x(xa) &#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>Can initialize any type of data<br>
一pseudo-constructor calls for built- ins<br>
一No need to perform assignment within body of ctor</p>
</li>
<li>
<p>Order of initialization is order of declaration</p>
<p>—Not the order in the list!</p>
<p>—Destroyed in the reverse order.</p>
</li>
</ul>
</li>
<li>
<p>Initialization vs. assignment</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student:: <span class="built_in">Student</span> (string s) :<span class="built_in">name</span> (s) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>initialization<br>
before constructor</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student:: <span class="built_in">Student</span> (string s) &#123;name=s; &#125;</span><br></pre></td></tr></table></figure>
<p>assignment</p>
<p>inside constructor</p>
<p>string must have a default constructor</p>
</li>
<li>
<p>建议：类里所有成员变量都在Initializer list初始化</p>
<p>​			父类的构造函数调用也要放这里</p>
</li>
</ul>
<h3 id="对象组合">对象组合</h3>
<ul>
<li>
<p>Reusing the implementation  软件重用</p>
<ul>
<li>
<p>Composition: construct new object with existing objects</p>
</li>
<li>
<p>It is the relationship of“has-a&quot;</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422143910989.png" alt="image-20200422143910989" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>Composition  组合</p>
<ul>
<li>Objects can be used to build up other objects</li>
<li>Ways of inclusion   （根据语义选择）<br>
-Fully  是组成我的一部分（成员变量是对象）<br>
-By reference  我知道它在哪，可以调用它，但不是我身体一部分（成员变量是指针）</li>
<li>Inclusion by reference allows sharing</li>
<li>For example,an Employee has a
<ul>
<li>Name</li>
<li>Address</li>
<li>Health Plan</li>
<li>Salary History
<ul>
<li>Collection of Raise objects</li>
</ul>
</li>
<li>Supervisor  （前面是Fully，这个不能是Fully，语义不符合，且Employee里又有Employee，完没了）
<ul>
<li>Another Employee object!</li>
</ul>
</li>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422162014753.png" alt="image-20200422162014753" style="zoom:50%;" />
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span> . .. &#125;;<span class="class"><span class="keyword">class</span> <span class="title">Currency</span> &#123;</span> . .. &#125;;<span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> &#123;</span><span class="keyword">public</span>:	<span class="built_in">SavingsAccount</span>( <span class="keyword">const</span> <span class="keyword">char</span>* name ,<span class="keyword">const</span> <span class="keyword">char</span>* address, <span class="keyword">int</span> cents ) ;	~<span class="built_in">SavingsAccount</span> () ;	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>;<span class="keyword">private</span> :	Person m saver ;	Currency m_ balance;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>组合进来的对象仍是独立的，不能去破坏它的边界</p>
</li>
<li>
<p>SavingsAccount初始化列表要调用那两个组合对象的构造函数，让它们自己处理自己内部的事情</p>
<p>如果不调用，就要要求m_saver和m_balance这两个对象要有default constructor</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Savi ngsAccount: : <span class="built_in">SavingsAccount</span>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* address,<span class="keyword">int</span> cents):<span class="built_in">m_saver</span> (name，address) ，<span class="built_in">m_balance</span> (<span class="number">0</span>，cents) &#123; &#125;<span class="comment">//仍然用组合进来的对象提供的操作去访问它的成员void SavingsAccount::print() &#123;	m_saver.print () ;	m_balance.print() ;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Embedded objects(课上没讲？)</p>
<ul>
<li>
<p>All embedded objects are initialized</p>
<p>—The default constructor is called if</p>
<ul>
<li>you don’t supply the arguments, and there is a default constructor (or one can be built)</li>
</ul>
</li>
<li>
<p>Constructors can have initialization list</p>
<p>—any number of objects separated by commas</p>
<p>—is optional</p>
<p>—Provide arguments to sub-constructors</p>
</li>
<li>
<p>Syntax:name ( args )  [ ‘:’ init-list ] ‘{‘</p>
</li>
</ul>
</li>
<li>
<p>Question</p>
<ul>
<li>
<p>If we wrote the constructor as (assuming we have the set accessors for the subobjects):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SavingsAccount::<span class="built_in">SavingsAccount</span> ( <span class="keyword">const</span> <span class="keyword">char</span>* name,<span class="keyword">const</span> <span class="keyword">char</span>* address, <span class="keyword">int</span> cents ) &#123;	m_saver.<span class="built_in">set_name</span> ( name ) ;	m_saver.<span class="built_in">set_address</span> ( address ) ;	m_balance.<span class="built_in">set_cents</span> ( cents ) ;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Default constructors would be called</p>
</li>
</ul>
</li>
<li>
<p>Public vs. Private</p>
<ul>
<li>
<p>It is common to make embedded objects (嵌入对象)</p>
<p>private:</p>
<p>—they are part of the underlying implementation</p>
<p>—the new class only has part of the public interface of the old class</p>
</li>
<li>
<p>Can embed as a public object if you want to have the entire public interface of the subobject available in the new object:（如果设置嵌入对象为public）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> &#123;</span><span class="keyword">public</span>:	Person m saver;    ...&#125;;<span class="comment">// assume	Person class haS set name ( )SavingsAccount account ;account.m saver.set_name (&quot;Fred&quot; ) ;//通过.来访问//但不是OOP所喜欢的，破坏了封装</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="继承">继承</h3>
<ul>
<li>
<p>组合和继承都是软件重用的一种方式</p>
<ul>
<li>区别：
<ul>
<li>组合：拿已有对象拼装成一个新对象，（玩实的）</li>
<li>继承：改造一个类，（玩虚的）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Reusing the interface</p>
<ul>
<li>Inheritance is to take the existing class, clone it,and then make additions and modifications to the clone.</li>
</ul>
</li>
<li>
<p>Inheritance</p>
<ul>
<li>
<p>Language implementation technique</p>
</li>
<li>
<p>Also an important component of the OO design methodology</p>
</li>
<li>
<p>Allows sharing of design for</p>
<ul>
<li>Member data</li>
<li>Member functions</li>
<li>Interfaces  一个类public的部分是这个类的Interfaces，它可能有Member data，可能有Member functions，所以这里写个Interfaces</li>
</ul>
</li>
<li>
<p>Key technology in C++</p>
</li>
<li>
<p>The ability to define the behavior or implementation of one class as a <strong>superset</strong> （超集）of another class.</p>
<ul>
<li>
<p>这句话one class是指：Student</p>
<p>another class是指Person</p>
<p>Studnet是在Person的属性上扩充，表达学生的数据比表达Person的数据要多，是对原有的类进行扩充，所以说superset（超集）</p>
</li>
</ul>
</li>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422145613325.png" alt="image-20200422145613325" style="zoom:50%;" />
<p>Person是Student的超类，Person是被学习者</p>
</li>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422145643439.png" alt="image-20200422145643439" style="zoom:50%;" />
<ul>
<li>画图一般把被继承的类放上面，表示高低关系</li>
<li>上面的：基类、超类、父类</li>
<li>下面的：派生类、子类</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Scopes and access in C++</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422170734507.png" alt="image-20200422170734507" style="zoom:67%;" />
</li>
</ul>
<h3 id="子类父类关系">子类父类关系</h3>
<ul>
<li>
<p>Decalre an Employee class</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span><span class="keyword">public</span>:	<span class="built_in">Employee</span> ( <span class="keyword">const</span> std::string&amp; name,<span class="keyword">const</span> std::string&amp; ssn ) ;	    <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">get_name</span> <span class="params">()</span> <span class="keyword">const</span></span>;	<span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(std::ostream&amp; out)</span> <span class="keyword">const</span></span>;	<span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(std::ostream&amp; out，<span class="keyword">const</span> std::string&amp; msg)</span> <span class="keyword">const</span></span>;<span class="keyword">protected</span>:<span class="comment">//偷懒的写法，好处少想很多事情，坏处不知道你的子类会对这两个东西动什么手脚	std::string m_name;	std::string m_ssn;&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Constructor for Employee</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee::<span class="built_in">Employee</span>(<span class="keyword">const</span> string&amp; name,<span class="keyword">const</span> string&amp; ssn ):<span class="built_in">m_name</span>(name)，<span class="built_in">m_ssn</span>(ssn)&#123;	<span class="comment">// initializer list sets up the values!已经在initializer list初始化了，函数里不做任何事情&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Employee member functions</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; Employee::get_ <span class="title">name</span> <span class="params">()</span> <span class="keyword">const</span></span>&#123;	<span class="keyword">return</span> m_name ;&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Employee::print</span><span class="params">(std::ostream&amp; out )</span> <span class="keyword">const</span></span>&#123;	out&lt;&lt;m_name&lt;&lt;endl;	out&lt;&lt;m_ssn&lt;&lt;endl;&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Employee::print</span><span class="params">(std::ostream&amp; out, <span class="keyword">const</span> std::string&amp; msg)</span> <span class="keyword">const</span></span>&#123;	out &lt;&lt; msg &lt;&lt; endl;	<span class="built_in">print</span> (out) ;<span class="comment">//调用了第6行的函数，避免了code duplication代码复制。未来要修改函数只需修改一处就行了。尽量使用已有的代码&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Now add Manager</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> :</span> <span class="keyword">public</span> Employee &#123;<span class="keyword">public</span>:	<span class="built_in">Manager</span> (<span class="keyword">const</span> std::string&amp; name,<span class="keyword">const</span> std::string&amp; ssn,<span class="keyword">const</span> std::string&amp; title);	<span class="function"><span class="keyword">const</span> std::string <span class="title">title_name</span> <span class="params">()</span> <span class="keyword">const</span></span>;	<span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">get_title</span> <span class="params">()</span> <span class="keyword">const</span> </span>;	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(std::ostream&amp; out)</span> <span class="keyword">const</span></span>;<span class="keyword">private</span>:	std::string m_title;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Inheritance and constructors</p>
<ul>
<li>
<p>Think of inherited traits as anembedded object</p>
</li>
<li>
<p>Base class is mentioned by class name</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Manager::<span class="built_in">Manager</span> ( <span class="keyword">const</span> string&amp; name， <span class="keyword">const</span> string&amp; ssn，<span class="keyword">const</span> string&amp; title = <span class="string">&quot;&quot;</span> ):<span class="built_in">Employee</span> (name， ssn)，<span class="function">m_ <span class="title">title</span><span class="params">( title )</span>    </span>&#123;    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>More on constructors</p>
<ul>
<li>Base class is always constructed first</li>
<li>If no explicit arguments are passed to base class.
<ul>
<li>Default constructor will be called</li>
<li>建议2：父类的构造函数，放在初始化列表（顺序是按你声明的顺序，而不是在初始化列表写的顺序。父类最先，然后其他成员变量（成员变量按你声明的顺序））</li>
</ul>
</li>
<li>Destructors are called in exactly the reverse order of the constructors. 先构造的后析构</li>
</ul>
</li>
<li>
<p>Manager member functions</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Manager::print</span><span class="params">(std::ostream&amp; out)</span> <span class="keyword">const</span></span>&#123;	Employee::<span class="built_in">print</span>(out);<span class="comment">// call the base class print     //cout &lt;&lt; m_title &lt;&lt; endl;&#125;inline const std::string&amp; Manager::get_title() const&#123;	return m_title;&#125;inline const std::string Manager::title_name() const&#123;	return string(m_title+&quot;:&quot;+m_name);//access base m_name&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Uses</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;	<span class="function">Employee <span class="title">bob</span><span class="params">( <span class="string">&quot;Bob Jones&quot;</span>, <span class="string">&quot;555-44-0000&quot;</span> )</span> </span>;    <span class="function">Manager <span class="title">bill</span><span class="params">( <span class="string">&quot;Bill Smith&quot;</span>, <span class="string">&quot;666-55-1234&quot;</span>， <span class="string">&quot; Important Person&quot;</span> )</span> </span>;    string name = bill .get_ <span class="built_in">name</span> () ;<span class="comment">// okay Manager	inherits Employee         //string title = bob.get_title() ;// Error -- bob is an Employee !	cout &lt;&lt; bill.title name () &lt;&lt; &#x27; \n&#x27; &lt;&lt; endl;	    bill.print (cout) ;	bob.print (cout) ;	bob.print (cout, &quot;Employee:&quot;) ;	//bill.print (cout, &quot;Employee:&quot;) ;	// Error hidden!&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Name Hidden</p>
<ul>
<li>
<p>只有c++这样：如果父类有overloading的函数，在子类中出现和父类当中重复的函数（相同的名字、参数），那么父类那些就被隐藏掉了，只有子类的</p>
<p>why？它俩无关系，所以把父类所有overload的都隐藏掉，要不就乱了</p>
<p>如果想调用父类的，用解析符：：</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="函数重载和默认参数">函数重载和默认参数</h3>
<ul>
<li>
<p>函数的返回类型不构成overload的条件</p>
<ul>
<li>编译器不知道你要调哪个函数</li>
</ul>
</li>
<li>
<p>Function overloading</p>
<ul>
<li>
<p>Same functions with different arguments list.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> * str， <span class="keyword">int</span> width)</span></span>; <span class="comment">// #1 .void print(double d，int width) ;//#2void print(long 1，int width); // #3void print(int i，int width); // #4void print(char *str); // #5print( &quot;Pancakes&quot;，15);print(&quot;Syrup&quot;) ;print(1999.0，10);print(1999，12);print(1999L，15);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Overload and auto-cast（Manager去调//bill.print (cout, “Employee:”) ;	// Error hidden!  这个例子）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">short</span> i)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> d)</span></span>;<span class="built_in">f</span>(<span class="string">&#x27;a&#x27;</span>);<span class="built_in">f</span>(<span class="number">2</span>);<span class="built_in">f</span>(<span class="number">2L</span>);<span class="built_in">f</span>(<span class="number">3.2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Default arguments</p>
<ul>
<li>
<p>A default argument is a value given in the declaration that the compiler automatically inserts if you don’t provide a value in the function call.函数声明时预先给一个值（写在.h里，在.cpp不能有）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stash</span>(<span class="keyword">int</span> size， <span class="keyword">int</span> initQuantity = <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>default arguments是编译时刻的事情，编译器看到函数原型声明时看到说后面几个参数有default的值，就补上了那个值</p>
</li>
<li>
<p>To define a function with an argument list, defaults must be added from right to left.从右往左写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">intharpo</span>(<span class="keyword">int</span> n，<span class="keyword">int</span> m=<span class="number">4</span>，intj=<span class="number">5</span>);<span class="function"><span class="keyword">int</span> <span class="title">chico</span><span class="params">(<span class="keyword">int</span> n，<span class="keyword">int</span> m = <span class="number">6</span>，<span class="keyword">int</span> j)</span></span>;<span class="comment">//illeagleintgroucho(int k=1，int m=2，int n=3);beeps = harpo(2);beeps = harpo(1, 8); beeps = harpo(8,7,6);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>建议：坚决不用default value</p>
<ul>
<li>原因：
<ul>
<li>让你少打字的事情，在软件工程上一般不是好事</li>
<li>阅读困难：传参时你以为这个函数只需要这么点参数</li>
<li>不安全：可能和设计者意图不同，可以改default value</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内联函数">内联函数</h3>
<ul>
<li>
<p>Overhead for a function call  调一个函数时有额外开销</p>
<ul>
<li>
<p>the processing time required by a device prior to the execution of a command</p>
<ul>
<li>Push parameters            push（传给函数的）实参</li>
<li>Push return address       push返回地址</li>
<li>Prepare return values     准备返回的值给寄存器</li>
<li>Pop all pushed                pop之前push的所有东西</li>
</ul>
</li>
<li>
<p>Example</p>
<ul>
<li>
<pre><code class="language-c++">int f(int i) &#123;	return i*2;&#125;main() &#123;	int a=4;	int b= f(a);&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  _f_int:	add ax,@sp[-8],@sp[-8]	ret_main:add sp,#8//stack pointer堆栈指针mov ax,#4mov @sp[-8],axmov ax,@sp[-8]push axcall _f_intmov @sp[-4],axpop ax    //函数参数和本地变量地位一样，都在堆栈里 </span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>做成inline函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;	<span class="keyword">return</span> i*<span class="number">2</span>;&#125;<span class="built_in">main</span>() &#123;	<span class="keyword">int</span> a=<span class="number">4</span>;	<span class="keyword">int</span> b= <span class="built_in">f</span>(a);&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编译之后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">main</span>()&#123;    <span class="keyword">int</span> a=<span class="number">4</span>;    <span class="keyword">int</span> b=a+a<span class="number">&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>汇编之后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_main: add sp,#<span class="number">8</span>mov ax,#<span class="number">4</span>mov @sp[<span class="number">-8</span>],axadd ax, @sp[<span class="number">-8</span>], @sp[<span class="number">-8</span>]mov @sp[<span class="number">-4</span>],ax </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Inline Functions</p>
<ul>
<li>
<p>An inline function is expanded in place, like a preprocessor macro, so the overhead of the function call is eliminated.</p>
</li>
<li>
<p>把函数嵌入调用它的地方，但仍保持函数的独立性</p>
<p>在最终可执行文件里是没有这个函数的，因为这个函数在编译经过类型检查后嵌入了主函数中</p>
</li>
<li>
<pre><code class="language-c++">inline int plusOne(int x);inline int plusOne(int x) &#123;return ++x; &#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ Repeat **inline** keyword at declaration and definition.</span><br><span class="line"></span><br><span class="line">  + .h:给调用这个函数的地方看的</span><br><span class="line"></span><br><span class="line">    .cpp:用来产生这个函数</span><br><span class="line"></span><br><span class="line">    在.cpp没放Inline，编译器认为这个函数不是Inline，会在可执行文件里留下这个函数，这与头文件原型声明无关</span><br><span class="line"></span><br><span class="line">    .h里的Inline是在调用这个函数的地方时告诉编译器这是个Inline函数，你不能生成调用的代码，而是把代码插进去</span><br><span class="line"></span><br><span class="line">    这样会产生问题：</span><br><span class="line"></span><br><span class="line">    ~~~c++</span><br><span class="line">    //a.hinline void f(int i,int j);//a.cpp#include &quot;a.h&quot;#include &lt;iostream&gt;using namespace std;inline void f(int i,int j)&#123;    cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;&#125;//main.cpp#include &quot;a.h&quot;int main()&#123;    f(10, 10);        return 0;&#125;</span><br></pre></td></tr></table></figure>

  g++ main.cpp a.pp后

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kai-MBA:CC wengkai$ g++ main.cpp a. cppa.h:<span class="number">1</span>: warning: <span class="keyword">inline</span> function <span class="string">&#x27;void f(int, int)&#x27;</span> used but never definedUndefined symbols <span class="keyword">for</span> architecture x86_64:	<span class="string">&quot;f(int, int)&quot;</span>， referenced from:		_main in cc3KiXGJ.old: <span class="built_in">symbol</span>(s) <span class="keyword">not</span> found <span class="keyword">for</span> architecture x86_64collect2: ld returned <span class="number">1</span> exit status</span><br></pre></td></tr></table></figure>

  经过预编译处理指令后，看main.ii

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kai-MBA:CC wengkai$ more main.ii#<span class="number">1</span><span class="string">&quot;main. cpp&quot;</span>#<span class="number">1</span><span class="string">&quot;&lt;built- in&gt;&quot;</span>#<span class="number">1</span><span class="string">&quot;&lt;command-line&gt;&quot;</span>#<span class="number">1</span><span class="string">&quot;main. cpp&quot;</span>#<span class="number">1</span><span class="string">&quot;a.h&quot;</span> <span class="number">1</span><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;#<span class="number">2</span><span class="string">&quot;main.cpp&quot;</span> <span class="number">2</span><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	<span class="built_in">f</span>(<span class="number">10</span>， <span class="number">10</span>);        <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//因为编译器同时只能看到一个文件，当编译器看main.cpp经过预编译处理指令后的main.ii,编译器知道f（）函数是inline,但不知道长什么样子，因为f（）函数的body不在这个文件里//当在main（）里调用f（）函数时，本来应该不产生调用函数的代码，把f（）函数的代码插入到这里，但现在编译器不知道f（）函数长什么样，那只能放弃把f（）函数作内联，产生对f（）函数的调用//而对于a.cpp，因为有了inline,所以编译器不去产生任何代码（a.o里就不会有关于f（）函数的汇编代码）//那么链接器时候就会出问题，main.cpp说要个f（）,而汇编里没有关于f（）函数的代码，所以就会报f（）函数没有定义的错误</span></span><br></pre></td></tr></table></figure>

  解决方案，把函数body放入.h，此时函数声明那一句其实多余了，可以去掉。若此时带上a.cpp进行编译

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kai-MBA: CC wengkai$ g++ main.cpp a. cppa.cpp: In function <span class="string">&#x27;void f(int， int)&#x27;</span>:a.cpp:<span class="number">6</span>: error: redefinition of <span class="string">&#x27;void f(int， int) &#x27;</span>a.h:<span class="number">4</span>: error: <span class="string">&#x27;void f(int, int)&#x27;</span> previously defined here   因为a.cpp<span class="meta">#<span class="meta-keyword">include</span>了a.h    a.cpp里有f（）函数body部分    #<span class="meta-keyword">include</span>的.h里也有f（）函数body部分    所以有重复定义</span></span><br></pre></td></tr></table></figure>

  **结论：Inline函数的定义其实是它的声明，不能放.cpp，只放.h就够了**

</code></pre>
</li>
<li>
<p>An inline function definition may not generate any code in .obi file.</p>
</li>
</ul>
</li>
<li>
<p>Inline functions in header file</p>
<ul>
<li>So you can put inline functions’ bodies in header file. Then #include it where the function is needed.</li>
<li>Never be afraid of multi-definition of inline functions, since they have no body at all.</li>
<li>Definitions of inline functions are just declarations.     Inline函数的definition就是它的declaration</li>
</ul>
</li>
<li>
<p>Tradeoff of inline functions</p>
<ul>
<li>
<p>Body of the called function is to be inserted into the caller.     嵌入函数会让空间变大，以空间换时间</p>
</li>
<li>
<p>This may expand the code size</p>
</li>
<li>
<p>but deduces the overhead of calling time.</p>
</li>
<li>
<p>So it gains speed at the expenses of space.</p>
</li>
<li>
<p>In most cases, it is worth.    但大多数情况下，这是值得的。因为空间不是很大的问题</p>
</li>
<li>
<p>It is much better than macro in C. It checks the types of the parameters.比C的宏好，因为inline函数是函数，可以做类型检查</p>
<ul>
<li>
<p>Example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(a) (a)+(a)main() &#123;	double a=4;	printf(<span class="meta-string">&quot;%d&quot;</span>,f(a) );&#125;<span class="comment">//直接替换，输出结果错误-----------------------------------------------------------------inline int f(int i) &#123;	return i*2;&#125;main() &#123;	double a=4;	printf(&quot;%d&quot; ,f(a) );&#125;//编译时会做类型检查，会报错</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Inline may not in-line</p>
<ul>
<li>The compiler does not have to honor your request to make a function inline. It might decide the function is too large or notice that it calls itself (recursion is not allowed or indeed possible for inline functions)（堆栈不可能做成inline，因为堆栈就要不断地进栈出栈）, or the feature might not be implemented for your particular compiler.</li>
</ul>
</li>
<li>
<p>Inline inside classes</p>
<ul>
<li>Any function you define inside a class declaration is automatically an inline.</li>
<li>在类的声明时候给出成员函数的body，那些函数通通是inline</li>
</ul>
</li>
<li>
<p>Access functions</p>
<ul>
<li>
<p>They are small functions that allow you to read or change part of the state of an object - that is, an internal variable or variables.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cup</span> &#123;</span><span class="keyword">int</span> color;<span class="keyword">public</span>:	<span class="function"><span class="keyword">int</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> color; &#125;	<span class="function"><span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;    	<span class="keyword">this</span>-&gt;color =color;	&#125;<span class="comment">//做成内联，好处是，调用这个函数和直接访问这个成员变量运行效率上没差别&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Reducing clutter</p>
<ul>
<li>
<p>Member functions defined within classes use the Latin in <em>situ</em> (in place) and maintains that all definitions should be placed outside the class to keep the interface clean.</p>
</li>
<li>
<p>Example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span>	<span class="keyword">int</span> width, height;<span class="keyword">public</span>:    <span class="built_in">Rectangle</span>(<span class="keyword">int</span> W = <span class="number">0</span>，<span class="keyword">int</span> h = <span class="number">0</span>);    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">( )</span> <span class="keyword">const</span></span>;    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span>;    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> <span class="keyword">const</span> </span>;    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span>;&#125;;<span class="comment">//类里可以加inline前缀，但没必要inline Rectangle: :Rectangle(int W，int h): width(w)， height(h) &#123;&#125;inline int Rectangle: :getWidth() const &#123;	return width;&#125;//这样可以保持类的清爽</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Inline or not?</p>
<ul>
<li>Inline:
<ul>
<li>Small functions,2 or 3 lines</li>
<li>Frequently called functions,eg.inside loops   频繁调用的函数，比如循环，值得做成inline</li>
</ul>
</li>
<li>Not inline?
<ul>
<li>Very large functions,more than 20 lines</li>
<li>Recursive functions  递归</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="const">const</h3>
<ul>
<li>
<p>Const</p>
<ul>
<li>
<p>decalres a variable to have a constant value   变量被初始化后不能再被赋值（修改）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">123</span>;x = <span class="number">27</span>; <span class="comment">// illegal!x++; // illegal!int y = x; // 0k， copy const to non-consty = x;      // 0k，same thingconst int z = y; // ok，const is safer  初始化，ok的</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Constants</p>
<ul>
<li>Constants are variables     加了const仍然是变量(变量要在内存中分配地址，而常量是编译时记在内存表的一项）
<ul>
<li>Observe scoping rules   遵循本地变量的规则（进函数存在，离开函数不存在）</li>
<li>Declared with “const” type modifier</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Compile time constants</p>
<ul>
<li>
<pre><code class="language-c++">const int busize = 1024;//在编译前就要明确地知道const的变量的值
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + value must be initialized</span><br><span class="line">  + unless you make an explicit extern declaration:   可以不知道，用extern</span><br><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  extern const int bufsize;//这是一句声明</span><br></pre></td></tr></table></figure>

+ 编译器保证编译时刻不会去修改const，这和你真正是不是const两回事
+ Compiler won't let you change it

+ Compile time constants are entries in compiler symbol table, not really variables.



</code></pre>
</li>
</ul>
</li>
<li>
<p>Run-time constants</p>
<ul>
<li>
<p>const value can be exploited</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> class_ size = <span class="number">12</span>;<span class="keyword">int</span> finalGrade[class_size]; <span class="comment">// ok   编译时刻知道const的值，可以做数组大小int x;cin &gt;&gt; x;const int size = x;double classAverage[size]; // error!   因为编译前不知道size是多少//因为编译时需要知道这个有多大，好给你分配空间（堆栈的大小）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Pointers and const</p>
<ul>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422151945420.png" alt="image-20200422151945420" style="zoom:50%;" />
</li>
<li>
<pre><code class="language-c++">char * const q = &quot;abc&quot;; // q is const   *q='c'; // 0Kq++;    // ERROR     指针是const，这个指针不能再指向别人const char *p =&quot;ABCD&quot;;// (*p) is a const char*p = 'b'; // ERROR! (*p) is the const     你不能通过这个p指针来修改p指针所指向的内存单元，而不是我指向哪，哪就是constp++; // 0K
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Quiz:What do these mean?</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  Person p1( &quot;Fred&quot;，200 );const Person* p = &amp;p1;//被指针指向的对象p1是const，即我不能通过这个指针去修改p1的值Person const* p = &amp;p1;//对象是constPerson *const p = &amp;p1;//指针是const//区分的标志：const写*前对象是  const写*后指针是const Person const* p=&amp;p1;指针和对象都是</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
<li>
<p>Pointers and constants</p>
<ul>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423183727983.png" alt="image-20200423183727983" style="zoom:67%;" />
</li>
<li>
<p>红色那行，error，因为in* ip不是const，它表明你可以通过*ip来修改值，与ci是const违背</p>
</li>
<li>
<p>Remember</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*ip  = <span class="number">54</span>; <span class="comment">// always legal since ip points to int*cip = 54; // never legal since cip points to const int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>String Literals</p>
<ul>
<li>
<pre><code class="language-c++">char* s = &quot;Hello,world!&quot;;//把&quot;Hello,world!&quot;在代码段的地址交给指针s
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + s is a pointer initialized to point to a string constant</span><br><span class="line">  + This is actually a const char* s but compiler accepts it without the const</span><br><span class="line">  + Don&#x27;t try and change the character values (it is undefined behavior)</span><br><span class="line"></span><br><span class="line">+ If you want to change the string, put it in an array:</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  char s[] = &quot;Hello, world!&quot;;//这个数组在堆栈里。这一行将hello world一个一个拷贝给数组</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>内存分三部分：</p>
<ul>
<li>
<p>本地变量放堆栈</p>
</li>
<li>
<p>new的放堆，有且仅有new的放</p>
</li>
<li>
<p>全局变量（静态本地变量、静态成员变量）放全局数据区，全局变量里的常量在代码段（代码段是不可写的）里</p>
</li>
<li>
<pre><code class="language-c++">#include &lt;stdio.h&gt;int main( )&#123;    const char *S1 = &quot;hello world&quot;;    char s2[] = &quot;hello world&quot;;        printf(&quot;s1   =%p\n&quot;， s1);    printf(&quot;s2   =%p\n&quot;， s2);    printf(&quot;main =%p\n&quot;， main);        return 0;&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 运行结果</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    Kai-MBA:CC wengkai$ ./a. outs1  =0x19f3a      //在内存很前面，代码段。和s3很近s2  =0xbffe7c48   //在堆栈main=0x19e40</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Conversions</p>
<ul>
<li>
<p>Can always treat a non-const value as const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* x)</span> </span>;<span class="comment">//你虽然传地址给我，但我保证不通过指针改你的值，编译器作保证，它会检查我的行为int a=15;f(&amp;a) ; // okconst int b = a;f(&amp;b) ; // okb = a + 1;// Error !</span></span><br></pre></td></tr></table></figure>
<p>You cannot treat a constant object as non-constant without an explicit cast (const_cast)</p>
</li>
</ul>
</li>
<li>
<p>Passing by const value？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123;	i++; <span class="comment">// Illegal -- compile-time error&#125;//对于调用f1的人无所谓，你传的不是地址，f（）里面怎么动，都不会改变你传进来的参数的值//这里只是说f（）函数里不能改形参i</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Returning by const value?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;<span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">f4</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;	<span class="keyword">const</span> <span class="keyword">int</span> j = <span class="built_in">f3</span>() ; <span class="comment">// Works fine	int k = f4() ; // But this works fine too!&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Passing and returning addresses</p>
<ul>
<li>Passing a whole object may cost you a <a target="_blank" rel="noopener" href="http://lot.It">lot.It</a> is better to pass by a pointer.But it’s possible for the programmer to take it and modify the original value.</li>
<li>In fact, whenever you’re passing an address into a function, you should make it a const if at all possible.</li>
<li>直接传对象进出堆栈开销大，传地址就好，但怕修改，所以以const的方式做保证</li>
</ul>
</li>
</ul>
<h3 id="不可修改的对象">不可修改的对象</h3>
<ul>
<li>
<p>Constant objects   类的对象const</p>
<ul>
<li>
<p>What if an object is const?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Currency <span class="title">the_raise</span> <span class="params">(<span class="number">42</span>,<span class="number">38</span>)</span></span>;<span class="comment">//说明这个对象里的值不能被修改</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>What members can access the internals?</p>
</li>
<li>
<p>How can the object be protected from change?</p>
<ul>
<li>
<p>那这个类的成员函数可能会动成员变量，怎么晓得会不会动成员变量？</p>
<p>我们可以看源码，但编译器干不了（编译单元），.h是原型，.cpp是body</p>
<p>解决方法：在函数后加const，说这个函数不修改任何成员变量</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Const member functions</p>
<ul>
<li>
<p>Cannot modify their objects</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Date::set_day</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;	<span class="comment">//...error check d here...	day = d;// ok, non-const so can modify&#125;int Date::get_day() const &#123;	day++;	//ERROR modifies data member	set day(12) ; // ERROR calls non-const member	return day;// ok&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Const member function usage</p>
<ul>
<li>
<p>Repeat the const keyword in the definition as well as the declaration  声明和定义都要加const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_day</span> <span class="params">()</span> <span class="keyword">const</span></span>;<span class="function"><span class="keyword">int</span> <span class="title">get_day</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> day &#125; ;<span class="comment">//其实这里的const说的是this</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Function members that do not modify data should be declared const</p>
</li>
<li>
<p>const member functions are safe for const objects</p>
</li>
<li>
<p>其实这里的const说的是this</p>
<ul>
<li>
<pre><code class="language-c++">#include &lt;iostream&gt;using namespace std;class A &#123;	int i;public:	A() : i(0) &#123;&#125;	void f() &#123; cout &lt;&lt; &quot;f()&quot; &lt;&lt; endl; &#125;  //完整版是void f(A* this) &#123; cout &lt;&lt; &quot;f()&quot; &lt;&lt; endl; &#125;	void f() const &#123; cout &lt;&lt; &quot;f() const&quot; &lt;&lt; endl; &#125;  //完整版是void f(const A* this) const &#123; cout &lt;&lt; &quot;f() const&quot; &lt;&lt; endl; &#125;    //这两个函数参数表不同，构成了overload&#125;;int main( )&#123;    const A a;	a.f();    	return 0;&#125;-----------------------------------------------------------------------    //运行结果：f() const
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Constants in class  成员变量是const，必须在initializer list初始化</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  class A&#123;    const int i;&#125;;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>has to be initialized in initializer list of the constructor</p>
</li>
</ul>
</li>
<li>
<p>Compile-time constants in classes</p>
<ul>
<li>
<pre><code class="language-c++">class HasArray &#123;	const int size;	int array[size]; // ERROR!    ...&#125;;//成员变量是const，不能做数组size
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ Make the const value static:     想让它可以的话，前面再加个static</span><br><span class="line"></span><br><span class="line">  + static const int size=100;</span><br><span class="line">  + static indicates only one per class(not one per object)</span><br><span class="line"></span><br><span class="line">+ Or use&quot;anonymous enum&quot; hack  或者用枚举</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    class HasArray &#123;	enum&#123;size=100&#125;;//size同样是一个常数、int类型、不能被改变，但能作数组size	int array[size] ; // OK!    ...&#125;;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="引用">引用</h3>
<ul>
<li>
<p>c++内存模型复杂在：三种放对象的地方（堆、堆栈、全局数据区）×三种访问的方式（变量、指针、引用）</p>
</li>
<li>
<p>Declaring references</p>
<ul>
<li>
<p>References are a new data type in C++</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;<span class="comment">// a characterchar* p = &amp;c; // a pointer to a characterchar&amp; r = c;// a reference to a character  //别名，一个东西的两个名字</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Local or global variables</p>
<ul>
<li>type&amp; refname = name;</li>
<li>For ordinary variables,the initial value is required   本地或全局变量引用都需要初始化。初始值必须是一个变量或者可以作左值的东西</li>
</ul>
</li>
<li>
<p>In parameter lists参数表 and member variables成员变量</p>
<ul>
<li>type&amp; refname</li>
<li>Binding绑定 defined by caller or constructor  参数是调用函数的时候给值，成员变量是构造对象时候初始化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>References</p>
<ul>
<li>
<p>Declares a new name for an existing object</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> X=<span class="number">47</span>;<span class="keyword">int</span>&amp; Y=X;<span class="comment">//Y is a reference to X.Y是X的别名// X and Y now refer to the same variablecout &lt;&lt; &quot;Y =&quot; &lt;&lt; y; //prints Y = 47Y=18;    //把18赋给Y绑着的Xcout&lt;&lt;&quot;X=&quot;&lt;&lt;X; // prints X = 18</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对references两种理解，别名、赋值</p>
</li>
</ul>
</li>
<li>
<p>Rules of references</p>
<ul>
<li>
<p>References must be initialized when defined</p>
</li>
<li>
<p>Initialization establishes a binding</p>
<ul>
<li>
<p>In declaration</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intx= <span class="number">3</span>;<span class="keyword">int</span>&amp;y= x;<span class="keyword">const</span> <span class="keyword">int</span>&amp; z = x;<span class="comment">//z是x的别名，但不能通过z修改x//其实和指针一回事const int* z = x;//不能通过指针z修改x的值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>As a function argument</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span>&amp; x)</span></span>;<span class="comment">//在f（）里其实x就是外面那个y，如果函数f（）里对x进行修改，外面y就被修改了f(y); // initialized when function is called</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Bindings don’t change at run time, unlike pointers</p>
</li>
<li>
<p>Assignment changes the object referred-to</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; y=x;y=<span class="number">12</span>;<span class="comment">//Changes value of x</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>The target of a reference must have a location!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; )</span> </span>;<span class="built_in">func</span>(i*<span class="number">3</span>);	<span class="comment">// Warning or error!    i*3有结果，是一个临时变量在放着他，但没有一个有名字的变量放着它，所以不能传给引用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>&amp;其实是const的指针（这个指针不能再指向其他的地址），为了让代码少点*</p>
<p>JAVA对象只能放堆，并且只能通过指针访问，因为只有这一种方式，所以去掉所有*，然后叫它引用，但它实际更像c++的指针，因为c++的引用之间不能赋值</p>
<p>相比于c的指针Java的指针少了*，而且不能做计算（p++，p–，俩指针之间做计算）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">f</span><span class="params">(<span class="keyword">int</span>* x)</span> </span>&#123;	(*x)++;	<span class="keyword">return</span> x; <span class="comment">// Safe， x is outside this scope&#125;int&amp; g(int&amp; x) &#123;	x++; // Same effect as in f()	return x; // Safe, outside this scope&#125;/*int g(int x)&#123;    &#125;*/reference不构成overloadint x;int&amp; h() &#123;	int q;//!  return q;  // Error	return x; // Safe， X lives outside this scope&#125;int main() &#123;	int a=0;	f(&amp;a); // Ugly (but explicit显而易见)	g(a); // Clean (but hidden)	h() = 16;//一个函数的返回结果是references，就可以做左值    //实际做的事是让x变成引用返回来，让那个引用=16，最终是让x=16    *k()=10;&#125; ///:</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Pointers vs. References</p>
<ul>
<li>References
<ul>
<li>can’t be null</li>
<li>are dependent on an existing variable,they are an alias别名 for an variable</li>
<li>can’t change to a new “address” location</li>
</ul>
</li>
<li>Pointers
<ul>
<li>can be set to null</li>
<li>pointer is independent of existing objects</li>
<li>can change to point to a different address</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Restrictions</p>
<ul>
<li>
<p>No regerences to references</p>
</li>
<li>
<p>No pointers to references</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;* p;<span class="comment">//illegal//如果*p的类型是references，说明你可以取到references的地址，但references的地址是不让你取到的</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Reference to pointer is ok<br>
void f(int*&amp; p);<br>
//p是references，它所捆的变量是一个int类型的指针</p>
<p>//离变量近的决定它是什么</p>
</li>
<li>
<p>No arrays of references   引用不是实体，所以没有数组</p>
</li>
</ul>
</li>
</ul>
<h3 id="向上造型">向上造型</h3>
<ul>
<li>
<p>Conversions</p>
<ul>
<li>
<p>Public Inheritance should imply substitution</p>
<ul>
<li>
<p>If B is a A,you can use a B anywhere an A can be used.</p>
<ul>
<li>if B is a A,then everything that is true for A is also true of B</li>
</ul>
</li>
<li>
<p>Be careful if the substitution is not valid!</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423223047267.png" alt="image-20200423223047267" style="zoom:50%;" />
<p>一个D的对象可以交给B的对象</p>
<p>一个D的指针可以交给B的指针</p>
<p>一个D的引用可以交给B的引用</p>
</li>
<li>
<p>因为从内容来说，子类的对象具有父类所有的东西，多的当不存在就好了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std;class A&#123;public:    int i;    public:    A():i(10)&#123;&#125;&#125;;class B:public A&#123;private:    int j;public:    B():j(30) &#123;&#125;    void f()&#123; cout &lt;&lt; <span class="meta-string">&quot;B.j&quot;</span> &lt;&lt; j &lt;&lt; endl; &#125;&#125;;int main()&#123;    A a;    B b;        cout &lt;&lt; a.i &lt;&lt;<span class="meta-string">&quot; &quot;</span> &lt;&lt; b.i &lt;&lt;endl;        cout &lt;&lt; sizeof(a) &lt;&lt; <span class="meta-string">&quot; &quot;</span> &lt;&lt; sizeof(b) &lt;&lt; endl;        int *p =(int*)&amp;a;<span class="comment">//把a的地址当成int类型指针交给*p    cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt;endl;    *p = 20;    cout &lt;&lt; a.i &lt;&lt;endl;        p = (int*)&amp;b;    cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt;endl;    p++;    *p = 50;    b.f();        return 0;&#125;-----------------------------------------------------------------------------------运行结果：-----------------------------------------------------------------------------------Kai-MBA:CC wengkai$ ./a. out10 104 80x7fff5609cbf0 10200x7fff5609cbe8 10B.j=50</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>子类增加的部分在后面
<ul>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423225120569.png" alt="image-20200423225120569" style="zoom:67%;" />
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Upcasting   把子类当父类看,UP是因为画图时候把子类画在下面，向上UP当父类看</p>
<ul>
<li>
<p>Upcasting is the act of converting from a Derived reference or pointer to a base class reference or pointer.</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422154817924.png" alt="image-20200422154817924" style="zoom:50%;" />
</li>
<li>
<p>cast造型，只是看待的眼光变了。而类型转换，丧失原来的数据类型</p>
</li>
</ul>
</li>
<li>
<p>Upcasting examples</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Manager <span class="title">pete</span><span class="params">( <span class="string">&quot;Pete&quot;</span>, <span class="string">&quot;444-55-6666&quot;</span>, <span class="string">&quot;Bakery&quot;</span>)</span></span>;Employee* ep = &amp;pete; <span class="comment">// UpcastEmployee&amp; er = pete;  // Upcast</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Lose type information about the object:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ep-&gt;<span class="built_in">print</span>( cout ); <span class="comment">// prints base class version</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="多态性">多态性</h3>
<ul>
<li>
<p>A drawing program</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423193526026.png" alt="image-20200423193526026" style="zoom:50%;" />
</li>
<li>
<p>Inheritance in C++</p>
<ul>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423194358065.png" alt="image-20200423194358065" style="zoom:67%;" />
</li>
<li>Can define one class in terms of another</li>
<li>Can capture the notion that
<ul>
<li>An ellipse is a shape</li>
<li>A circle is a special kind of ellipse</li>
<li>A rectangle is a different shape</li>
<li>Circles,ellipses,and rectangles share common
<ul>
<li>attributes</li>
<li>services</li>
</ul>
</li>
<li>Circles, ellipses, and rectangles are not identical</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Conceptual model</p>
<ul>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423194443465.png" alt="image-20200423194443465" style="zoom:67%;" />
</li>
</ul>
</li>
<li>
<p>Shape</p>
<ul>
<li>
<p>Define the general properties of a Shape</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XYPos</span> &#123;</span>...&#125;;  <span class="comment">// x,y pointclass Shape &#123;public:    Shape () ;    virtual ~Shape () ;    virtual void render () ;//将来shape的所有子类里，如果重新写了render，名称一样，参数也相同。那么这个render和子类的render有联系    void move (const XYPos&amp;) ;    virtual void resize () ;protected :	XYPos center ;&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Add new shapes</p>
<ul>
<li>
<pre><code class="language-c++">class Ellipse : public Shape &#123;public:    Ellipse (float maj, float minr) ;    virtual void render() ; // will define own   继承树中某个祖先加了virtual，子子孙孙都是virtual//在子孙中加上去是好习惯protected:	float major_axis, minor_axis;&#125;;class Circle : public Ellipse &#123;public:	Circle (float radius) : Ellipse (radius, radius) &#123; &#125;    virtual void render() ;&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ Example</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    void render (Shape* p) //这个函数对Shape的子类是通用的&#123;	p-&gt;render(); // calls correct render function&#125;				// for given Shape !//这里p是多态的，有的地方叫多态对象，P指哪个类型，就变成谁的形态，做那个类型的动作//另外的角度，p的静态类型是Shape的指针。动态类型是p当时指的对象的类型//如果这个函数是virtual的，就要看它的动态类型；如果不是，就是静态绑定void func() &#123;    Ellipse ell(10，20) ;    ell. render () ;    Circle circ(40) ;    circ. render () ;        render (&amp;ell) ;//把ell的地址传给Shape* p，把子类Ellipse的对象当作Shape来看待，发生了向上造型    //调用Ellipse的render（）    render (&amp;circ) ;//circle的render（）被调用&#125;//virtual的函数告诉编译器，如果对这个函数的调用是通过指针或引用的话，你就要到运行的时候看指针所指的对象是什么类型，再调用那个类型的函数</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
<li>
<p>Polymorphism  多态性    建立在Upcast和动态绑定的基础上</p>
<ul>
<li>Upcast: take an object of the derived class as an object of the base one.
<ul>
<li>Ellipse can be treated as a Shape</li>
</ul>
</li>
<li>Dynamic binding:   动态绑定
<ul>
<li>Binding:which function to be called
<ul>
<li>Static binding: call the function as the code   编译时确定</li>
<li>Dynamic binding: call the function of the object   运行时确定</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多态的实现">多态的实现</h3>
<ul>
<li>
<p>任何一个类只要有虚函数，这个类的对象就会比正常的大一点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std; class A&#123;public:	A() : i(10) &#123;&#125;	virtual void f() &#123; cout &lt;&lt; <span class="meta-string">&quot;A::f()&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;    int i;&#125;;int main( )&#123;	A a;	a.f() ;	cout &lt;&lt; sizeof(a) &lt;&lt; endl;    	int *p = (int*)&amp;a;    cout &lt;&lt; *p &lt;&lt; endl;	     return 0;&#125;---------------------------------------------------------------------------------------------运行结果：---------------------------------------------------------------------------------------------Kai-MBA:CC wengkai$ g++ a.cpp -m32Kai-MBA:CC wengkai$ ./a.outA::f()108835680---------------------------------------------------------------------------------------------    <span class="comment">//17~18行加一行 p++;---------------------------------------------------------------------------------------------Kai-MBA:CC wengkai$ g++ a.cpp -m32Kai-MBA:CC wengkai$ ./a.outA::f()10810---------------------------------------------------------------------------------------------   对象里面是：隐藏的vptr（指针，指向一张表vtable（vtable里是所有virtual函数的地址）），然后是成员变量  </span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>这张virtual不是对象的，是类的（检验方法：同一个类下不同对象的vtable地址是一样的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std; class A&#123;public:	A() : i(10) &#123;&#125;	virtual void f() &#123; cout &lt;&lt; <span class="meta-string">&quot;A::f()&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;    int i;&#125;;int main( )&#123;	A a，b;	a.f() ;	cout &lt;&lt; sizeof(a) &lt;&lt; endl;    	int *p = (int*)&amp;a;     int *q = (int*)&amp;b;        cout &lt;&lt; *p &lt;&lt; endl&lt;&lt;*q&lt;&lt;endl;	     return 0;&#125;-----------------------------------------------------------------------------------------运行结果：-----------------------------------------------------------------------------------------Kai-MBA:CC wengkai$ ./a. outA::f()108725088725088</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>vtable里面第一项是什么</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std; class A&#123;public:	A() : i(10) &#123;&#125;	virtual void f() &#123; cout &lt;&lt; <span class="meta-string">&quot;A::f()&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;    int i;&#125;;int main( )&#123;	A a，b;	a.f() ;	cout &lt;&lt; sizeof(a) &lt;&lt; endl;    	int *p = (int*)&amp;a;     int *q = (int*)&amp;b;        int *x = (int*)*p;<span class="comment">//把*p的值在当作指针，二级指针，看看vtable里面第一项的值是什么    cout &lt;&lt; x &lt;&lt; endl;        cout &lt;&lt; *p &lt;&lt; endl&lt;&lt;*q&lt;&lt;endl;	     return 0;&#125;--------------------------------------------------------------------------------------运行结果：--------------------------------------------------------------------------------------Kai-MBA:CC wengkai$ . /a. outA: :f()1080x2f068192616192616</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>How virtuals work in C++</p>
<ul>
<li>
<pre><code class="language-c++">class Shape &#123;public:    Shape () ;    virtual ~Shape () ;    virtual void render() ;    void move (const XYPos&amp;) ;    virtual void resize() ;protected:	XYPos center;&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + &lt;img src=&quot;/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423201229022.png&quot; alt=&quot;image-20200423201229022&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">+ Ellipse</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    class Ellipse :public Shape&#123;public:	Ellipse (float majr,float minr) ;	virtual void render () ;protected:	float major_ axis;	float minor_ axis;&#125;;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423201401951.png" alt="image-20200423201401951" style="zoom:67%;" />
</li>
<li>
<p>Ellipse的对象里面，自己新增的成员变量部分在后面。</p>
<p>Ellipse也有自己的vtable（检验方法：Ellipse的vtable地址和父类Shape的不一样）</p>
<p>Ellipse的vtable的结构和父类一样（第一是dtor(),然后render(),然后resize() ），但dtor（）和render（）是自己写的</p>
</li>
</ul>
</li>
<li>
<p>Shape vs Ellipse</p>
<ul>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423201500704.png" alt="image-20200423201500704" style="zoom:67%;" />
</li>
<li>动态绑定实现原理：p-&gt;render()，把p所指对象的第一个地址取出来，从这个地址访问到vtable，从vtable+2访问到render（）的地址，然后调用这个地址上的render（）函数</li>
<li>不用在运行时知道对象的类型是什么，只是顺着这条线找到render（），这其实很快</li>
</ul>
</li>
<li>
<p>Circle</p>
<ul>
<li>
<pre><code class="language-c++">class Circle:public Ellipse&#123;public:	Circle (float radius) ;	virtual void render() ;	virtual void resize() ;	virtual float radius () ;protected:	float area;&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + &lt;img src=&quot;/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423201800385.png&quot; alt=&quot;image-20200423201800385&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ What happens if</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  Ellipse elly (20F, 40F) ;Circle circ (60F) ;elly = circ;// 10 in 5?  vptr不参与赋值传递</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>Area of circ is sliced off</p>
<ul>
<li>一(Only the part of circ that fits in elly gets copied)</li>
</ul>
</li>
<li>
<p>Vtable from circ is ignored; the vtable in elly is the Ellipse vtable</p>
<ul>
<li>
<pre><code class="language-c++">elly.render() ; // Ellipse::render ()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  #include &lt;iostream&gt;using namespace std;class A &#123;public:	A() : i(10) &#123;&#125;	virtual void f() &#123; cout &lt;&lt; &quot;A::f()&quot; &lt;&lt; i &lt;&lt; endl; &#125;	    int i;&#125;;class B: public A &#123;public:	B() : j(20) &#123;&#125;	virtual void f() &#123; cout &lt;&lt; &quot;B::f()&quot; &lt;&lt; j &lt;&lt; endl; &#125;	    int j;&#125;;int main( )&#123;    A a;    B b;        A* p = &amp;b;        p-&gt;f();        return 0；&#125;-----------------------------------------------------------------------------------------运行结果：-----------------------------------------------------------------------------------------Kai-MBA:CC weng kai$ . /a.outB::f( )20 ========================================================================================= #include &lt;iostream&gt;using namespace std;class A &#123;public:	A() : i(10) &#123;&#125;	virtual void f() &#123; cout &lt;&lt; &quot;A::f()&quot; &lt;&lt; i &lt;&lt; endl; &#125;	    int i;&#125;;class B: public A &#123;public:	B() : j(20) &#123;&#125;	virtual void f() &#123; cout &lt;&lt; &quot;B::f()&quot; &lt;&lt; j &lt;&lt; endl; &#125;	    int j;&#125;;int main( )&#123;    A a;    B b;        A* p = &amp;b;    p-&gt;f();        a = b;//只是把b的成员变量赋给了a，vptr不参与赋值        a.f();        return 0；&#125;----------------------------------------------------------------------------------------运行结果：----------------------------------------------------------------------------------------Kai-MBA:CC weng kai$ . /a.outB::f()20A::f( )10========================================================================================#include &lt;iostream&gt;using namespace std;class A &#123;public:	A() : i(10) &#123;&#125;	virtual void f() &#123; cout &lt;&lt; &quot;A::f()&quot; &lt;&lt; i &lt;&lt; endl; &#125;	    int i;&#125;;class B: public A &#123;public:	B() : j(20) &#123;&#125;	virtual void f() &#123; cout &lt;&lt; &quot;B::f()&quot; &lt;&lt; j &lt;&lt; endl; &#125;	    int j;&#125;;int main( )&#123;    A a;    B b;        A* p = &amp;b;    p-&gt;f();        a = b;//把b的成员变量赋给了a，vptr不参与赋值        p = &amp;a;    p-&gt;f();        return 0；&#125;----------------------------------------------------------------------------------------运行结果：----------------------------------------------------------------------------------------Kai-MBA:CC weng kai$ . /a.outB::f()20A::f( )10========================================================================================#include &lt;iostream&gt;using namespace std;class A &#123;public:	A() : i(10) &#123;&#125;	virtual void f() &#123; cout &lt;&lt; &quot;A::f()&quot; &lt;&lt; i &lt;&lt; endl; &#125;	    int i;&#125;;class B: public A &#123;public:	B() : j(20) &#123;&#125;	virtual void f() &#123; cout &lt;&lt; &quot;B::f()&quot; &lt;&lt; j &lt;&lt; endl; &#125;	    int j;&#125;;int main( )&#123;    A a;    B b;        A* p = &amp;a;    int* r = (int*)&amp;a;    int* t = (int*)&amp;b;    *r = *t;                  //把a的vptr指向的vtable改成指向b的vtable       p-&gt;f();//f()去找j，把对象a里成员变量i的下一块地址当成j，于是结果是32767    return 0；&#125;----------------------------------------------------------------------------------------运行结果：----------------------------------------------------------------------------------------Kai-MBA:CC wengkai$ ./a.outB::f()32767</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200424153049193.png" alt="image-20200424153049193" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>What happens with pointers?</p>
<ul>
<li>
<pre><code class="language-c++">Ellipse* elly = new Ellipse (20F，40F) ;Circle* circ = new Circle (60F) ;elly = circ;//两个对象没变，只是指针指过去
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ Well, the original Ellipse for elly is lost....</span><br><span class="line"></span><br><span class="line">+ elly and circ point to the same Circle object!</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    elly-&gt;render() ; // Circle::render ()</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
<li>
<p>Virtuals and reference arguments</p>
<ul>
<li>
<pre><code class="language-c++">void func (Ellipse&amp; elly)&#123;	elly.render () ;&#125;Circle circ (60F) ;func (circ) ;//circ::render()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + References act like pointers</span><br><span class="line"></span><br><span class="line">  + Circle::render() is called</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Virtual destructors</span><br><span class="line"></span><br><span class="line">  + Make destructors virtual if they might be inherited</span><br><span class="line"></span><br><span class="line">    ~~~c++</span><br><span class="line">    Shape *p = new Ellipse (100.0F，200.0F) ;...delete P;//如果这里Shape的析构不是virtual，这里的绑定是静态绑定，delete p时调用Shape的析构函数，子类Ellipse的析构函数丢掉了，没有被调用//如果是virtual的，delete p会根据对象的类型调用相应的析构函数//如果一个类有virtual函数，则必须声明析构函数是virtual//给以后程序修改，软件重用留口子//c++默认静态绑定，为了效率，因为静态比动态快//其它语言追求OOP语义，默认动态绑定</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>Want Ellipse: :~Ellipse() to be called</p>
<ul>
<li>Must declare Shape: :~Shape () virtual</li>
<li>It will call Shape: : ~Shape () automatically</li>
</ul>
</li>
<li>
<p>If Shape: : ~ Shape () is not virtual, only Shape: : ~Shape () will be invoked!</p>
</li>
</ul>
</li>
<li>
<p>Overriding</p>
<ul>
<li>
<p>Overriding redefines the body of a virtual function</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="keyword">public</span>:	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;<span class="keyword">public</span>:	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>;	<span class="comment">//overrides Base::func()&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Calls up the chain</p>
<ul>
<li>
<p>You can still call the overridden function:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">voidDerived: : <span class="built_in">func</span>() &#123;	cout &lt;&lt; <span class="string">&quot;In Derived: : func!&quot;</span>;	Base: : <span class="built_in">func</span>() ; <span class="comment">// call to base class &#125;//在overriding里想调父类的func加：</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>This is a common way to add new functionality</p>
<ul>
<li>No need to copy the old stuff !</li>
</ul>
</li>
<li>
<p>Return types relaxation(current)</p>
<ul>
<li>Suppose D is publicly derived from B</li>
<li>D::f()can return a subclass of the return type defined in B::f()</li>
<li>Applies to pointer and reference types
<ul>
<li>eg.  D&amp;,  D*</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Relaxation example</p>
<ul>
<li>
<pre><code class="language-c++">class Expr &#123;public:    virtual Expr* newExpr () ;//父类函数返回父类对象的指针    virtual Expr&amp; clone () ;//父类函数返回父类对象的引用    virtual Expr self() ;//父类函数返回父类对象自己&#125;;class BinaryExpr : public Expr &#123;            //子类overriding了public:	virtual BinaryExpr* newExpr() ;// Ok	virtual BinaryExpr&amp; clone() ;//Ok	virtual BinaryExpr self() ; // Error !&#125;;//因为只有通过指针或引用才构成upcast的关系，才能发生Polymorphism
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Overloading and virtuals</span><br><span class="line"></span><br><span class="line">  + Overloading adds multiple signatures</span><br><span class="line"></span><br><span class="line">    + ~~~c++</span><br><span class="line">      Class Basepublic:	virtual void func() ;	virtual void func (int) ;&#125;;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>If you override an overloaded function, you must override all of the variants!</p>
<ul>
<li>
<p>Can't override just one</p>
</li>
<li>
<p>If you don't override all, some will be hidden</p>
</li>
<li>
<p>如果一个类里有重载的两个虚函数</p>
<p>子类必须也要写这两个，如果只写一个，那么父类另一个会被屏蔽（name hidden）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="引用再研究">引用再研究</h3>
<ul>
<li>
<p>References as class members</p>
<ul>
<li>
<p>Declared without initial value</p>
</li>
<li>
<p>Must be initialized using constructor initializer list</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span><span class="keyword">public</span>:	<span class="keyword">int</span>&amp; m_y;	<span class="built_in">X</span>(<span class="keyword">int</span>&amp; a) ;&#125;;X::<span class="built_in">X</span>(<span class="keyword">int</span>&amp; a) : <span class="built_in">m_y</span>(a) &#123; &#125;<span class="comment">//成员变量是引用，必须用这样的代码去初始化</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Returning references</p>
<ul>
<li>
<p>Functions can return references<br>
-But they better refer to non-local variables!函数类型可以返回引用（和返回指针一样），但不能返回函数里本地变量的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span>const int SIZE = 32;double myarray[SIZE] ;double&amp; subscript (const int i) &#123;	return myarray [i] ;<span class="comment">//函数返回&amp;，return这里一定是个变量。这个变量的生存周期要比这个函数长&#125;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Example</p>
<ul>
<li>
<pre><code class="language-c++">main () &#123;	for(int i=0 ;i &lt; SIZE ;i++)&#123;	myarray[i] = i*0.5;&#125;	double value = subscript (12) ;//把myarray[12]的值赋给了value	    subscript (3) = 34.5;    //其实是myarray[3]=34.5;    //一个函数返回&amp;，这个函数就可以做左值&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ const in Functions Arguments</span><br><span class="line"></span><br><span class="line">  + Pass by const value -- don&#x27;t do it</span><br><span class="line"></span><br><span class="line">  + Passing by const reference</span><br><span class="line"></span><br><span class="line">    ~~~c++</span><br><span class="line">    Person( const string&amp; name, int weight );//传一个对象进函数，常用const &amp;（const保证不修改，&amp;相比指针看起来少*）</span><br></pre></td></tr></table></figure>

+ don't change the string object
+ more efficient to pass by reference (address) than to pass by value (copy)
+ const qualifier protects from change



</code></pre>
</li>
</ul>
</li>
<li>
<p>Const reference parameters</p>
<ul>
<li>
<p>What if you don’t want the argument changed?</p>
</li>
<li>
<p>Use const modifier</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//y is a constant! Can&#x27;t be modified.void func (const int&amp; y, int&amp; z) &#123;	z =z*5;// ok	y+=8;//error!&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Temporary values are const  内部有一个const int的临时变量存储这个值</p>
<ul>
<li>
<p>What you type</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span> &amp;)</span> </span>;<span class="built_in">func</span> (i * <span class="number">3</span>) ; <span class="comment">// Generates warning or error !</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>What the compiler generates</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span> &amp;)</span> </span>;<span class="keyword">const</span> <span class="keyword">int</span> tmp@ = i *<span class="number">3</span>;<span class="built_in">func</span> (tmp@) ; <span class="comment">// Problem -- binding const ref to non-const argument !//有一种解释是说会产生一个const int的临时变量tmp@存i*3的值，所以不能传给boid func（int &amp;），问题：那如果我的函数就是boid func（const int &amp;）行不行=========================================================================================#include &lt;iostream&gt;using namespace std;void f(const int &amp; i)//这个函数要一个int类型的引用，并且有const保证绝对不会修改你传进来的东西&#123;    //把const去掉会得到error    cout &lt;&lt; i &lt;&lt;endl;&#125;int main()&#123;    int i = 3;    f(i*3);        return 0;&#125;-----------------------------------------------------------------------------------------运行结果：-----------------------------------------------------------------------------------------9        //这是可以的，const int的变量可以给const int的引用</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>The temporary is constant, since you can’t access it</p>
</li>
</ul>
</li>
<li>
<p>const in Function returns  函数返回类型是const（即return一个const的value）</p>
<ul>
<li>
<p>return by const value</p>
<ul>
<li>
<p>for user defined types, it means &quot;prevent use as an value&quot;我返回的那个值你不能再修改</p>
</li>
<li>
<p>for built-in’s it means nothing</p>
</li>
<li>
<pre><code class="language-c++">#include &lt;iostream&gt;using namaspace std;class A&#123;public:    int i;    A() : i(0) &#123;&#125;&#125;;A f()&#123;    A a;    return a;&#125;int main()&#123;    A b;    b.i = 20;    f() = b;//f( )返回一个对象，可以做左值（这和A*/&amp; f()不一样，返回*or&amp;不行,因为离开这个函数，你指针指的or引用 的变量都消失了）    //f().i=10;    //20和21行，都是可以的。f()返回的那个对象a是存在的，但你无法访问到它，它失踪了    return 0;&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + return by const pointer or reference</span><br><span class="line"></span><br><span class="line">    - depends on what you want your client to do with the return value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 拷贝构造</span><br><span class="line"></span><br><span class="line">+ Copying</span><br><span class="line">  + Create a new object from an existing one</span><br><span class="line">    一For example, when calling a function</span><br><span class="line">    + &lt;img src=&quot;/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200424165109693.png&quot; alt=&quot;image-20200424165109693&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ **Initialization初始化**和**assignment赋值**</span><br><span class="line"></span><br><span class="line">  + 标志：在**定义变量时**给它值，Initialization初始化</span><br><span class="line"></span><br><span class="line">    ​		**定义好了**在给它值，assignment赋值</span><br><span class="line"></span><br><span class="line">  + 区别：任何对象**Initialization初始化**只有一次，后面在给值叫**assignment赋值**</span><br><span class="line"></span><br><span class="line">  + 初始化时=和（）等价</span><br><span class="line"></span><br><span class="line">    + Person baby_b = baby_a;     $\Leftrightarrow$    Person baby_c(baby_a);</span><br><span class="line"></span><br><span class="line">    + 主要看第54行</span><br><span class="line"></span><br><span class="line">      ~~~c++</span><br><span class="line">      //: C11: HowMany.cpp// From Thinking in C++, 2nd Edition// Available at http: //www. BruceEckel. com// (c) Bruce Eckel 2000// Copyright notice in Copyright. txt// A class that counts its objects#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;static int objectCount =0;class HowMany &#123;public:    HowMany()     &#123;        objectCount++;                //记录制作对象的个数        print (&quot;HowMany()&quot;);          //显示调用了构造函数    &#125;        HowMany(int i)          //新加这样一个构造函数    &#123;        objectCount++;                //记录制作对象的个数        print (&quot;HowMany()&quot;);          //显示调用了构造函数    &#125;    	void print(const string&amp; msg = &quot;&quot;)     &#123;        if(msg.size() != 0)             cout &lt;&lt; msg &lt;&lt; &quot;: &quot;;		cout &lt;&lt; &quot;objectCount = &quot;&lt;&lt; objectCount &lt;&lt; endl;	&#125;    	~HowMany()     &#123;	        objectCount--;              		print(&quot;~HowMany()&quot;);    &#125;&#125;;// Pass and return BY VALUE:HowMany f (HowMany x)          //要一个HowMany对象的输入，返回也是一个Howmany的对象&#123;    cout &lt;&lt; &quot;begin of f&quot; &lt;&lt;endl;	x.print(&quot;x argument inside f()&quot;);	cout &lt;&lt; &quot;end of f&quot; &lt;&lt;endl;	return X;&#125;int main() &#123;	HowMany h;	h.print(&quot;after construction of h&quot;) ;	HowMany h2（10）    //HowMany h2 = 10;    和53行的代码等价，表面上看10是int，h2是一个对象。实际上h2就是要一个int型的参数 	h.print(&quot;after call to f()&quot;);&#125;///:~</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>引例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: C11: HowMany.cpp// From Thinking in C++, 2nd Edition// Available at http: //www. BruceEckel. com// (c) Bruce Eckel 2000// Copyright notice in Copyright. txt// A class that counts its objects#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;static int objectCount =0;class HowMany &#123;public:    HowMany()     &#123;        objectCount++;                //记录制作对象的个数        print (&quot;HowMany()&quot;);          //显示调用了构造函数    &#125;    	void print(const string&amp; msg = &quot;&quot;)     &#123;        if(msg.size() != 0)             cout &lt;&lt; msg &lt;&lt; &quot;: &quot;;		cout &lt;&lt; &quot;objectCount = &quot;&lt;&lt; objectCount &lt;&lt; endl;	&#125;    	~HowMany()     &#123;	    	objectCount--;              		print(&quot;~HowMany()&quot;);    &#125;&#125;;// Pass and return BY VALUE:HowMany f (HowMany x)          //要一个HowMany对象的输入，返回也是一个Howmany的对象&#123;    cout &lt;&lt; &quot;begin of f&quot; &lt;&lt;endl;	x.print(&quot;x argument inside f()&quot;);	cout &lt;&lt; &quot;end of f&quot; &lt;&lt;endl;	return X;&#125;int main() &#123;	HowMany h;	h.print(&quot;after construction of h&quot;) ;	HowMany h2 = f(h);	h.print(&quot;after call to f()&quot;);&#125;///:~---------------------------------------------------------------------------------------------运行结果：---------------------------------------------------------------------------------------------HowMany(): objectCount = 1after construction of h: objectCount = 1begin of fx argument inside f(): objectCount = 1end of f~HowMany(): objectCount = 0after call to f() : obj ectCount = 0~HowMany(): obj ectCount = -1~HowMany(): objectCount = -2        //不平衡？？</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>The copy constructor</p>
<ul>
<li>
<p>Copying is implemented by the copy constructor</p>
</li>
<li>
<p>Has the unique signature</p>
<ul>
<li>
<pre><code class="language-c++">T::T (const T&amp;) ;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + Call-by-reference is used for the explicit argument</span><br><span class="line"></span><br><span class="line">+ C++ builds a copy ctor for you if you don&#x27;t provide one!     </span><br><span class="line"></span><br><span class="line">  c++默认会给拷贝构造函数，做的事情是**拷贝每一个成员变量**。有些东西你不想拷贝或者有些东西有特别的安排可以自己写拷贝构造函数。</span><br><span class="line"></span><br><span class="line">  + Copies each member variable</span><br><span class="line"></span><br><span class="line">    + Good for numbers, objects, arrays</span><br><span class="line"></span><br><span class="line">    + 如果**自己类（假设为类A）的成员变量**是int，会把int拷贝给int；如果是float类型，会把float拷贝给float；</span><br><span class="line"></span><br><span class="line">    + 如果**这个成员变量是其他类（假设为类B）的对象**，会让那个类（类B）的拷贝构造函数拷贝构造那个对象，即这个拷贝构造会递归下去（A的拷贝构造函数--&gt;B的拷贝构造函数）mark动手代码实现。</span><br><span class="line"></span><br><span class="line">      **这是成员级别上的拷贝，而不是bit字节对bit字节的拷贝**（只不过如果类A成员变量没有其他类的对象，是int、float什么的，最终结果和字节对字节的拷贝一样）</span><br><span class="line"></span><br><span class="line">  + Copies each pointer</span><br><span class="line"></span><br><span class="line">    + Data may become shared!  两个指针指向同一块内存</span><br><span class="line"></span><br><span class="line">+ 不是这种形式</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    class A&#123;public:    A(A o)&#123;&#125;;  //A(const A&amp; b);&lt;--默认有的&#125;;//你想传参数调用拷贝构造，却调用A(A o)&#123; &#125; 这个构造函数 ，这个构造函数需要对象作为参数，又传参给这个类去调用自身的拷贝构造，循环，导致递归=======================================================================================  error:invalid constructor;you probably meant &#x27;A(const A&amp;)&#x27;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>What if class contains pointers?  成员变量有指针.&amp;同理</p>
<ul>
<li>
<p>Choices</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200424173736430.png" alt="image-20200424173736430" style="zoom:50%;" />
</li>
<li>
<p>如果<strong>成员变量有指针</strong>，默认的拷贝后结果是<strong>两个指针指向同一块内存</strong>（图左）</p>
<ul>
<li>要加一个拷贝构造函数，去处理指针的问题（图右）。因为默认的拷贝构造函数不会去做申请一块内存这种复杂动作</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.h#ifndef_ PERSON_ _H #define_ PERSON_ _H class Person &#123;public:	Person(const char *s);	~Person();	void print() ;	// ... accessor funct ions//private:	char *name ;   // char * instead of string，注意这里是char类型指针而不是char类型	//... more info e.g. age, address, phone   其他信息&#125;;#endif=============================================================================================//Person.cpp    #include &quot;Person. h&quot;#include &lt;cstring&gt;        // #include &lt;string. h&gt;using namespace std; //构造函数，要用你送进来的字符串指针去初始化对象里的namePerson::Person( const char *s ) &#123;	name = new char[::strlen(s) + 1];  //【new一块John&quot;+1即大小为5的char类型的空间给    								 //name指针】	: :strcpy(name, s);                //让指针name的地址=s的地址，即name指向s指向的内存&#125;Person: :~Person() &#123;	delete [ ] name;    // array delete&#125;=============================================================================================//main.cpp    #include &lt;stdio. h&gt;#include &quot;person. h&quot;int main( )&#123;	Person p1(&quot;John&quot;);	    Person p2(p1);      //对象p1里的name指针指向“John”，拷贝构造后对象p2里的name指针也指向”                        //“John”    printf (&quot;p1.name=%p\n&quot;, p1.name) ;	printf(&quot;p2.name= :%p\n&quot;，p2.name ) ;    	return 0;&#125;//对象释放时，析构被调用，delete对象p1里的name指针，delete对象p2里的name指针，但它们指着同一块内存，所以同一块内存delete了两次，报错---------------------------------------------------------------------------------------------//运行结果：p1.name=0x7f90084000e0p2.name=0x7f90084000e0    //证明指向同一块内存a. out(10067) malloc: *** error for object 0x7f90084000e0: pointer //错误因为同一块内存free了两次eing freed was not allocated*** set a breakpoint in malloC_ error_ break to debugAbort trap: 6============================================================================================= //正确做法：加一个拷贝构造函数。这样被指的东西也复制了一份    //●To person declaration add copy ctor prototype:    Person(const Person&amp; w);  //copy ctor//●To Person.cpp add copy ctor defintionPerson::Person(const Person&amp; w)&#123;    name = new char[::strlen(w.name)+1];    ::strcpy(name,w.name);&#125;//传同类的另一个对象p1进来，得到p1里面name的长度去初始化创建p2 name的内存，然后做拷贝//●No value returned//●Accesses w.name across client boundary//●The copy ctor initializes uninitialized memory//private是针对类而不是对象，访问同类另一个对象private的东西是ok的</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Character strings</p>
<ul>
<li>In C++, a character string is
<ul>
<li>An array of characters</li>
<li>With a special terminator— ‘\0’ or ASCII null
<ul>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200424165936411.png" alt="image-20200424165936411" style="zoom:50%;" />
</li>
</ul>
</li>
</ul>
</li>
<li>The string “C++” is represented, in memory, by an array of four (4, count’em) characters</li>
</ul>
</li>
<li>
<p>Standard C library String fxns</p>
<ul>
<li>
<p>Declared in <cstring>（C的标准款string.h，不过会有点不同，eg.某个参数有const；返回类型是size_t而不是int，给今后改成非int留下空间）</p>
<ul>
<li>
<pre><code class="language-c++">size_t strlen(const char *s);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + s is a null-terminated string</span><br><span class="line">  + returns the length of s</span><br><span class="line">  + length does not include the terminnator!</span><br><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  char *strcpy (char *dest,const char *src)</span><br></pre></td></tr></table></figure>

+ Copies src to dest stopping after the terminating null-character is copied. (src should be null-terminated!)
+ dest should have enough memory space allocated to contain src string.，
+ Return Value: returns dest




</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>When are copy ctors called?</p>
<ul>
<li>
<p>函数形参是对象，调用这个函数时</p>
<ul>
<li>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200425134735028.png" alt="image-20200425134735028" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>During initialization</p>
<ul>
<li>
<pre><code class="language-c++">Person baby_ a (&quot;Fred&quot;) ;// these use the copy ctorPerson baby_ b = baby_ a; // not an assignmentPerson baby_ C( baby_ a) ;// not an assignment
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    &lt;img src=&quot;/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200425134918145.png&quot; alt=&quot;image-20200425134918145&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">+ During function return(函数返回一个对象)</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200425135111465.png&quot; alt=&quot;image-20200425135111465&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  + Copies and overhead</span><br><span class="line"></span><br><span class="line">    + Compilers can &quot;optimize out&quot; copies when safe!</span><br><span class="line"></span><br><span class="line">      + **optimeize out** 编译器会把它认为不必要的拷贝构造给优化掉</span><br><span class="line"></span><br><span class="line">      + Example</span><br><span class="line"></span><br><span class="line">        ~~~c++</span><br><span class="line">        Person copy_func( char *who )&#123;	Person local ( who ) ;   //who不是对象，初始化对象local不发生拷贝构造	local .print() ;	return local;             // copy ctor called!  &#125;// 返回对象local出去，初始化对象p的时候会调用拷贝构造---------------------------------------------------------------------------------Person nocopy_func( char *who ) &#123;	return Person( who ) ;&#125;                             //no copy needed ! ---------------------------------------------------------------------------------//外头    Person p = copy_func(&quot;x&quot;); //nocopy func返回的是一个Person @tmp（who），在用这个临时对象去初始化下面那个p对象。但因为在nocopy func里你没使用过这个对象，所以编译器一步到位，直接用who去初始化对象p，跳过了这个临时变量@tmp的拷贝构造</span><br></pre></td></tr></table></figure>

+ Programmers need to

  - Program for &quot;dumb&quot; compilers
  - Be ready to look for optimizations



</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Constructions VS. assignment</p>
<ul>
<li>Every object is constructed once</li>
<li>Every object should be destroyed once
<ul>
<li>Failure to invoke delete()</li>
<li>Invoking delete() more than once</li>
</ul>
</li>
<li>Once an object is constructed, it can be the target of many assignment operations</li>
</ul>
</li>
<li>
<p>Person:string name</p>
<ul>
<li>
<p>What if the name was a string (and not a char*)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>class Person &#123;public:	Person( const string&amp; );	~Person();	void print();	<span class="comment">// ... other accessor fxnsprivate:	string name;	// embedded object (composition)//..other data members...&#125;;//成员变量是系统类库里的string类，则不需要人为加拷贝构造函数,因为拷贝构造是成员级别上的拷贝，它可以拷贝string成员。（string是系统内库，库里有相应的拷贝构造函数，它能把这件事做好）//建议：在c++不使用c以前的string.h。用string类来做事情，string会自己take care of everything，包括拷贝构造的事情）// 用char*除非你要动内存or要做二进制的事情（Byte *，只不过Byte *在c和c++表现为char *）。//用字符串请使用string</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Copy ctor guidelines</p>
<ul>
<li>In general, be explicit
<ul>
<li>Create your own copy ctor – don’t rely on the default  每写一个类，就为这个类写一个copy constructor，别太依赖默认的</li>
</ul>
</li>
<li>If you don’t need one declare a private copy ctor
<ul>
<li>prevents creation of a default copy constructor</li>
<li>generates a compiler error if try to pass-by-value</li>
<li>don’t need a defintion</li>
<li>把copy constructor访问属性设置为private，别人不能拷贝你的对象
<ul>
<li>别人无法弄一个函数，这个函数的参数是对象本身，因为拷贝构造函数被禁止了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="静态对象">静态对象</h3>
<ul>
<li>
<p>Static在C的两义（在哪和谁能看到两回事）</p>
<ul>
<li>持久存储
<ul>
<li>如果说一个本地变量是static的，那么这个本地变量具有持久存储。实际上，static 本地变量就是全局变量</li>
</ul>
</li>
<li>访问性受局限
<ul>
<li>如果说一个全局变量/函数是static的，说明这个全局变量/函数只在这个.c文件有效</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Static in C++</p>
<p>Two basic meanings</p>
<ul>
<li>Static storage
<ul>
<li>allocated once at a fixed address</li>
</ul>
</li>
<li>Visibility of a name
<ul>
<li>internal linkage</li>
</ul>
</li>
<li>Don’t use static except inside functions and classes</li>
</ul>
</li>
<li>
<p>Uses of “static” in C++</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Static free functions</td>
<td><s>Internal linkage</s> (deprecated过时了)</td>
</tr>
<tr>
<td>Static global variables全局变量</td>
<td><s>Internal linkage</s>(deprecated)</td>
</tr>
<tr>
<td>Static local variables本地变量</td>
<td>Persistent storage持久存储</td>
</tr>
<tr>
<td>Static member variables成员变量</td>
<td>Shared by all instances所有对象间共享</td>
</tr>
<tr>
<td>Static member function成员函数</td>
<td>Shared by all instances, can  only access static member  variables只能访问静态成员变量or静态成员函数</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Global static hidden in file</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200425142233717.png" alt="image-20200425142233717" style="zoom:50%;" />
<ul>
<li>在File2 extern int g_global;就可以在File2中使用File1中的g_global</li>
<li>但在File1中int s_local是static的，即s_local只能在File1中使用，File2extern了能骗过编译器，但到ld链接器那关会出问题</li>
</ul>
</li>
<li>
<p>Static inside functions</p>
<ul>
<li>
<p>Value is remembered for entire program</p>
</li>
<li>
<p>Initialization occurs only once</p>
</li>
<li>
<p>Example:</p>
<ul>
<li>
<p>count the number of times the function has been called</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;    staic <span class="keyword">int</span> num_calls = <span class="number">0</span>;    ...    num_calls++;&#125;<span class="comment">//全局变量，但只能在函数里访问</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Static applied to objects</p>
<ul>
<li>
<p>Suppose you have a class</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>	<span class="built_in">X</span>(<span class="keyword">int</span>， <span class="keyword">int</span>) ;	~<span class="built_in">X</span>() ;    ...&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>And a function with a static X object</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;	    <span class="function"><span class="keyword">static</span> X my_ <span class="title">X</span><span class="params">(<span class="number">10</span>，<span class="number">20</span>)</span> </span>;	...&#125;<span class="comment">//在链接器时，分配my_x的空间。//第一次进函数时，初始化my_x//只初始化一次，存储是全局的，如果后面再次调这个函数不初始化。//在目前c++格局下不知道对象有没有初始化过。所以需要一个伴随的变量知道这个对象有没有初始化过，见下面的Conditonal construction-Example//当你以后设计自己的OOP语言，你可以考虑给每个对象来一个hidden的变量，表示你这个对象有没有初始化过//JAVA不需要，因为JAVA会保证不会让你去用没有初始化过的内存</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Static applied to objects…   static 对象</p>
<ul>
<li>Construction occurs when definition is encountered
<ul>
<li>Constructor called at-most once   构造只发生一次，有构造就会有析构</li>
<li>The constructor arguments must be satisfied</li>
</ul>
</li>
<li>Destruction takes place on exit from program    析构在程序结束时发生
<ul>
<li>Compiler assures LIFO order of destructors</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Conditional construction  有条件的构造</p>
<ul>
<li>
<p>Example：conditional construction</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;    <span class="keyword">if</span>(x&gt;<span class="number">10</span>)    &#123;        <span class="function"><span class="keyword">static</span> X <span class="title">my_X</span><span class="params">(x,x*<span class="number">21</span>)</span></span>;        ...    &#125;&#125;<span class="comment">//x作为伴随的变量，通过x可以知道这个对象有没有初始化过</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>my_X</p>
<ul>
<li>is constructed once,if f() is ever called with x&gt;10</li>
<li>retains its value</li>
<li>destroyed only if constructed</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Global objects  全局对象</p>
<ul>
<li>
<p>Consider</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;X.h&quot;</span>X glocal_x(12, 34);X global_x2(8, 16);</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Constructors are called before main()is entered</p>
<p>链接时分配空间，空间在全局数据区</p>
<p>全局对象的构造在程序一运行时执行，在main()之前，且只执行一次</p>
<ul>
<li>Order controlled by appearance in file</li>
<li>In this case,global_x before global_x2</li>
<li>main() is no longer the first function called</li>
</ul>
</li>
<li>
<p>Destructors called when      main()结束  or  exit()时调用析构     (即程序结束调用析构）</p>
<ul>
<li>main() exits</li>
<li>exit() is called</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Static Initialization Dependency</p>
<ul>
<li>
<p>Order of construction within a file is known</p>
</li>
<li>
<p>Order between files is unspecified!</p>
</li>
<li>
<p>Problem when non-local static objects in different files have dependencies</p>
</li>
<li>
<p>A non-local static object is :</p>
<ul>
<li>defined at global or namespace scope</li>
<li>declared static in a class</li>
<li>defined static at file scope</li>
</ul>
</li>
<li>
<p>跨文件初始化全局对象（如果你的程序有多个.cpp文件，每个文件里都有一个全局变量）</p>
<ul>
<li>这些全局对象的初始化顺序没有规矩</li>
<li>如果你的这些全局对象初始化互相有依赖，比如某个对象的初始化要用另一个对象作为它构造函数的参数，就要那个对象先得到初始化，解决办法：
<ul>
<li>别这么干</li>
<li>在逻辑许可的前提下，把所有有依赖的全局变量放在同一个地方</li>
<li>JAVA怎么做，JAVA没全局变量，就没这种问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="静态成员">静态成员</h3>
<ul>
<li>
<p>Can we apply static to members?</p>
<ul>
<li>Static means
<ul>
<li>Hidden  隐藏
<ul>
<li>在c++stactic的Hidden任务结束了，通过类的访问属性public、private、protected就可以完成Hidden这个任务</li>
</ul>
</li>
<li>Persistent  持久存储
<ul>
<li>对于一种在函数之间流转的语言来说，函数之间仍然存在的东西叫persistent。eg.c语言中是指全局变量和malloc的东西</li>
<li>对于一种在对象之间流转的语言来说，对象和对象之间还能存在的东西叫persisten。</li>
<li>类的不同对象之间的成员变量是Persistent保持一致的，不随对象的不同而不同。另外一种说法是这个static 的成员变量是class-wide，整个类领域里的东西。（其实是做了一个全局变量，让这个全局变量是类的成员，这样在一个对象里修改了，表象上看所有其他对象里这个值也改了）</li>
</ul>
</li>
</ul>
</li>
<li>Hidden：A static member is a member
<ul>
<li>Obeys usual access rules</li>
</ul>
</li>
<li>Persistent：Independent of instances</li>
<li>Static members are class-wide
<ul>
<li>variables or</li>
<li>functions</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Static members</p>
<ul>
<li>
<p>Static member variables</p>
<ul>
<li>
<p>Global to all class member functions</p>
</li>
<li>
<p>Initialized once,at file scope</p>
</li>
<li>
<p>provide a place for this variable and init it in .cpp</p>
</li>
<li>
<p>No ‘static’ in .cpp</p>
</li>
<li>
<p>Example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std;class A&#123;public:    A() &#123;i= 0; &#125;	void print() &#123; cout <span class="meta-string">&lt;&lt; &lt; i &lt;&lt; endl; &#125;	void set(int ii) &#123; i= ii; &#125;private:	static int i;&#125;;int main()&#123;    A a,b;    	a.set(10);	b.print();    	return 0;&#125;----------------------------------------------------------------------------------------Undefined symbols for architecture x86_ _64:	&quot;A::i&quot;， referenced f rom: .		A::A()	in ccQeG7fH.0 .			A::set(int)	in ccQeG7fH. 0		A::print()	in ccQeG7fH. 0ld: symbol(s) not found for architecture x86_ 64   //重点在这一句collect2: ld returned 1 exit status========================================================================================    //类里的都是declaration，并且static的成员变量在全局数据区。    //编译能通过但ld链接器会找不到这个全局变量    //类有static成员变量，要在某个.cpp文件里写上这个成员变量的defination======================================================================================== #include &lt;iostream&gt;</span>using namespace std;class A&#123;public:    A() &#123;i= 0; &#125;	void print() &#123; cout <span class="meta-string">&lt;&lt; &lt; i &lt;&lt; endl; &#125;	void set(int ii) &#123; i= ii; &#125;        //void set(int i) &#123; this-&gt;</span>i= i; &#125;    <span class="comment">//this指针可以访问静态和非静态的成员变量,静态变量仍然是类的成员变量private:	static int i;&#125;;//int A::i;要加上这一句defination,否则报错如下代码区所示//可以在定义时候初始化int A::i=10;int main()&#123;    A a,b;    	a.set(10);	b.print();    	return 0;&#125;  ========================================================================================static int A::i;//如果加的是这句，表示这个东西只能在这个.cpp文件里访问，这与类的静态成员访问属性(private)违背，因为类的静态成员可能会被外部（除这个.cpp文件外的东西）访问。会报错为：Kai-MBA:CC wengkai$ g++ a.cppa.cpp:14: error:&#x27;static&#x27; may not be used when defining (as opposed to declaring)a static data member========================================================================================//如果在Initializer list去初始化这个静态成员变量，则报错。因为Initializer list只能对非静态成员作初始化Kai-MBA:CC wengkai$ g++ a. cppa.cpp: In constructor &#x27;A: :A()&#x27; :a.cpp:7: error: &#x27;int A::i&#x27; is a static data member; it can only be initialized at its definition========================================================================================//静态成员变量/函数是public，在类以外有两种方式访问它:    a.i//通过具体某个对象or    A::i//通过类的名字加：：去访问</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>静态成员函数</p>
<ul>
<li>静态成员函数只能调静态成员函数、访问静态成员变量（表面上）</li>
<li>原因：静态成员函数因为可以通过类的名字加::去调用，所以静态成员函数是没有this这个hidden parameter，所以在这个函数里你无法访问其它非静态成员变量</li>
<li>我们需要有一些东西是它和类的对象存在与否无关的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="重载">重载</h2>
<h3 id="运算符重载——基本规则">运算符重载——基本规则</h3>
<ul>
<li>
<p>Overloading Operators</p>
<ul>
<li>
<p>Allows user-defined types to act like bulit in types</p>
</li>
<li>
<p>Another way to make a function call.</p>
</li>
<li>
<p>Unary and binary operators can be overloaded:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+  -  *  /  %  ^  &amp;  |  ~=  &lt;  &gt;  +=  -=  *=  /=  %=^=  &amp;=  |=  &lt;&lt;  &gt;&gt;  &gt;&gt;=  &lt;&lt;=  ==!=  &lt;= &gt;=  !  &amp;&amp;  ||  ++  --,  -&gt;*  -&gt;  ()  []operator new         operator deleteoperator new[]       operator delete[]^异或 ~取反&lt;&lt;（左移or insert）, 运算符，表达式连接，结果是右边那个()函数传参数的时[]数组索引</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Operators you can’t overload</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.  .*  ::  ?:<span class="keyword">sizeof</span>  typeidstatic_cast  <span class="keyword">dynamic_cast</span>  const_castreinterpret_cast</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Restrictions</p>
<ul>
<li>
<p>Only existing operators can be overloaded(you can’t create a ** operator for exponentiation)</p>
<p>只能重载已有的运算符</p>
</li>
<li>
<p>Operators must be overloaded on a class or enumeration type</p>
<p>只能对类或枚举类型里的运算符进行重载</p>
</li>
<li>
<p>Overloaded operators must</p>
<ul>
<li>
<p>Preserve number of operands</p>
<p>保持运算符原来的操作数</p>
</li>
<li>
<p>Preserve precedence</p>
<p>保持原来的优先级</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>C++ overloaded operator</p>
<ul>
<li>
<p>Just a function with an operator name!</p>
<ul>
<li>Use the <strong>operator</strong> keyword as a prefix to name<br>
operator * (…)     //重载*运算符</li>
</ul>
</li>
<li>
<p>Can be a member function</p>
<ul>
<li>
<p>Implicit first argument</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> String String::<span class="keyword">operator</span> + (<span class="keyword">const</span> String&amp; that) ;<span class="comment">//非静态成员函数自带this，因为+法要两个算子，所以还需要一个that</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Can be a global (free) function</p>
<ul>
<li>
<p>Both arguments explicit</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> String <span class="keyword">operator</span>+ (<span class="keyword">const</span> String&amp; r, <span class="keyword">const</span> String&amp; <span class="number">1</span>) ;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>How to overload</p>
<ul>
<li>As member function
<ul>
<li>lmplicit first argument</li>
<li>No type conversion performed on receiver</li>
<li>Must have access to class definition</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Operators as member functions</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> &#123;</span><span class="keyword">public</span>:	<span class="built_in">Integer</span>(<span class="keyword">int</span> n=<span class="number">0</span>):<span class="built_in">i</span>(n)&#123;&#125;	<span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer&amp; n) <span class="keyword">const</span>&#123;<span class="comment">//加法不会改变两个算子，所以Interger&amp; n 前有const，this也有const（加在函数结尾）    //前面这个const，让函数返回结果不能做左值，eg.a+b=6，在程序设计中是错的，不能有的	return Integer (i + n.i) ;&#125;    ...private :	int i;&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Member Functions</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">x</span><span class="params">(<span class="number">1</span>)</span> ，<span class="title">y</span><span class="params">(<span class="number">5</span>)</span> , z</span>;x+y;     ====&gt; x.<span class="keyword">operator</span>+(y) ;<span class="comment">//operator+   函数//运算符左边那个算子叫receiver，它的类型决定用哪个+</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Implicit first argument</p>
</li>
<li>
<p>Developer must have access to class definition</p>
</li>
<li>
<p>Members have full access to all data in class</p>
</li>
<li>
<p>No type conversion performed on receiver</p>
<ul>
<li>z=x+y;✔（receiver是x，用的是Integer的+）</li>
<li>z=x+3;✔（用的是Integer的+，3不能直接用，会把3用构造函数Integer(int n=0):i(n){}构造成一个Integer的对象，让x和这个匿名的（没有变量）对象做Integer的operator +，然后赋给对象z）
<ul>
<li>z=x+3.5;不行，因为构造函数入口是int类型</li>
<li>z=x+3,构造函数是double n=0；也不行。int类型的3可以变成double类型的3（第一次自动类型转换）（窄的数据类型可以自动转换成宽的，宽的不能变窄的），然后double的3变成Integer类的3，（第二次自动类型转换）。只能有一次自动类型转换，两次不行</li>
</ul>
</li>
<li>z =3+y;✖（receiver是3，用的是系统默认的+，再发现右边的算子是Integer，需要Integer这个类里有一个手段把对象y变成int，这里没有，所以这个式子编译通不过）</li>
</ul>
</li>
<li>
<p>For binary operators (+, -, *,etc) member functions require one argument.二元运算符要1个参数（还有1个this）</p>
</li>
<li>
<p>For unary operators (unary -, !, etc) member functions require no arguments:一元不需要，对自己做运算的结果，制造成新的值交给别人，注意不改变自己！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>- () <span class="keyword">const</span> &#123;    <span class="keyword">return</span> <span class="built_in">Integer</span> (-i) ;&#125;  ...  z=-x;<span class="comment">// z.operator= (x. operator-()) ;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>How to overload</p>
<ul>
<li>
<p>As a global function</p>
<ul>
<li>Explicit first argument</li>
<li>Type conversions performed on both arguments</li>
<li>Can be made a friend</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Operator as a global function</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer&amp; rhs,<span class="keyword">const</span> Integer&amp; lhs) ;<span class="comment">//左右两边算子都要写Integer x，y;x+y        ====&gt; operator+(x, y) ;//运算符重载是全局函数，可以不用修改一个类里的代码，直接给这个类加上这个运算符重载  //前提：能接触到类里的成员  //比如这个类有get函数能让外部访问它的成员变量  //左右两个算子都可以转换类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Explicit first argument</li>
<li>Developer does not need special access to classes .</li>
<li>May need to be a friend</li>
<li>Type conversions performed on both arguments .</li>
</ul>
</li>
<li>
<p>Global operators（friend）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> &#123;</span>	<span class="keyword">friend</span> <span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer&amp; lhs,<span class="keyword">const</span> Integer&amp; rhs) ;    ...&#125;<span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer&amp; lhs,<span class="keyword">const</span> Integer&amp; rhs)&#123;	<span class="keyword">return</span> <span class="built_in">Integer</span>( lhs.i + rhs.i ) ;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Global Operators</p>
<ul>
<li>binary operators require two arguments</li>
<li>unary operators require one argument</li>
<li>conversion:<br>
z =x+y;✔<br>
z=x+3;✔<br>
z=3+y;✔（如果receiver是3，做不了；如果receiver是y，把3变成Integer，可以做，那就用这个做）<br>
z=3+7;✔（3+7完是10，再把10转成Integer赋给z）</li>
<li>If you don’t have access to private data members, then the global function must use the public interface (e.g. accessors)</li>
</ul>
</li>
<li>
<p>Tips:Members vs. Free Functions</p>
<ul>
<li>Unary operators <strong>should be</strong> members     单目的should be 成员函数</li>
<li>= ()  []  -&gt;  -&gt;* must be members     必须是成员函数（不是成员没法做）</li>
<li>assignment operators should be members</li>
<li>All other binary operators as non-members     其他二元运算符做成非成员函数（因为相比于做成成员函数，全局函数，左右两个算子都可以做receiver）</li>
</ul>
</li>
</ul>
<h3 id="运算符重载——原型">运算符重载——原型</h3>
<ul>
<li>
<p>Argument Passing</p>
<ul>
<li>if it is trad-only pass it in as a const reference(except bulit-ins)  传进函数的参数一定是对象，所以是const 的引用</li>
<li>make member functions const that don’t change the class (boolean operators, +, -, etc)  不修改算子，函数结尾加上const（给this的），还有另外一个参数也要const</li>
<li>for global functions, if the left-hand side changes pass as a reference (assignment operators)</li>
</ul>
</li>
<li>
<p>Return Values  return的values是改变传进来的对象还是制造新的对象，如果是新的对象，能不能作左值？</p>
<ul>
<li>
<p>Select the return type depending on the expected meaning of the operator. For example,</p>
<ul>
<li>
<p>For operator+ you need to generate a new object.   //比如重载+号，是制造出一个新的对象，而且不能做作左值</p>
<p>Return as a const object so the result cannot be modified as an Ivalue.</p>
</li>
<li>
<p>Logical operators should return bool (or int for older compilers). 逻辑运算返回布尔量</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>The prototypes of operators  常见operators原型</p>
<ul>
<li>
<p>±*/%^&amp;|~</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> T <span class="title">operatorX</span><span class="params">(<span class="keyword">const</span> T&amp; I, <span class="keyword">const</span> T&amp; r)</span> <span class="keyword">const</span></span>;<span class="comment">//返回的不能左左值			//传对象，const（防开销） &amp;（清爽）										//不会修改算子//返回的不是引用，是新对象</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>!  &amp;&amp;  ||  &lt;  &lt;=  ==  &gt;=  &gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operatorX</span><span class="params">(<span class="keyword">const</span> T&amp; I, <span class="keyword">const</span> T&amp; r)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>[]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T&amp; T::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)    <span class="comment">//参数是个int    //一定是&amp;。并且我们要拿它作左值，所以函数最前面没const</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>operators ++ and –</p>
<ul>
<li>
<p>How to distinguish postfix from prefix?</p>
</li>
<li>
<p>postfix forms take an int argument – compiler will pass in 0 as that int</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> &#123;</span><span class="keyword">public</span>:    ...	<span class="keyword">const</span> Integer&amp; <span class="keyword">operator</span>++ () ;<span class="comment">//prefix++   //eg.++a，先+后用（返回），即返回a加了以后的结果（自身变了），返回a的引用即可（可以不用&amp;，但用&amp;更节约，环保）。前面的const表示禁止拿它做左值，eg.++a=6，这不行    const Integer operator++ (int) ; //postfix++  //eg.a++,返回加以前的结果，对象变了，返回新对象 	    		    //这个int只是让编译器知道是prefix还是postfix    const Integer&amp; operator--() ; //prefix--          const Integer operator--(int) ; //postfix--    ...&#125;;const Integer&amp; Integer::operator++ () &#123;    *this += 1;// increment   this是指针，*this是它所指的对象（这里只是用*this表示对象里的成员变量，实际代码不是这样子写，对象和1没法+=）    return *this ;// fetch&#125;// int argument not used so leave unnamed so// won&#x27;t get compiler warningsconst Integer Integer::operator++( int ) &#123;	Integer old( *this ) ; // fetch   //调用拷贝构造函数，制作一个新的对象	++ (*this) ;// increment   调用13行的函数。	return old;// return了原始的值    old对象只在这个函数里有效，返&amp;返不出去    &#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>附&lt;<a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/increment-decrement-operators-overloading.html">https://www.runoob.com/cplusplus/increment-decrement-operators-overloading.html</a>&gt;</p>
<ul>
<li>
<p>Using the overloaded ++ and –</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decrement operators similar to increment	Integer x(5) ;	++x;		// calls x.operator++() ;	x++;		// calls x.operator++(0) ;	--x;		// calls x.operator--() ;	x--;		// calls x.operator--(0) ;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>User-defined prefix is more efficient than postfix.</li>
</ul>
</li>
<li>
<p>Relational operators</p>
<ul>
<li>
<p>implement != in terms of==</p>
</li>
<li>
<p>implement&gt;, &gt;= , &lt; &lt;= in terms of &lt;      只写&lt;和==的重载，其他的基于它们来实现。好处是将来好修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> &#123;</span><span class="keyword">public</span>:    ...    <span class="keyword">bool</span> <span class="keyword">operator</span>==( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span>;    <span class="keyword">bool</span> <span class="keyword">operator</span>!=( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span>;    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span>;    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span>;    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span>;    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span>;&#125;<span class="keyword">bool</span> Integer::<span class="keyword">operator</span>==( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span> &#123;	<span class="keyword">return</span> i == rhs.i;&#125;<span class="comment">// implement lhs != rhs in terms of ! (lhs == rhs)  用了12行的来写这个函数bool Integer::operator!=( const Integer&amp; rhs ) const &#123;	return ! (*this == rhs) ;&#125;bool Integer::operator&lt;( const Integer&amp; rhs ) const &#123;	return i &lt; rhs.i;&#125;// implement 1hs &gt; rhs in terms of lhs &lt; rhsbool Integer::operator&gt;( const Integer&amp; rhs ) const &#123;	return rhs &lt; *this;// implement 1hs &lt;= rhs in terms of ! (rhs &lt; 1hs)bool Integer::operator&lt;=( const Integer&amp; rhs ) const &#123;	return ! (rhs &lt; *this) ;&#125;    // implement lhs &gt;= rhs in terms of ! (lhs &lt; rhs)bool Integer::operator&gt;=( const Integer&amp; rhs ) const &#123;	return ! (*this &lt; rhs) ;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Operator []</p>
<ul>
<li>
<p>Must be a member function</p>
</li>
<li>
<p>Single argument</p>
</li>
<li>
<p>Implies that the object it is being called for acts like an array, so it should return a reference</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">V</span> <span class="params">(<span class="number">100</span>)</span> </span>; <span class="comment">// create a vector of size 100 v[10] = 45;//[]返回的是引用，所以可以作左值//(Note: if returned a pointer you would need to do:*v[10] = 45;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>vector.h，vector.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector.h#ifndef _VECTOR_H_#define _VECTOR_H_class Vector &#123;public:	Vector(int size):m_size(size)     &#123;		m_array = new int[size];    &#125;	~Vector() &#123; delete m_ array; &#125;	int&amp; operatorD(int index) &#123; return m_array[index]; &#125;private:	int m_size;	int *m_array;//以后改变这个容器的容量很容易，相比于直接int m_array[size] &#125;;#endif</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="运算符重载——赋值">运算符重载——赋值</h3>
<ul>
<li>
<p>Copying VS. lnitialization</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyType b;MyType a= b;<span class="comment">//拷贝构造a=b;//赋值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Example:Copying Vs Initialization.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fi</span> &#123;</span><span class="keyword">public</span>:    <span class="built_in">Fi</span>() &#123;&#125;&#125;;  <span class="class"><span class="keyword">class</span> <span class="title">Fee</span> &#123;</span><span class="keyword">public</span>:    <span class="built_in">Fee</span>(<span class="keyword">int</span>) &#123;&#125;  	<span class="built_in">Fee</span>(<span class="keyword">const</span> Fi&amp;) &#123;&#125;&#125;;  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    Fee fee = <span class="number">1</span>; <span class="comment">// Fee(int)        	Fi fi;  	Fee fum = fi; // 调用构造函数Fee(Fi)        	fum = fi;//先用Fee(const Fi&amp;)把fi变成Fee类对象，然后赋值给fum&#125;///:~</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Automatic operator= creation</p>
<ul>
<li>
<p>The compiler will automatically create a <strong>type::operator=(type)</strong> if you don’t make one.</p>
</li>
<li>
<p>memberwise assignment  系统默认的=是成员级别的拷贝，这点和拷贝构造函数一样</p>
</li>
<li>
<p>Example:AutomaticOperatorEquals.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Cargo &#123; public:    Cargo&amp; operator=(const Cargo&amp;)     &#123;    	cout&lt;&lt;<span class="meta-string">&quot;inside Cargo::operator=()&quot;</span> &lt;&lt; endl;    	return *this;    &#125;    &#125;;class Truck &#123;	Cargo b;&#125;;int main() &#123;	Truck a, b;	a = b;<span class="comment">//Prints:&quot;inside Cargo::operator=()&quot;&#125;///：~</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Assignment Operator</p>
<ul>
<li>
<p>Must be a member function  必须是成员函数</p>
</li>
<li>
<p>Will be generated for you if you don’t provide one</p>
<ul>
<li>Same behavior as automatic copy ctor - memberwise assignment</li>
</ul>
</li>
<li>
<p>Check for assignment to self</p>
</li>
<li>
<p>Be sure to assign to all data members</p>
</li>
<li>
<p>Return a reference to *this</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=B=C;<span class="comment">// executed asA=(B=C);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Skeleton assignment operator</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T&amp; T::<span class="keyword">operator</span>=( <span class="keyword">const</span> T&amp; rhs ) &#123;	<span class="keyword">if</span>( <span class="keyword">this</span> != &amp;rhs)     <span class="comment">// check for self assignment，why？见12行   有动态分配内存的就要写    &#123;		// perform assignment  作赋值的具体操作	&#125;	return *this;//最后一定是这句&#125;//This checks address vs. check value(*this!=rhs)//这种情况下自己又=一次自己有坏处：class A &#123;	char *p;	A&amp; operator=(const A&amp; that)	&#123;		delete p;//你肯定是申请过内存的啦，所以要先delete        //如果that已经就是this，这里delete p就把this和that都delete掉了。20行that.p不存在，无法执行        	p=new[strlen(that.p)+1];    	strcpy(p，that.p);    	return *this;	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Assignment Operator</p>
<ul>
<li>For classes with dynamically allocated memory declare an assignment operator (and a copy constructor)有动态内存分配要写那个判断是否相等</li>
<li>To prevent assignment, explicitly declare operator= as private  如果你想防止系统作的那个=行为不正确，可以将=声明为私有，但代价是这个类的对象无法赋值</li>
</ul>
</li>
</ul>
<h3 id="运算符重载——类型转换">运算符重载——类型转换</h3>
<ul>
<li>
<p>Value classes  类的作用是表达值</p>
<ul>
<li>Appear to be primitive data types  看上去很像基本类型</li>
<li>Passed to and returned from functions  可以传进传出函数</li>
<li>Have overloaded operators (often)  一般需要有重载的运算符</li>
<li>Can be converted to and from other types  转换类型</li>
<li>Examples: Complex, Date, String</li>
</ul>
</li>
<li>
<p>User-defined Type conversions</p>
<ul>
<li>
<p>A conversion operator can be used to convert an object of one class into</p>
<ul>
<li>an object of another class</li>
<li>a built-in type</li>
</ul>
</li>
<li>
<p>Compilers perform implicit conversions</p>
<p>using:</p>
<ul>
<li>Single-argument constructors</li>
<li>implicit type conversion operators</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Single argument constructors</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathName</span> &#123;</span>	string name;<span class="keyword">public</span>:	<span class="comment">// or could be multi- argument with defaults 	PathName (const string&amp;) ;	~PathName () ;&#125;;	...	string abc (&quot;abc&quot;) ;		PathName xyz (abc) ; // OK!		xyz = abc;	// OK abc =&gt; PathName，然后这个PathName的abc会和xyz这个PathName作operator assignment（=），然后PathName没有自己的operator assignment，就用调用系统默认的operator assignment。因为是对象的拷贝，没涉及到指针，所以在这个default operator assignment里是ok的，于是会递归调用string类的operator assignment来作abc和xyz的赋值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Example:AutomaticTypeConversion.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: C12:AutomaticTypeConversion.cpp// From Thinking in C++， 2nd Edition// Available at http://www.BruceEckel.com// (c) Bruce Eckel 2000// Copyright notice in Copyright . txt// Type conversion constructorclass One &#123;public:	0ne() &#123;&#125;&#125;;class Two &#123;public:	Two( const 0ne&amp;) &#123;&#125;&#125;;void f(Two) &#123;&#125;int main() &#123;	One one;	f(one); // Wants a Two，has a One&#125; ///:~</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Preventing implicit conversions  不想让编译器自动转换</p>
<ul>
<li>
<p>New keyword: explicit</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathName</span>&#123;</span>	string name;<span class="keyword">public</span>:	<span class="function"><span class="keyword">explicit</span> <span class="title">PathName</span> <span class="params">(<span class="keyword">const</span> string&amp;)</span> </span>;<span class="comment">//显式的，告诉编译器我这个构造函数只能做构造函数，而不能拿来作自动转换类型	~PathName () ;&#125;;...string abc (&quot;abc&quot;) ;PathName xyz (abc) ; // OK!xyz = abc;	// error !</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Example:ExplicitKeyword.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> &#123;</span><span class="keyword">public</span>:	<span class="built_in">One</span>() &#123;&#125;&#125;;<span class="class"><span class="keyword">class</span> <span class="title">Two</span> &#123;</span><span class="keyword">public</span>:	<span class="keyword">explicit</span> Two <span class="keyword">const</span> One&amp;) &#123;&#125;&#125;;<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Two)</span> </span>&#123;&#125;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;	One one ;<span class="comment">//! f(one); // No auto conversion allowed	f(Two(one)); // 0K -- user performs conversion&#125; ///:~</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Conversion operations  自己做一个自动转换类型的函数</p>
<ul>
<li>
<p>Operator conversion</p>
<ul>
<li>Function will be called automatically</li>
<li>Return type is same as function name</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span><span class="keyword">public</span>:    ...	<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// Rational to double.这个double意思是把this转换成double&#125;Rational::operator double () const &#123;//这个double已经说明这个函数的返回类型。所以这个函数前面没返回类型	return numerator_ / (double) denominator ;//把this转换掉了，但并没有改this的值，所以函数结尾有const&#125;Rational r(1,3) ; double d = 1.3 * r; // r=&gt;double</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>General form of conversion ops</p>
<ul>
<li>X::operator T ()
<ul>
<li>Operator name is any type descriptor</li>
<li>No explicit arguments</li>
<li>No return type</li>
<li>Compiler will use it as a type conversion from X→T  把X的对象转换成T</li>
</ul>
</li>
</ul>
</li>
<li>
<p>C++type conversions</p>
<ul>
<li>
<p>Built-in conversions 基础类型</p>
<ul>
<li>
<p>Primitive</p>
<p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++%E7%AC%94%E8%AE%B0-%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82%E7%BF%81%E6%81%BA%E8%80%81%E5%B8%88/image-20200425204121286.png" alt="image-20200425204121286"></p>
</li>
<li>
<p>Implicit (for any type T)</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200425204148911.png" alt="image-20200425204148911" style="zoom:67%;" />
<ul>
<li>这里转的意思是，左边类型的变量或者值能否赋给右边类型的变量
<ul>
<li>T=&gt;T&amp;,T的对象交给T的引用，两种情况，初始化或赋值</li>
<li>T&amp;=&gt;T，赋值</li>
<li>T*=&gt;void*  通过这个指针去看待那块内存的眼光变了，而不是那块内存的本身的东西变了</li>
<li>T[]=&gt;T*， 一个数组可以交给指针去管</li>
<li>T*=&gt;T[]，某个指针可以用数组来管它</li>
<li>T=&gt;const T，非const拿来当const看</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>User-defined T <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> C  把T转成C，有以下两种方式</p>
<ul>
<li>if C(T) is a valid constructor call for C  //C类里有构造函数C(T)，可以把T转成C</li>
<li>if operator C() is defined for T  //T类里有operator C()</li>
</ul>
</li>
<li>
<p>BUT 如果都有呢？</p>
<ul>
<li>
<p>See:TypeConversionAmbiguity.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: C12:TypeConversionAmbiguity. cpp// From Thinking in C++, 2nd Edition // Available at http://www. BruceEckel. com// (c) Bruce Eckel 2000// Copyright notice in Copyright. txtclass Orange; // Class declarationclass Apple &#123;public:	operator Orange() const; // Convert Apple to Orange&#125;;class Orange &#123;public:	Orange(Apple); // Convert Apple to Orange    &#125;;void f(Orange) &#123;&#125;int main() &#123;	Apple a;//! f(a); // Error: ambiguous conversion  两种情况都有，会出错，要去掉其中一种方法   可以在15行代码前面加explicit&#125; ///:~</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Do you want to use them?</p>
<ul>
<li>In General, no!尽量少用这种自动替你做的事情
<ul>
<li>Cause lots of problems when functions are called unexpectedly.</li>
<li>See: CopyingVsInitialization2.cpp</li>
</ul>
</li>
<li>Use explicit conversion functions. For example, in class Rational instead of the conversion operator,declare a member function://更倾向于使用显式转换函数，阅读代码容易理解。例如，在Rational类中，而不是在转换操作符中，也不是声明一个成员函数<br>
double toDouble() const;</li>
</ul>
</li>
</ul>
<h3 id="模板">模板</h3>
<ul>
<li>
<p>Why templates?</p>
<ul>
<li>Suppose you need a list of X and a list of Y
<ul>
<li>The lists would use similar code</li>
<li>They differ by the type stored in the list  它们区别在于列表里存放的类型不同</li>
</ul>
</li>
<li>Choices
<ul>
<li>Require common base class  X和Y有共同的基类
<ul>
<li>May not be desirable  这可能做不到，eg.苹果和榔头，基类只能是东西</li>
</ul>
</li>
<li>Clone code  克隆代码
<ul>
<li>preserves type-safety  类型是安全的</li>
<li>hard to manage  难以维护、管理，调整代码，两处都要改</li>
</ul>
</li>
<li>Untyped lists  创一个list，是void*，任何东西就可以往里面放
<ul>
<li>type unsafe</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Templates</p>
<ul>
<li>Reuse source code
<ul>
<li>generic programming</li>
<li>use types as parameters in class or function definitions</li>
</ul>
</li>
<li>Template functions
<ul>
<li>Example: sort function  用这“一个”去sort不同类型</li>
</ul>
</li>
<li>Template classes
<ul>
<li>Example: containers such as stack, list, queue…
<ul>
<li>Stack operations are independent of the type of items in the stack</li>
</ul>
</li>
<li>template member functions</li>
</ul>
</li>
</ul>
</li>
<li>
<p>区别一下：</p>
<ul>
<li>
<p>function template函数模板:是一种模板，用来做出函数</p>
</li>
<li>
<p>类模板：是一种模板，用来做出类</p>
</li>
<li>
<hr>
</li>
<li>
<p>Template function：用template做出来的function</p>
</li>
<li>
<p>Template class：用template做出来的class</p>
</li>
</ul>
</li>
<li>
<p>Function Templates</p>
<ul>
<li>
<p>Perform similar operations on different types of data.</p>
</li>
<li>
<p>Swap function for two int arguments:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">( <span class="keyword">int</span>&amp; x，<span class="keyword">int</span>&amp; y )</span> </span>&#123;    <span class="keyword">int</span> temp = x;    x=y;    y = temp;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>What if we want to swap floats, strings,Currency, Person?</p>
</li>
</ul>
</li>
<li>
<p>Example:swap function template</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span><span class="comment">//template，class是关键字不能换。一般情况只有一个类型参数的话，习惯用T//template表示我的下一行那个东西是模板，如果下一行是函数，那个函数就是template，如果是类，那个类就是templatevoid swap( T&amp; x，T&amp; y )//在这个函数里可以使用T，来代表一个类型&#123;	T temp=x;	x=y;	y = temp;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>The <strong>template</strong> keyword introduces the template</li>
<li>The <strong>class T</strong> specifies a parameterized type name
<ul>
<li>class means any built-in type or user-defined type</li>
</ul>
</li>
<li>Inside the template, use T as a type name</li>
</ul>
</li>
<li>
<p>Function Template Syntax</p>
<ul>
<li>Parameter types represent:
<ul>
<li>types of arguments to the function</li>
<li>return type of the function</li>
<li>declare variables within the function</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Template Instantiation</p>
<ul>
<li>Generating a declaration from a template class/function and template arguments:
<ul>
<li>Types are substituted into template</li>
<li>New body of function or class definition is created
<ul>
<li>syntax errors,type checking</li>
</ul>
</li>
<li>Specialization – a version of a template for a particular arguments(s)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Example:Using swap</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">3</span>; <span class="keyword">int</span> j=<span class="number">4</span>;<span class="built_in">swap</span>(i, j) ;<span class="comment">// use explicit int swapfloat k = 4.5;float m = 3.7;swap(k, m) ; // instanstiate float swap   templateshi是一个declaration，编译器看到template什么也不干，它只会记住这个template。等编译器读到这一行，float不能用int的那个swap函数，窄不能转换到宽，然后你又有一个swap函数的模板，于是编译器会替你种出一个接受两个float作为输入的swap函数std::string s (&quot;Hel1o&quot;) ;std::string t (&quot;World&quot;) ;swap(s，t) ; // std::string swap</span></span><br></pre></td></tr></table></figure>
<ul>
<li>A template function is an instantiation of a function template</li>
</ul>
</li>
<li>
<p>Interactions</p>
<ul>
<li>Only exact match on types is used</li>
<li>No conversion operations are applied
<ul>
<li>swap(int, int);// ok</li>
<li>swap(double, double); // ok</li>
<li>swap(int, double);// error!  不能作类型转换，因为你没有这种swap函数的模板</li>
</ul>
</li>
<li>Even implicit conversions are ignored  有函数模板后不会作类型转换，因为你已经明确有模板了，可以做出你想要的模板函数。所以编译器不会让你做自动类型转换，因为它认为这是对你意志的一种违背</li>
<li>Template functions and regular functions coexist</li>
</ul>
</li>
<li>
<p>Overloading rules</p>
<ul>
<li>
<p>Check first unique function match</p>
</li>
<li>
<p>Then check for unique function template match</p>
</li>
<li>
<p>Then do overloading on functions</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i,<span class="keyword">float</span> k)</span></span>&#123;&#125;;<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T t, T u)</span></span>&#123;&#125;:<span class="built_in">f</span>(<span class="number">1.0</span>,<span class="number">2.0</span>);<span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Function Instantiation</p>
<ul>
<li>
<p>The compiler deduces the template type from the actual arguments passed into the function.编译器从传递给函数的实际参数中推断模板类型。</p>
</li>
<li>
<p>Can be explicit:</p>
<ul>
<li>
<p>for example, if the parameter is not in the function signature (older compilers won’t allow this…)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123; <span class="comment">/*...*/</span>&#125;<span class="comment">//形参里没用到第1行中的Tfoo&lt;int&gt; () ; // type T is int    用&lt;&gt;再()，表示这次我就要种一个int出来foo&lt;float&gt; () ;// type T is float</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Class templates</p>
<ul>
<li>
<p>Classes parameterized by types</p>
<ul>
<li>Abstract operations from the types being operated upon</li>
<li>Define potentially infinite set of classes</li>
<li>Another step towards reuse!</li>
</ul>
</li>
<li>
<p>Typical use: container classes</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack &lt;<span class="keyword">int</span>&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>is a stack that is parameterized over int</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list &lt;Person&amp;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue &lt;Job&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Example:Vetor</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span><span class="keyword">public</span>:    <span class="built_in">Vector</span> (<span class="keyword">int</span>) ;    ~<span class="built_in">Vector</span>() ;    <span class="built_in">Vector</span> (<span class="keyword">const</span> Vector&amp;) ;    Vector&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Vector&amp;) ;    T&amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span>) ;<span class="keyword">private</span>:    T* m_elements;    <span class="keyword">int</span> m_size;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Usage</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span> <span class="params">(<span class="number">100</span>)</span> </span>;<span class="function">Vector&lt;Complex&gt; <span class="title">v2</span> <span class="params">(<span class="number">256</span>)</span> </span>;v1 [<span class="number">20</span>] = <span class="number">10</span>;v2 [<span class="number">20</span>] = v1[<span class="number">20</span>] ; <span class="comment">// ok if int-&gt;Complex				// defined</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Vector menbers  类里的成员函数都要写成函数模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>Vector&lt;T&gt;::<span class="built_in">Vector</span> (<span class="keyword">int</span> size) : <span class="built_in">m_size</span> (size) &#123;<span class="comment">//注意这行的&lt;T&gt;	m_elements = new T[m_size] ;&#125;template &lt;class T&gt;T&amp; Vector&lt;T&gt;::operator[] (int indx) &#123;        if(indx &lt; m_size&amp;&amp;indx&gt;0)        &#123;        	return m_ elements [ indx] ;        &#125;    	else         &#123;            ...        &#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>A simple sort function</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bubble sort -- don&#x27;t use it!template &lt; class T &gt;void sort( vector&lt;T&gt;&amp; arr ) &#123;	const size_t last = arr.size() -1;	for(int i=0;i&lt;last;i++)    &#123;		for(int j=last;i&lt;j;j--)        &#123;			if (arr[j] &lt; arr[j - 1])            &#123;//这个&lt;就需要T要有overload operator的&lt;，如果没有编译会出错。出错说这个&lt;无法完成，你很难发觉怎么去修改                //int，string可以完成，有自己的类库                //如果是你自己写的类用了这个模板，要注意要有overloaded的operator的&lt;            				// which swap?				swap(arr[j]，arr[j - 1]) ;			&#125;		&#125;	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Sorting the vector</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vi</span> <span class="params">(<span class="number">4</span>)</span> </span>;vi[<span class="number">0</span>]=<span class="number">4</span>;vi[<span class="number">1</span>]=<span class="number">3</span>;vi[<span class="number">2</span>]=<span class="number">7</span>;vi[<span class="number">3</span>]=<span class="number">1</span>;<span class="built_in">sort</span> ( vi ) ; <span class="comment">// sort( vector&lt;int&gt;&amp; )vector&lt;string&gt; VS;vs.push_back (&quot;Fred&quot;) ;vs.push_back (&quot;Wilma&quot;) ;vs .push_back (&quot;Barney&quot;) ;vs .push_back (&quot;Dino&quot;) ;vs.push_back (&quot;Prince&quot;) ;sort( vs ) ; // sort( vector&lt;string&gt;&amp; )//<span class="doctag">NOTE:</span> sort uses operator&lt; for comparison</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Templates</p>
<ul>
<li>
<p>Templates can use multiple types</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>&gt;</span><span class="comment">//最好还是用单个大写字母，整单词给人阅读起来很难想象未来它是要被替换成其他的class HashTable &#123;    const Value&amp; lookup (const Key&amp;) const;    void install (const Key&amp;， const Value&amp;) ;    ...&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Templates nest —they’re just types!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt; Vector&lt; <span class="keyword">double</span> *&gt; &gt; <span class="comment">// note space&gt;&gt;  有的编译器要求中间要有空格,否则&gt;&gt;表示右移</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Type arguments can be complicated</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt; <span class="built_in"><span class="keyword">int</span></span> (*) (Vector&lt;<span class="keyword">double</span>&gt;&amp;，<span class="keyword">int</span>) &gt;<span class="comment">//Vector里面的成员是函数指针，这个函数指针返回类型是int    它的参数有两项，Vector的&amp;，这个Vector里面放的是double，第二项是int</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Expression parameters</p>
<ul>
<li>
<p>Template arguments can be constant expressions</p>
</li>
<li>
<p>Non-Type parameters</p>
<ul>
<li>
<p>can have a default argument</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">int</span> <span class="title">bounds</span> =</span> <span class="number">100</span>&gt;<span class="class"><span class="keyword">class</span> <span class="title">FixedVector</span> &#123;</span><span class="keyword">public</span>:	<span class="built_in">FixedVector</span>() ;	<span class="comment">//	T&amp; operator[] (int) ;private:	T elements [bounds]; // fixed size array!&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Templates and inheritance</p>
<ul>
<li>
<p>Templates can inherit from non-template classes</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">A</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;...<span class="comment">//将来种的每一个类都是Base的子类</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Templates can inherit from template classes</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">A</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> List&lt;A&gt;&#123;...<span class="comment">//父类是函数模板种出来的一个模板函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Non-template classes can inherit from templates某个类继承了模板种出来的类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SupervisorGroup</span>:</span><span class="keyword">public</span> List&lt;Employee*&gt;&#123;...</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Writing templates</p>
<ul>
<li>Get a non-template version working first</li>
<li>Establish a good set of test cases</li>
<li>Measure performance and tune</li>
</ul>
</li>
<li>
<p>Usage:Non-type parameters</p>
<ul>
<li>
<p>Usage</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FixedVector&lt;<span class="keyword">int</span>， <span class="number">50</span>&gt; v1 ;FixedVector&lt;<span class="keyword">int</span>，<span class="number">10</span>*<span class="number">5</span>&gt; v2;FixedVector&lt;<span class="keyword">int</span>&gt; v3;<span class="comment">// uses default</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Summary</p>
<ul>
<li>Embedding sizes not necessarily a good idea</li>
</ul>
<ul>
<li>Can make code faster</li>
<li>Makes use more complicated<br>
●size argument appears everywhere!<br>
-Can lead to (even more) code bloat</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>视频结尾的问题？？有空查下</p>
<h2 id="异常">异常</h2>
<h3 id="异常基本概念">异常基本概念</h3>
<ul>
<li>
<p>Run-time Error</p>
<ul>
<li>The basic philosophy of C++ is that“badly formed code will not be run.&quot;</li>
<li>There’s always something happen in run-time.</li>
<li>It is very important to deal with all possible situation in the future running.</li>
</ul>
</li>
<li>
<p>read a file出现的问题，不是由于你程序的问题，而是外界因素导致的</p>
<ul>
<li>
<p>open the file;</p>
</li>
<li>
<p>文件是否存在？</p>
<ul>
<li>Unix下另外一个进程独占这个文件？</li>
</ul>
</li>
<li>
<p>determine its size;</p>
</li>
<li>
<p>网络数据流，连接着远端服务器，还在往这个文件里写东西</p>
<ul>
<li>另一个进程打开这个文件正在写这个文件</li>
</ul>
</li>
<li>
<p>windows和Unix把外部设备都当文件，比如有一个串口，串口上接了一个moudle，moudle上可能有数据来，也可能没有</p>
</li>
<li>
<p>allocate thet much memory;</p>
<ul>
<li>文件可以很大，电影4g，你得不到那么大的内存</li>
</ul>
</li>
<li>
<p>read the file into memory;</p>
<ul>
<li>软盘、光盘、硬盘、U盘中有部分损坏，读不出来</li>
</ul>
</li>
<li>
<p>close the file;<br>
+</p>
</li>
</ul>
</li>
<li>
<p>C的基础上写出一个强壮的程序，应对出错的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">errorCodeType readFile&#123;    initialize errorCode=<span class="number">0</span>;    open the file;    <span class="keyword">if</span>(the FilesOped)    &#123;        determine its size;        <span class="keyword">if</span>(gotTheFileLength)        &#123;            allocate that much memory;            <span class="keyword">if</span>(gotEnoughMemory)            &#123;                read the file into memory;                <span class="keyword">if</span>(readFailed)                &#123;                    errorCode=<span class="number">-1</span>;                &#125;            &#125;            <span class="keyword">else</span>            &#123;                errorCode=<span class="number">-2</span>;            &#125;        &#125;        <span class="keyword">else</span>        &#123;            errorCode=<span class="number">-3</span>;        &#125;        close the file;        <span class="keyword">if</span>(theFILEDidntClose&amp;&amp;errorCode==<span class="number">0</span>)        &#123;            errorCode=<span class="number">-4</span>;        &#125;        <span class="keyword">else</span>        &#123;            errorCode=errorCode <span class="keyword">and</span> <span class="number">-4</span>;        &#125;    &#125;    <span class="keyword">else</span>    &#123;        errorCode=<span class="number">-5</span>;    &#125;    <span class="keyword">return</span> errorCode;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Working w/ exception</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;    open the file;    determine its size;    allocate that much memory;    read the file into memory;    close the file;&#125; <span class="built_in"><span class="keyword">catch</span></span> ( fileOpenFailed ) &#123;	doSomething;&#125; <span class="built_in"><span class="keyword">catch</span></span> ( sizeDeterminationFailed ) &#123;	doSomething;&#125; <span class="built_in"><span class="keyword">catch</span></span> ( memory AllocationFailed ) &#123;	doSomething;&#125; <span class="built_in"><span class="keyword">catch</span></span> ( readFailed ) &#123;	doSomething;&#125; <span class="built_in"><span class="keyword">catch</span></span> ( fileCloseFailed ) &#123;	doSomething;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>exception</p>
<ul>
<li>I take exception to that</li>
<li>At the point where the problem occurs, you might not know what to do with it, but you do know that you can’t just continue on merrily;出现问题后你不能悄无声息地继续（因为中途出错，你后面的步骤是无意义的）you must stop, and somebody, somewhere must figure out what to do.</li>
</ul>
</li>
<li>
<p>Why exception?</p>
<ul>
<li>The significant benefit of exceptions is that they clean up error handling code.</li>
<li>It separates the code that describes what you want to do from the code that is executed.</li>
<li>exception业务逻辑清晰，发生了问题你会知道该怎么做</li>
</ul>
</li>
</ul>
<h3 id="异常的抛出和捕捉">异常的抛出和捕捉</h3>
<ul>
<li>
<p>Exanple:Vector</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&#123;</span><span class="keyword">private</span>:    T* m_elements;    <span class="keyword">int</span> m_size;<span class="keyword">public</span>:	<span class="built_in">Vector</span> (<span class="keyword">int</span> size=<span class="number">0</span>):<span class="built_in">m_size</span>(size)...    ~<span class="built_in">Vector</span>()    &#123;        <span class="keyword">delete</span>[] m_elements;    &#125;	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>    </span>&#123;        <span class="keyword">return</span> m_size;    &#125;	T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span>);&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Poblem</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[] (<span class="keyword">int</span> indx) &#123;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>What shoule the [] operator do if the index is not valid?[]越界了怎么办</p>
<ul>
<li>
<p>1.)Return random memory object</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> m_elements[indx];<span class="comment">//返回一个random值，但你可能拿它作左值，写到别人内存里去了，这是不能接受的</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>2.)Return s apecial error value</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (indx &lt; <span class="number">0</span> || indx &gt;= m_size)&#123;    T* error_marker=<span class="keyword">new</span> <span class="built_in">T</span>(<span class="string">&quot;some magic value&quot;</span>);    <span class="keyword">return</span> *erroe_marker;&#125;<span class="keyword">return</span> m_elements[indx];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>But this throws the baby out with the bath!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=v[<span class="number">2</span>]+v[<span class="number">4</span>];<span class="comment">//not safe code!  返回特定的错误值，但你这样要检查每个数是否是这个错误值，因为不能让这些错误值参与运算</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3.)Just die!</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (indx &lt; <span class="number">0</span> || indx &gt;= m_size)&#123;      <span class="built_in">exit</span>(<span class="number">22</span>);  &#125;  <span class="keyword">return</span> m_elements[indx];</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>4.)Die gracefully (with autopsy!)优雅地死</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(indx &gt;= <span class="number">0</span> &amp;&amp; indx &lt; m_size);<span class="comment">//assert其作用是如果它的条件返回错误，则终止程序执行。//https://www.cnblogs.com/lvchaoshun/p/7816288.html//assert表示的是代码的错误，数组越界可能不是代码问题，所以assert放这里不合适return m_elements[indx];</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>When to use exceptions</p>
<ul>
<li>Many times,you don’t know what shoule be done</li>
<li>If you do anything you’ll be wrong</li>
<li>Solutin:turf the problem</li>
<li>Make your caller(or its caller…)responsible</li>
</ul>
</li>
<li>
<p>How to raise an exception</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[] (<span class="keyword">int</span> indx) &#123;	<span class="keyword">if</span>(indx &lt; <span class="number">0</span> || indx &gt;= m_size)    &#123;		<span class="comment">// throw is a keyword		// exception is raised at this point		throw &lt; &lt;some thing&gt; &gt;;//出错就throw个东西出去，告诉别人这里出问题了	&#125;	return m_elements [indx] ;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>What do you throw?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// What do you have? Data!// Define a class to represent the error//原始类型和对象都是可以扔的，但一般扔对象。可以通过这个对象的类型知道里面发生了什么error，并且对象可以携带一定的数据（比如导致里面数组越界的index是多少）class VectorIndexError &#123;public:    VectorIndexError(int v) : m_badValue (v) &#123; &#125;    ~VectorIndexError () &#123; &#125;    void diagnostic()     &#123;    cerr&lt;&lt; &quot;index &quot; &lt;&lt; m_badValue    	&lt;&lt; &quot;out of range!&quot;;     &#125;private :    int m_badValue;&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>How to raise an exception</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[] (<span class="keyword">int</span> indx) &#123;	<span class="keyword">if</span> (indx &lt; <span class="number">0</span>|| indx &gt;= m_size) &#123;		<span class="comment">// VectorIndexError(indx) ;		// throw e;		throw VectorIndexError(indx) ;//VectorIndexError这个类的对象在堆栈里（在函数内部产生的本地变量）        //throw作用是终止，离开当前大括号&#123;&#125;的函数        //第6行抛出异常，这个函数里throw后面的语句不被执行（这里if函数里throw后面没语句了）；然后退出整个if函数，此时整个if函数相当于throw，throw后语句不被执行(operator[]函数里第10行不被执行；然后退出operator[]函数，回到调用operator[]函数的地方、、转下个代码块    &#125;	return m_elements [indx] ;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>What about your caller?</p>
<ul>
<li>
<p>Case 1)Doesn’t care<br>
-Code never even suspects a problem</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;	<span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">V</span><span class="params">(<span class="number">12</span>)</span> </span>;    v[<span class="number">3</span>] = <span class="number">5</span>;    <span class="keyword">int</span> i = v[<span class="number">42</span>]; <span class="comment">// out of range//退回到了这个，此时这句话相当于throw，再看throw所处的大括号是啥，第6行又被跳过，然后程序继续带着VectorIndexError的对象离开func（）函数（知道这个对象的地址就可以带走它）    // control never gets here !    return i * 5;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Case 2)Cares deeply</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outer</span><span class="params">()</span> </span>&#123;<span class="keyword">try</span> &#123; 	 <span class="built_in">func</span>() ; <span class="built_in">func2</span>() ;<span class="comment">//此时func()又相当于throw,func2()被跳过。此时throw在的大括号是try，它不着急离开了，而是去看后面的catch能否处理它这种异常，如果可以，就离开try，进catch，做catch里的事情，处理完以后不回到try()，而是继续往下走，如果你想回去自己写个循环  &#125; catch (VectorIndexError&amp; e) &#123;//这个catch捕捉的是VectorIndexError对象的&amp;  	e.diagnostic() ;  // This exception does not propagate&#125; 	cout &lt;&lt; &quot;Control is here after exception&quot;;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Case 3)Mildly interested</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outer2</span> <span class="params">()</span> </span>&#123;<span class="function">String <span class="title">err</span> <span class="params">(<span class="string">&quot;exception caught&quot;</span>)</span> </span>;	<span class="keyword">try</span> &#123;		<span class="built_in">func</span>() ;	&#125; <span class="built_in"><span class="keyword">catch</span></span> (VectorIndexError) &#123;		cout &lt;&lt; err;		<span class="keyword">throw</span>; <span class="comment">// propagate the exception  异常的传播        //第7行的意思是我要把刚刚捉到的异常再扔出去（在catch里，所以这里的throw不需要带对象和数值），这样整个try又相当于throw，这个函数又要被打断，回到调用try的地方      //为啥需要异常的传播？可能你只能处理一点点问题，需要更高层次的人去解决，或是寻找一个适当的时机再处理，这就需要不断向上报告，即把这个异常传播出去	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Case 4)Doesn’t care about the particulars</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outer3</span> <span class="params">()</span> </span>&#123;	<span class="keyword">try</span> &#123;			<span class="built_in">outer2</span> () ;	&#125; <span class="built_in"><span class="keyword">catch</span></span> (...) &#123;<span class="comment">//...表示万能的，所有异常类型都能捕捉		//.. . catches ALL exceptions !		cout &lt;&lt; &quot;The exception stops here!&quot;;	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>What happened?</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200609103617989.png" alt="image-20200609103617989" style="zoom: 80%;" />
<ul>
<li>沿着调用的链条回去，直到遇到某个try里有匹配的catch能处理它为止</li>
</ul>
</li>
<li>
<p>Review</p>
<ul>
<li>
<p>Throw statement <strong>raises</strong> the exception</p>
<ul>
<li>Control propagates back to first handler for that exception</li>
<li>Propagation follows the <strong>call</strong> chain</li>
<li>Objects on <strong>stack</strong>are properly destroyed</li>
</ul>
</li>
<li>
<pre><code class="language-c++">throw exp;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + throws value for matching</span><br><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  throw;</span><br></pre></td></tr></table></figure>

+ **reraises** the exception being handled
+ valid only within a handler



</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="异常语句">异常语句</h3>
<ul>
<li>
<p>Try blocks</p>
<ul>
<li>
<p>Try block</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;...&#125;	<span class="keyword">catch</span> ...	<span class="keyword">catch</span> ...</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Establishes any number of handlers</p>
</li>
<li>
<p>Not needed if you don’t use any handlers</p>
</li>
<li>
<p>Shows where you expect to handle exceptions</p>
</li>
<li>
<p>Costs cycles</p>
</li>
</ul>
</li>
<li>
<p>Exception handlers</p>
<ul>
<li>
<p>Select exception by type</p>
</li>
<li>
<p>Can re-raise exceptions</p>
</li>
<li>
<p>Two forms</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SomeType v) &#123;<span class="comment">//handler code&#125;    catch (...) &#123;//handler code  但...你拿不到对象，这是万般无奈下的补救措施&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Take a single argument (like a formal parameter)</p>
</li>
</ul>
</li>
<li>
<p>Selecting a handler</p>
<ul>
<li>
<p>Can have any number of handlers</p>
</li>
<li>
<p>Handlers are checked in order of appearance  按你书写catch顺序针对每一条catch作下面123</p>
<ol>
<li>
<p>Check for exact match</p>
</li>
<li>
<p>Apply base class conversions</p>
<p>Reference and pointer types, only</p>
</li>
<li>
<p>Ellipses (…) match all</p>
</li>
</ol>
</li>
<li>
<p>Inheritance can be used to structure exceptions</p>
</li>
</ul>
</li>
<li>
<p>Example:using inheritance</p>
<ul>
<li>
<p>Hierarchy of exception types</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathErr</span>&#123;</span>    ...    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">diagnostic</span><span class="params">()</span></span>;&#125;;<span class="class"><span class="keyword">class</span> <span class="title">OverflowErr</span>:</span><span class="keyword">public</span> MathErr&#123;...&#125;<span class="class"><span class="keyword">class</span> <span class="title">UnderfolwErr</span>:</span><span class="keyword">public</span> MathErr&#123;...&#125;<span class="class"><span class="keyword">class</span> <span class="title">ZeroDivideErr</span>:</span><span class="keyword">public</span> MathErr&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Using handlers</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;	<span class="comment">// code to exercise math options	throw UnderFlowErr () ;&#125; catch (ZeroDivideErr&amp; e) &#123;	// handle zero divide case&#125; catch (MathErr&amp; e) &#123;	// handle other math errors&#125; catch (...) &#123;//第三个如果是UnderfolwErr&amp; e,编译出错，因为永远被第6行捕捉，留不到第8行    //http://c.biancheng.net/view/2331.html	// any other exceptions&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Exception specifications</p>
<ul>
<li>
<p>Declare which exceptions function might raise</p>
</li>
<li>
<p>Part of function prototypes</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abc</span><span class="params">(<span class="keyword">int</span> a)</span> : throw (MathErr) &#123;</span><span class="comment">//throw()里可以有一到多个类。告诉别的程序abc函数运行时最多会（“可能”）抛出哪些异常，如果抛出的异常不在这个清单里，会抛出unexpexted异常，这反而是对abc函数的一种限制。我们需要的是警告那些调用abc()的人自己最好有处理这些异常的机制，（JAVA里如果调用的人没有处理机制编译通不过，而C++编译不管）//throw()表示我不抛任何异常//不写throw(),什么都有可能抛出    ...&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Not checked at compile time</p>
</li>
<li>
<p>At run time,</p>
<ul>
<li>if an exception not in the list propagates out,the <strong>unexpected</strong> exception is raised</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​</p>
<ul>
<li>
<p>Examples</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Printer::<span class="built_in">print</span> (Document&amp;):<span class="keyword">throw</span> (PrinterOf fLine, BadDocument)&#123;...    PrintManager::<span class="built_in">print</span> (Document&amp;) :<span class="built_in"><span class="keyword">throw</span></span> (BadDocument) &#123; ...	<span class="comment">// raises or doesn&#x27;t handle BadDocument    void goodguy() : throw () &#123;	// handles all exceptions        void average() &#123; &#125; // no spec，no checking,</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Exceptions and new</p>
<ul>
<li>
<p>new does NOT returned 0 on failure</p>
</li>
<li>
<p>new raises a bad_alloc() exception</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;	<span class="keyword">try</span> &#123;		<span class="keyword">while</span>(<span class="number">1</span>) &#123;			<span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="number">10000</span>] ;        &#125;&#125; <span class="built_in"><span class="keyword">catch</span></span> (bad_ alloc&amp; e) &#123;<span class="comment">//c里mallorca，内存不空是返回NULL；c++是返回bad_alloc异常    &#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Failure in constructors:</p>
<ul>
<li>No return value is possible</li>
<li>Use an“uninitialized flag”</li>
<li>Defer work to an Init() function</li>
</ul>
</li>
<li>
<p>Failure in constructors…</p>
<p>if you constructor can’t complete,throw an exception.</p>
<ul>
<li>
<p>Dtors for objects whose ctor didn’t complete won’t be called.</p>
</li>
<li>
<p>Clean up allocated resources before throwing.</p>
<ul>
<li>
<pre><code class="language-c++">class A&#123;public:	A()    &#123;        throw 0;//加入你在构造函数里new了空间，在析构里delete，但构造函数抛出异常，导致析构无法调用（没构造就没析构），先前那块new的内存又变垃圾了        //所以在构造函数里抛出异常时比较麻烦的一件事情    &#125;&#125;;   int notmain()&#123;    A* p= new A();//new是先分配内存，然后将这块内存交给构造函数去用。但构造函数里抛出异常，你无法找到然后删掉这块内存，这块内存变垃圾了        delete p;        return 0;&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">+ Programming with exceptions</span><br><span class="line"></span><br><span class="line">  Prefer catching exceptions by reference</span><br><span class="line"></span><br><span class="line">  + Throwing/catching by value involves slicing://slicing：子类对象交给父类（不是指针、引用），会丢掉一些东西</span><br><span class="line"></span><br><span class="line">    ~~~c++</span><br><span class="line">    struct X &#123;&#125;;struct Y : public X &#123;&#125;;try&#123;	throw Y () ;&#125; catch(X x) &#123;	//was it X or Y?&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>Throwing/catching by pointer introduces coupling between normal and handler code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Y</span>();&#125;<span class="built_in"><span class="keyword">catch</span></span>(Y* p)&#123;    <span class="comment">//whoops,forgot to delete.. 对象交给指针，这是可以的，但别忘了在catch里delete它，但这有点复杂了&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Catch exceptions by reference:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span>    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;&#125;;<span class="class"><span class="keyword">struct</span> <span class="title">D</span>:</span><span class="keyword">public</span> B&#123;<span class="comment">/*...*/</span>&#125;;<span class="keyword">try</span>&#123;    <span class="keyword">throw</span> <span class="built_in">D</span>(<span class="string">&quot;D error&quot;</span>);&#125;<span class="built_in"><span class="keyword">catch</span></span>(B&amp; b)&#123;    b.<span class="built_in">print</span>()<span class="comment">//print D&#x27;s error.&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>所以我们更倾向于你抛的是一个堆栈里很高的对象，catch是对象的引用（开销小），做完事情后不用做别的动作，反正那个高高在上的对象将来会被别人覆盖掉</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="流">流</h2>
<h3 id="流的概念">流的概念</h3>
<ul>
<li>
<p>Why streams?</p>
<ul>
<li>Original C I/O used printf, scanf</li>
<li>Streams invented for C++
<ul>
<li>C I/O libraries still work</li>
</ul>
</li>
<li>Advantages of streams
<ul>
<li>Better type safety</li>
<li>Extensible</li>
<li>More object oriented</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>More verbose  啰嗦</li>
<li>Often slower</li>
</ul>
</li>
</ul>
</li>
<li>
<p>C VS. C++</p>
<ul>
<li>C stdio operations work
<ul>
<li>Don’t provide“object-oriented&quot; features</li>
<li>No overloadable operators</li>
</ul>
</li>
<li>C++
<ul>
<li>Can overload inserters(&lt;&lt;) and extractors(&gt;&gt;)</li>
</ul>
</li>
<li>Moral
<ul>
<li>When converting C to C++, leave the I/O intact</li>
</ul>
</li>
</ul>
</li>
<li>
<p>What is a stream?</p>
<ul>
<li>Common logical interface to a device  流，一维单方向</li>
</ul>
</li>
<li>
<p>Stream naming conventions</p>
<p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++%E7%AC%94%E8%AE%B0-%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82%E7%BF%81%E6%81%BA%E8%80%81%E5%B8%88/image-20200430203758312.png" alt="image-20200430203758312"></p>
<ul>
<li>理解成fstream有i和o两种</li>
<li>第三行过时的， 对内存里char数组进行读写，这是不安全的，因为有下标检查，往里写东西可能会越界</li>
</ul>
</li>
<li>
<p>Stream operations</p>
<ul>
<li>Extractors
<ul>
<li>Read a value from the stream（c++重载了&gt;&gt;，如果运算符左边是istream，作extractor；receive是整数作右移。&lt;&lt;同理）</li>
<li>Overload the &gt;&gt; operator</li>
</ul>
</li>
<li>Inserters
<ul>
<li>Insert a value into a stream</li>
<li>Overload the &lt;&lt; operator</li>
</ul>
</li>
<li>Manipulators  操纵流怎样写的东西
<ul>
<li>Change the stream state</li>
</ul>
</li>
<li>Others  在这些cin，cout上仍然有函数可以进行</li>
</ul>
</li>
<li>
<p>Kinds of streams</p>
<ul>
<li>
<p>Text streams  对文本进行操作，所有的输入输出其实都在作解析parse，输出在作format</p>
<ul>
<li>
<p>Deal in ASCII text</p>
</li>
<li>
<p>Perform some character translation</p>
<p>●e.g: newline -&gt; actual OS file representation</p>
</li>
<li>
<p>Include</p>
<ul>
<li>Files</li>
<li>Character buffers</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Binary streams  二进制文件（不以人阅读为目的的文件）</p>
<ul>
<li>Binary data</li>
<li>No translations  输入输出不经过解析和格式化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="流的运算符">流的运算符</h3>
<ul>
<li>
<p>Predefined streams</p>
<ul>
<li>cin
<ul>
<li>standard input</li>
</ul>
</li>
<li>cout
<ul>
<li>standard output</li>
</ul>
</li>
<li>cerr  标准错误
<ul>
<li>unbuffered error (debugging) output</li>
</ul>
</li>
<li>clog  标准日志
<ul>
<li>buffered error (debugging) output</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>int i; float f; char C;char buffer[80] ;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Read the next character</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;c;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Read an integer</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; i; <span class="comment">// skips whitespace</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Read a float and a string separated by whitespace</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; f &gt;&gt; buffer;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Predefined extractors</p>
<ul>
<li>
<p>istream&gt;&gt;lvalue  根据你给的变量的类型来决定在文本中如何解析</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200506145332777.png" alt="image-20200506145332777" style="zoom:67%;" />
</li>
<li>
<p>Extractors skip leading whitespace, in general</p>
</li>
</ul>
</li>
<li>
<p>Defining a stream extractor  自己写</p>
<ul>
<li>
<p>Has to be a 2-argument free function  写成全局函数</p>
<ul>
<li>
<p>First argument is an i stream&amp;</p>
</li>
<li>
<p>Second argument is a reference to a value</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, T&amp; obj) &#123;                    <span class="comment">//is里的position改了，读到哪个位置，所以istream&amp; is前没const	// specific code to read obj	return is ;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Return an <strong>istream&amp;</strong> for chaining</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;( (cin &gt;&gt; a) &gt;&gt; b) &gt;&gt; c;<span class="comment">//cin &gt;&gt; a的结果要作下一个&gt;&gt;的receiver,所以cin &gt;&gt; a还得是istream。所以上面代码块函数的返回类型得是istream</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Other input operators</p>
<ul>
<li>
<p>int get()</p>
<ul>
<li>
<p>Returns the next character in the stream</p>
</li>
<li>
<p>Returns EOF if no characters left</p>
</li>
<li>
<p>Example: copy input to output</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;<span class="keyword">while</span> ( (ch = cin.<span class="built_in">get</span>()) != EOF)cout.<span class="built_in">put</span> (ch) ;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<pre><code class="language-c++">istream&amp; get(char&amp; ch)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    + Puts the next character into argument//返回类型是istream，可以放在一连串中用</span><br><span class="line">    + Similar to int get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ More input operators</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    get (char *buf， int limit, char delim = &#x27;\n&#x27;)</span><br></pre></td></tr></table></figure>

+ **read up to** limit **characters, or to** delim
+ **Appends a null character to** buf
+ **&lt;u&gt;Does&lt;/u&gt;** not consume the **delimiter**

</code></pre>
</li>
<li>
<pre><code class="language-c++">getline(char *buf, int limit, char delim = '\n')
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + **read up to** limit **characters, or to** delim</span><br><span class="line">  + **Appends a null character to** buf</span><br><span class="line">  + &lt;u&gt;**Does**&lt;/u&gt; **consume the delimiter**</span><br><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  ignore (int limit = 1，int delim = EOF)//跳过多少个东西不去读或者读到delim为止</span><br></pre></td></tr></table></figure>

+ **Skip over limit characters or to delimiter**
+ **Skip over delimiter if found**

</code></pre>
</li>
<li>
<pre><code class="language-c++">int gcount ()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ returns number of characters just read//返回刚才读到的多少个东西</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  char buffer[100] ;cin.getline (buffer, sizeof (buffer) ) ;cout &lt;&lt; &quot;read &quot; &lt;&lt; cin.gcount ()	&lt;&lt; &quot; characters&quot;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<pre><code class="language-c++">void putback (char)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + pushes a single character back into the stream</span><br><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  char peek()//偷窥，看一眼但不读</span><br></pre></td></tr></table></figure>

+ examines next character without reading it

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (cin.<span class="built_in">peek</span>())...</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
<li>
<p>Predefined inserters</p>
<ul>
<li>
<p>Usage</p>
<p>-ostream&lt;&lt;expression</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200506150546190.png" alt="image-20200506150546190" style="zoom:67%;" />
</li>
</ul>
</li>
<li>
<p>Creating a stream inserter</p>
<ul>
<li>
<p>Has to be a 2-argument free function</p>
<ul>
<li>
<p>First argument is an ostream&amp;</p>
</li>
<li>
<p>Second argument is any value</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; os， <span class="keyword">const</span> T&amp; obj) &#123;                                 <span class="comment">//这里有const，因为我只是要把obj往&lt;&lt;里inserter// specific code to write obj	return OS ;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Return an ostream&amp; for chaining</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt;c;((cout &lt;&lt; a) &lt;&lt; b) &lt;&lt; c;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Other output operators</p>
<ul>
<li>
<pre><code class="language-c++">put (char)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ prints a single character</span><br><span class="line"></span><br><span class="line">+ Examples</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  cout.put(&#x27;a&#x27;) ;cerr.put (&#x27;!&#x27;) ;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>flush()</p>
<ul>
<li>
<p>Force output of stream contents 保证这个输出能忘物理地址上写</p>
</li>
<li>
<p>Example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Enter a number&quot;</span> ;cout.<span class="built_in">flush</span>() ;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Formatting using manipulators</p>
<ul>
<li>
<p>Manipulators modify the state of the stream</p>
<ul>
<li>#include <iomanip></li>
<li>Effects hold (usually)</li>
</ul>
</li>
<li>
<p>Example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;cout &lt;&lt; <span class="string">&quot;enter number in hexadecimal&quot;</span>	 &lt;&lt; flush;cin &gt;&gt; hex &gt;&gt; n;<span class="comment">//用hex告诉cin下一个读到的东西是十六进制</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Example</p>
<ul>
<li>
<p>A simple program</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span>main() &#123;cout &lt;&lt; setprecision(2) &lt;&lt; 1000.243 &lt;&lt;endl;<span class="comment">//精度为2cout &lt;&lt; setw(20) &lt;&lt; &quot;OK!&quot;;//宽度为20return 0;&#125;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Prints</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">le03                 OK!</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Manipulators</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200506151405912.png" alt="image-20200506151405912" style="zoom:67%;" />
<ul>
<li>type上，I指Input可用，O指输出可用</li>
<li>setw(int)最少多宽</li>
<li>setfill(ch)填充什么</li>
<li>setbase(int)，任何数制</li>
<li>ws，跳过空格</li>
<li>setprecision(int)，精度多少，有多少位有效数字</li>
<li>setiosflags(long),在计算机，set就是置1，reset是置0</li>
</ul>
</li>
<li>
<p>Creating manipulators</p>
<ul>
<li>
<p>You can define your own manipulators!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skeleton for an output stream manipulatorostream&amp; manip (ostream&amp; out) &#123;    ...	return out ;&#125;ostream&amp; tab ( ostream&amp; out )&#123;	return out &lt;&lt; &#x27;\t&#x27; ;&#125;cout &lt;&lt; &quot;Hello&quot; &lt;&lt; tab &lt;&lt; &quot;World!&quot; &lt;&lt; endl ;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Stream flags control formatting</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200506151547193.png" alt="image-20200506151547193" style="zoom:67%;" />
</li>
<li>
<p>Setting flags</p>
<ul>
<li>Using manipulators
<ul>
<li>setiosflags(flags);</li>
<li>resetiosflags(flags);</li>
</ul>
</li>
<li>Using stream member functions
<ul>
<li>setf(flags)</li>
<li>unsetf(flags)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="STL简述">STL简述</h2>
<ul>
<li>
<p>What is STL</p>
<ul>
<li>STL = Standard Template Library</li>
<li>Part of the ISO Standard C++ Library</li>
<li>Data Structures数据结构 and algorithms算法 for C++.</li>
</ul>
</li>
<li>
<p>Why should I use STL?</p>
<ul>
<li>Reduce development time.
<ul>
<li>Data-structures already written and debugged.</li>
</ul>
</li>
<li>Code readability  可读性。另一层意思，和其他程序员有共同语言
<ul>
<li>Fit more meaningful stuff on one page.一页上有更多有意义的东西</li>
</ul>
</li>
<li>Robustness  强壮性
<ul>
<li>STL data structures grow automatically.</li>
</ul>
</li>
<li>Portable code.可移植</li>
<li>Maintainable code可维护</li>
<li>Easy</li>
</ul>
</li>
<li>
<p>C++ Standard Library</p>
<ul>
<li>
<p>Library includes:</p>
<ul>
<li>A <strong>Pair</strong> class (pairs of anything, int/int, int/char, etc)表达两个东西之间的关系</li>
<li>Containers
<ul>
<li>Vector (expandable array可拓展数组，下标会自动拓展，不会有越界问题)</li>
<li>Deque (expandable array, expands at both ends两头增长)</li>
<li>List (double-linked双向链表)</li>
<li>Sets（集合，重复，无序） and Maps（映射，key和value）</li>
</ul>
</li>
<li>Basic Algorithms 基础算法(sort, search, etc)</li>
</ul>
</li>
<li>
<p>All identifiers in library are in <strong>std</strong> namespace</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>The three parts of STL</p>
<ul>
<li>Containers</li>
<li>Algorithms</li>
<li>Iterators枚举器</li>
</ul>
</li>
<li>
<p>The ‘Top 3’ data stryctures</p>
<ul>
<li>map
<ul>
<li>Any key type,any value type.</li>
<li>Sorted.</li>
</ul>
</li>
<li>vector
<ul>
<li>Like c array,but auto-extending.</li>
</ul>
</li>
<li>list
<ul>
<li>doubly-linked list</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Example using the vector class</p>
<img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200609203610775.png" alt="image-20200609203610775" style="zoom: 80%;" />
<ul>
<li>vector<int>::iterator p;//vector<int>里的一种数据类型iterator</li>
<li>运算符重载，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">∗</span></span></span></span>重载过，vector里说iterator是int类型，所以iterator*返回的就是int</li>
<li>++肯定也重载过</li>
</ul>
</li>
<li>
<p>Basic Vector Operations</p>
<ul>
<li>
<p>Constryctors</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Elem&gt; c;<span class="function">vector&lt;Elem&gt; <span class="title">c1</span><span class="params">(c2)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Simple Methods</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V.<span class="built_in">size</span>()	<span class="comment">//num itemsV.empty()	//empty?==,!=,&lt;,&gt;,&lt;=,&gt;=  //重载了一些比较两个Vector的运算符V.swap(v2)	//swap  交换两个Vector的所有元素</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Iterators</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I.<span class="built_in">begin</span>()	<span class="comment">//first positonI.end()	//lase position</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Element access</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V.<span class="built_in">at</span>(index)V[index]V.<span class="built_in">front</span>()	<span class="comment">//first itemV.back()	//last item</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Add/Remove/Find</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V.<span class="built_in">push_back</span>(e)V.<span class="built_in">pop_back</span>()	<span class="comment">//有push，pop，相当于实现了stackv.insert(pos,e)	V.erase(pos)	//删除V.clear()	//清空V.find(first,last,item)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>List Class</p>
<ul>
<li>
<p>Same basic concepts as vector</p>
<ul>
<li>
<p>Constructors</p>
</li>
<li>
<p>Ability to compare lists(==,!=,&lt;,&lt;=,&gt;,&gt;=)</p>
</li>
<li>
<p>Ability to access front and back of list</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="built_in">front</span>(),x.<span class="built_in">back</span>()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Ability to assign items to a list,remove items</p>
<ul>
<li>
<pre><code class="language-c++">x.push_back(item),x.push_front(item)x.pop_back(),x.pop_front()x.remove(item)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Sample List Application</span><br><span class="line"></span><br><span class="line">  ![image-20200610100902057](/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200610100902057.png)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">+ Example Program</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  #include &lt;map&gt;#include &lt;string&gt;map&lt;string,float&gt; price;price[&quot;snapple&quot;] = 0.75;price[&quot;coke&quot;]= 0.50;string item;double total=0;while ( cin &gt;&gt; item )	total += price[item];</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>C++笔记-网易云课堂翁恺老师</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://jyxyz.github.io/posts/a9cf272f.html">https://jyxyz.github.io/posts/a9cf272f.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display: inline-block;width: 120px"><h>博主✍</h><div class="post-copyright-cc-info"><h>阿耶</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>本篇发布于📚</h><div class="post-copyright-cc-info"><h>2020-04-02</h></div></div><div class="post-copyright-u" style="display: inline-block;width: 120px"><h>本篇更新于🕝</h><div class="post-copyright-cc-info"><h>2020-07-10</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq,qzone"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 要饭码</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/reward/wechat.png" alt="wechat饿饿"/></a><div class="post-qr-code-desc">wechat饿饿</div></li><li class="reward-item"><a href="/img/reward/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/reward/alipay.png" alt="alipay饿饿"/></a><div class="post-qr-code-desc">alipay饿饿</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/43cb853c.html"><img class="prev-cover" src="/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">DES、AES、SM4、ZUC、RSA、ElGamal</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%89%AF%E5%A5%BD%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%A3%8E%E6%A0%BC%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.</span> <span class="toc-text">良好的程序风格建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">什么是对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">面向对象基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%94%AE%E7%A5%A8%E6%9C%BA%E4%BE%8B%E5%AD%90"><span class="toc-number">2.3.</span> <span class="toc-text">自动售票机例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">构造与析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-delete"><span class="toc-number">2.5.</span> <span class="toc-text">new	&amp;	delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6"><span class="toc-number">2.6.</span> <span class="toc-text">访问限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88"><span class="toc-number">2.7.</span> <span class="toc-text">对象组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.8.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E7%88%B6%E7%B1%BB%E5%85%B3%E7%B3%BB"><span class="toc-number">2.9.</span> <span class="toc-text">子类父类关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%92%8C%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">2.10.</span> <span class="toc-text">函数重载和默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">2.11.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">2.12.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.13.</span> <span class="toc-text">不可修改的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">2.14.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E9%80%A0%E5%9E%8B"><span class="toc-number">2.15.</span> <span class="toc-text">向上造型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">2.16.</span> <span class="toc-text">多态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.17.</span> <span class="toc-text">多态的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%86%8D%E7%A0%94%E7%A9%B6"><span class="toc-number">2.18.</span> <span class="toc-text">引用再研究</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.19.</span> <span class="toc-text">静态对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">2.20.</span> <span class="toc-text">静态成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="toc-number">3.1.</span> <span class="toc-text">运算符重载——基本规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">运算符重载——原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E2%80%94%E2%80%94%E8%B5%8B%E5%80%BC"><span class="toc-number">3.3.</span> <span class="toc-text">运算符重载——赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.</span> <span class="toc-text">运算符重载——类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.5.</span> <span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">4.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">异常基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA%E5%92%8C%E6%8D%95%E6%8D%89"><span class="toc-number">4.2.</span> <span class="toc-text">异常的抛出和捕捉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.3.</span> <span class="toc-text">异常语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81"><span class="toc-number">5.</span> <span class="toc-text">流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">流的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text">流的运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E7%AE%80%E8%BF%B0"><span class="toc-number">6.</span> <span class="toc-text">STL简述</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'acloudenv-3gdr1re432b1f469',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.vemoji)'))
      }
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'acloudenv-3gdr1re432b1f469',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      document.getElementById('twikoo-count').innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>