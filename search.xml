<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试文章</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><details class="folding-tag" ><summary> 资源布局 </summary>              <div class='content'>                            </div>            </details><p>糖果屋网址：<a href="https://akilar.top/posts/615e2dec/">Tag Plugins Plus | Akilarの糖果屋</a></p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">MyDlg.h</button></li><li class="tab"><button type="button" data-href="#test4-2">MyDlg.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><p>CTF WP的格式：</p><p>难度：⭐</p><div class="btns rounded grid5">            <a class="button" href='https://files.buuoj.cn/files/b66a080016da04abfc002a336c0132e5/easyre.zip' title='文件下载'><i class='fas fa-download'></i>文件下载</a>          </div><details class="folding-tag" ><summary> 参考答案 </summary>              <div class='content'>              <ol><li><p>查</p></li><li><p>运行观察</p></li><li><p>找主函数</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">字符串交叉引用</button></li><li class="tab"><button type="button" data-href="#test4-2">一波流</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li><li><p>流程分析</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">F5已扣</button></li><li class="tab"><button type="button" data-href="#test4-2">F5</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li><li><p>运行拿flag</p></li></ol>              </div>            </details><ol start="6"><li></li></ol><hr><kbd>Ctrl</kbd> + <kbd>F</kbd><hr><p>MFC多文件：</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">.h</button></li><li class="tab"><button type="button" data-href="#test4-2">.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">diff</button></li><li class="tab"><button type="button" data-href="#test4-2">完整版</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><p>模板：</p><p><strong>背景</strong></p><p><strong>需求</strong></p><p><strong>产品</strong></p><details class="folding-tag" ><summary> 事件冒泡简要介绍 </summary>              <div class='content'>                            </div>            </details><p><strong>种草</strong></p><p><strong>拔草</strong></p><hr> <img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109103959866.png" style="height:180px;"/> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>L</mi><mi>i</mi></msub><mo>=</mo><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><msub><mi>L</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⊕</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}L_i=R_{i-1}\\R_i=L_{i-1}⊕F(R_{i-1},K_i)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传upload-labs</title>
      <link href="/posts/d642dfa0.html"/>
      <url>/posts/d642dfa0.html</url>
      
        <content type="html"><![CDATA[<p>123</p><p>文件上传漏洞：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0upload-labs/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY3NzQwOQ==,size_16,color_FFFFFF,t_70.png" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY3NzQwOQ==,size_16,color_FFFFFF,t_70"></p><p>upload-labs通关全记录：</p><p><a href="https://blog.csdn.net/weixin_44677409/article/details/92799366">upload-labs通关记录</a></p><p><a href="https://www.cnblogs.com/chu-jian/p/15515770.html">upload-labs通关攻略</a></p><p>PASS12-<code>%00</code>截断:</p><p><a href="https://www.freesion.com/article/52781351623/">UPLOAD-LABS 学习笔记（四）PASS 12-16</a></p><p>PASS13-POST请求%00截断：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0upload-labs/13847.png" alt="13847"></p><p>写入这个后，不着急转发，我们需要将%00转码后再进行转发</p><p>选择%00后点击右键，按照图中所示转码</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0upload-labs/13857.png" alt="13857"></p><p>转码后再点击转发</p>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
          <category> 漏洞分析 </category>
          
          <category> 文件上传漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows程序设计</title>
      <link href="/posts/4eb9716e.html"/>
      <url>/posts/4eb9716e.html</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识">前置知识</h2><p><a href="https://docs.microsoft.com/zh-cn/">MSDN技术文档</a></p><h3 id="匈牙利命名法-2">匈牙利命名法</h3><p>变量名前都有一个短前缀，用以表明该变量的数据类型</p><p>变量名前缀：</p><table><thead><tr><th><strong>前缀</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>c</td><td>char 或 WCHAR 或 TCHAR</td></tr><tr><td>by</td><td>BYTE （无符号字符）</td></tr><tr><td>n</td><td>short（短整型）</td></tr><tr><td>i</td><td>int（整型）</td></tr><tr><td>x, y</td><td>int，表示 x 坐标和 y 坐标</td></tr><tr><td>cx, cy</td><td>int，表示 x 或 y 的长度，c 表示“count”（计数）</td></tr><tr><td>B 或 f</td><td>BOOL（int）；f 表示“flag”</td></tr><tr><td>w</td><td>WORD（无符号短整型）</td></tr><tr><td>l</td><td>LONG（长整型）</td></tr><tr><td>dw</td><td>DWORD（无符号长整型）</td></tr><tr><td>fn</td><td>函数</td></tr><tr><td>s</td><td>字符串</td></tr><tr><td>sz</td><td>以零结束的字符串（String Terminated with a Zero)</td></tr><tr><td>h</td><td>句柄</td></tr><tr><td>p</td><td>指针</td></tr></tbody></table><ul><li>前缀lpfn：指向函数的长指针（long pointer to a function)</li><li>lpsz：指向以零结束的字符串的长指针（long pointer to a string terminated with a zero）</li><li>前缀cb：字节数（count of byte)</li><li>h句柄<ul><li>hbr：画刷的句柄（handle to a brush）</li></ul></li></ul><p>大写前缀：</p><table><thead><tr><th><strong>前缀</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>CS</td><td>类风格选项（ClassStyle）</td></tr><tr><td>CW</td><td>创建窗口选项（CreateWindow）</td></tr><tr><td>DT</td><td>文本绘制选项（DrawText）</td></tr><tr><td>IDI</td><td>图标的 ID 号（IDIcon）（ID for a icon）</td></tr><tr><td>IDC</td><td>光标的 ID 号（IDCursor）</td></tr><tr><td>MB</td><td>消息框选项（MessageBox）</td></tr><tr><td>SND</td><td>声音选项（Sound）</td></tr><tr><td>WM</td><td>窗口消息（WindowsMessage）</td></tr><tr><td>WS</td><td>窗口风格（WindowStyles）</td></tr></tbody></table><h3 id="宽字符与自适应">宽字符与自适应</h3><p>Unicode直接简单粗暴用16位字符编码</p><p>库函数已经被重写，头文件用了条件编译宏<code>#ifdef</code>、<code>#else</code>、<code>#endif</code>，你直接用，这些函数会自适应换成是Unicode或非Unicode版的函数。</p><h2 id="第一个窗口程序">第一个窗口程序</h2><p>定义窗口类结构（<a href="http://bbs.fishc.com/thread-47123-1-1.html">WNDCLASS</a>） -&gt; 注册窗口类（RegisterClass） -&gt; 创建窗口（<a href="http://bbs.fishc.com/thread-47139-1-1.html">CreateWindow</a>） -&gt; 显示窗口（<a href="http://bbs.fishc.com/thread-47206-1-1.html">ShowWindow</a>） -&gt; 更新窗口（<a href="http://bbs.fishc.com/thread-47210-1-1.html">UpdateWindow</a>） -&gt; 消息循环（<a href="http://bbs.fishc.com/thread-47252-1-1.html">GetMessage</a> -&gt; <a href="http://bbs.fishc.com/thread-47258-1-1.html">TranslateMessage</a> -&gt;<a href="http://bbs.fishc.com/thread-47260-1-1.html">DispatchMessage</a>）</p><p>​备注：当<code>CreateWindow</code>调用返回时，窗口已在Windows内部被创建（Windows已经分配了一块内存来保存CreateWindow调用中指定的窗口信息以及一些其他信息。Windows可通过窗口句柄来获取这些信息）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span> <span class="params">(HWND, UINT, WPARAM, LPARAM)</span> </span>;</span><br><span class="line">                        <span class="comment">//函数参数声明了类型，没指出形参而已</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span> <span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">                    PSTR szCmdLine, <span class="keyword">int</span> iCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">static</span> TCHAR szAppName[] = TEXT (<span class="string">&quot;HelloWin&quot;</span>) ;</span><br><span class="line">     HWND         hwnd ;    <span class="comment">//窗口句柄</span></span><br><span class="line">     MSG          msg ;     <span class="comment">//消息结构</span></span><br><span class="line">     WNDCLASS     wndclass ;<span class="comment">//窗口类结构</span></span><br><span class="line"><span class="comment">/*------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   定义窗口类结构（WNDCLASS）</span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------*/</span></span><br><span class="line">     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;                 <span class="comment">//指定窗口类型，各种“类风格”，可以使用按位或操作符组合起来</span></span><br><span class="line">     wndclass.lpfnWndProc   = WndProc ;                                 <span class="comment">//指定窗口过程（必须是回调函数）</span></span><br><span class="line">     wndclass.cbClsExtra    = <span class="number">0</span> ;                                       <span class="comment">//预留的额外空间，一般为 0</span></span><br><span class="line">     wndclass.cbWndExtra    = <span class="number">0</span> ;                                       <span class="comment">//预留的额外空间，一般为 0</span></span><br><span class="line">     wndclass.hInstance     = hInstance ;                               <span class="comment">//应用程序的实例句柄</span></span><br><span class="line">     wndclass.hIcon         = LoadIcon (<span class="literal">NULL</span>, IDI_APPLICATION) ;        <span class="comment">//为所有基于该窗口类的窗口设定一个图标</span></span><br><span class="line">     wndclass.hCursor       = LoadCursor (<span class="literal">NULL</span>, IDC_ARROW) ;            <span class="comment">//为所有基于该窗口类的窗口设定一个鼠标指针</span></span><br><span class="line">     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;   <span class="comment">//指定窗口背景色</span></span><br><span class="line">     wndclass.lpszMenuName  = <span class="literal">NULL</span> ;                                    <span class="comment">//指定窗口菜单</span></span><br><span class="line">     wndclass.lpszClassName = szAppName ;                               <span class="comment">//指定窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   注册窗口类（RegisterClass）</span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------*/</span></span><br><span class="line">     <span class="keyword">if</span> (!RegisterClass (&amp;wndclass))</span><br><span class="line">     &#123;</span><br><span class="line">          MessageBox (<span class="literal">NULL</span>, TEXT (<span class="string">&quot;This program requires Windows NT!&quot;</span>), </span><br><span class="line">                      szAppName, MB_ICONERROR) ;                        <span class="comment">//注册失败则弹窗提示ERROR</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">/*------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   创建窗口（CreateWindow)</span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------*/</span></span><br><span class="line">     hwnd = CreateWindow (szAppName,                  <span class="comment">// 窗口类名称</span></span><br><span class="line">                          TEXT (<span class="string">&quot;The Hello Program&quot;</span>), <span class="comment">// 窗口标题</span></span><br><span class="line">                          WS_OVERLAPPEDWINDOW,        <span class="comment">// 窗口风格，或称窗口格式</span></span><br><span class="line">                          CW_USEDEFAULT,              <span class="comment">// 初始x坐标</span></span><br><span class="line">                          CW_USEDEFAULT,              <span class="comment">// 初始y坐标</span></span><br><span class="line">                          CW_USEDEFAULT,              <span class="comment">// 初始x方向尺寸</span></span><br><span class="line">                          CW_USEDEFAULT,              <span class="comment">// 初始y方向尺寸</span></span><br><span class="line">                          <span class="literal">NULL</span>,                       <span class="comment">// 父窗口句柄</span></span><br><span class="line">                          <span class="literal">NULL</span>,                       <span class="comment">// 窗口菜单句柄</span></span><br><span class="line">                          hInstance,                  <span class="comment">// 程序实例句柄</span></span><br><span class="line">                          <span class="literal">NULL</span>) ;                     <span class="comment">// 创建参数</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">/*------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   显示窗口（ShowWindow）-&gt;更新窗口（UpdateWindow）</span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------*/</span></span><br><span class="line">     ShowWindow (hwnd, iCmdShow) ;</span><br><span class="line">     UpdateWindow (hwnd) ;</span><br><span class="line">     </span><br><span class="line"><span class="comment">/*------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   消息循环（GetMessage-&gt;TranslateMessage-&gt;DispatchMessage)</span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------*/</span></span><br><span class="line">     <span class="keyword">while</span> (GetMessage (&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">          TranslateMessage (&amp;msg) ;</span><br><span class="line">          DispatchMessage (&amp;msg) ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> msg.wParam ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   窗口过程</span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------*/</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span> <span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;                           <span class="comment">//WndProc这四个函数参数是msg结构变量中的前四位成员</span></span><br><span class="line">     HDC         hdc ;      <span class="comment">//设备环境句柄</span></span><br><span class="line">     PAINTSTRUCT ps ;       <span class="comment">//绘制结构</span></span><br><span class="line">     RECT        rect ;     <span class="comment">//矩阵结构</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">switch</span> (message)</span><br><span class="line">     &#123;      </span><br><span class="line">     <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">          hdc = BeginPaint (hwnd, &amp;ps) ;</span><br><span class="line">          </span><br><span class="line">          GetClientRect (hwnd, &amp;rect) ;</span><br><span class="line">          </span><br><span class="line">          DrawText (hdc, TEXT (<span class="string">&quot;Hello, Windows 98!&quot;</span>), <span class="number">-1</span>, &amp;rect,</span><br><span class="line">                    DT_SINGLELINE | DT_CENTER | DT_VCENTER) ;</span><br><span class="line">          </span><br><span class="line">          EndPaint (hwnd, &amp;ps) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">          PostQuitMessage (<span class="number">0</span>) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> DefWindowProc (hwnd, message, wParam, lParam) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息机制">消息机制</h3><p>Windows是一个事件驱动，基于消息的操作系统。</p><p>用户的任何操作都被看作一个事件，操作系统会自动将该事件转换为相应的消息并投入该应用程序的消息队列等待处理。</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20211125154437000.png" alt="image-20211125154437000"></p><p>消息分为：</p><p>队列消息（投放到消息队列）和非队列消息（直接对窗口过程进行调用）</p><h3 id="窗口过程">窗口过程</h3><blockquote><p><strong>Don’t call me, I will call you.</strong></p></blockquote><p>用户对窗口所有的操作都会触发相应的事件，而 Windows 把所有的事件转换为对应的消息，所有对窗口过程的调用都是以消息的形式触发，<strong>我们写的大部分代码都是致力于对各种消息的处理和响应</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Windows安全 </category>
          
          <category> 编程篇 </category>
          
          <category> win api </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIN32 API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MFC</title>
      <link href="/posts/cef53f28.html"/>
      <url>/posts/cef53f28.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="What-is-MFC">What is MFC?</h2><p>Microsoft Foundation Classes，an application framework</p><p>微软公司对windows api函数封装后的一个C++类库，原本SDK编程中的消息循环等东西被封装在MFC框架中，让程序员关注自己业务逻辑即可。</p><h2 id="Why-MFC">Why MFC?</h2><p>重要的：</p><ul><li>体会封装，感知优雅的设计</li><li>逆向人员：至少了解一种框架（MFC、QT、JAVA也行）</li><li>前辈是生活在MFC走红的时代，看他们的资料不免会遇到MFC，这玩意梭哈学一下也不太费事，深入学一下，后边轻松点</li></ul><p>次要的：</p><ul><li>环境不依赖性，性能好</li><li>MFC仍广泛用于数控、工控领域</li></ul><h2 id="知识补充">知识补充</h2><h3 id="开发环境及项目创建">开发环境及项目创建</h3><p>VS2015 community</p><details class="folding-tag" ><summary> 创建Win32空项目 </summary>              <div class='content'>              <p>Win32项目-&gt;空项目</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211107152939905.png" alt="image-20211107152939905"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211107153219441.png" alt="image-20211107153219441"></p><p>对项目右键-&gt;选择属性</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211107153640655.png" alt="image-20211107153640655"></p>              </div>            </details><details class="folding-tag" ><summary> 创建MFC项目-对话框应用程序 </summary>              <div class='content'>              <p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108173901400.png" alt="image-20211108173901400"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108173919424.png" alt="image-20211108173919424"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108174007226.png" alt="image-20211108174007226"></p><p>保持默认，下一步</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108174034447.png" alt="image-20211108174034447"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108174045530.png" alt="image-20211108174045530"></p><p>点击完成</p><p>（题外话：CMy03MFCCheckboxDemoApp是进程实例，CMy03MFCCheckboxDemoDlg是我们画出来的窗口）</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108174140449.png" alt="image-20211108174140449"></p>              </div>            </details><h3 id="匈牙利命名法">匈牙利命名法</h3><p>变量：</p><p>m_表示该变量是类的成员变量（member）</p><p>常量：</p><p>SW_SHOW是一个常量宏，SW表示它被用于系统函数ShowWindow的参数</p><h3 id="Windows-API与MFC成员函数">Windows API与MFC成员函数</h3><p>要从MFC程序调用一个常规的Windows API函数，需要在函数名称前添加一个全局运算符<code>::</code>，确保即使对象具有相同名称的成员函数，也可以调用API函数</p><h2 id="基础篇">基础篇</h2><h3 id="第一个MFC程序（窗体）">第一个MFC程序（窗体）</h3><details class="folding-tag" ><summary> 参考资料 </summary>              <div class='content'>              <p><a href="https://blog.csdn.net/qq_45391763/article/details/101482454">第一个MFC程序</a></p>              </div>            </details><details class="folding-tag" ><summary> 第一个MFC程序（窗体） </summary>              <div class='content'>              <blockquote><p>创建Win32-&gt;空项目，项目名为01First，创建两个文件：mfc.h、01FirstMFC.cpp</p></blockquote><p>内容如下</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">mfc.h</button></li><li class="tab"><button type="button" data-href="#test4-2">01FirstMFC.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义MyFirstApp类作为 应用程序类CWinApp的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFirstApp</span> :</span><span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//基类的虚函数（接口），子类去实现</span></span><br><span class="line"><span class="comment">//MFC程序的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//框架窗口类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span><span class="keyword">public</span> CFrameWnd &#123;<span class="comment">//这是一个用C++对象表明的Windows窗口</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>();<span class="comment">//构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mfc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyFirstApp theApp;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">MyFirstApp::InitInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1.创建一个框架窗口类对象</span></span><br><span class="line">MainWindow* pMain = <span class="keyword">new</span> <span class="built_in">MainWindow</span>();<span class="comment">//调用上面定义的方法</span></span><br><span class="line"><span class="comment">//2.显示窗口</span></span><br><span class="line">pMain-&gt;<span class="built_in">ShowWindow</span>(m_nCmdShow);</span><br><span class="line"><span class="comment">//3.更新窗口</span></span><br><span class="line">pMain-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line"><span class="comment">//4.保存框架类对象的指针</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_pMainWnd = pMain;<span class="comment">//建立Window对象和App对象的关联关系</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;<span class="comment">//初始化正常则返回TRUE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Create</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;我的第一个MFC程序&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>运行结果：</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211028183517793.png" alt="image-20211028183517793" style="zoom: 50%;" />              </div>            </details><h3 id="MFC对象与Windows对象">MFC对象与Windows对象</h3><p>在Windows应用程序中，窗口是通过窗口句柄（HWND）来标识的。</p><p>MFC开发Windows应用程序就是对一个个MFC对象的熟悉、改造的过程——MFC对象就是把一个个零散的windows对象变成了易于标准化程序开发的C++对象。</p><p>下面以按钮、Cbutton为例子，来体会Windows对象与MFC对象的概念：</p><details class="folding-tag" ><summary> 例子：winapi或MFC方式创建一个按钮 </summary>              <div class='content'>              <blockquote><p>接着用上边的项目01FirstMFC</p></blockquote><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">windows api的方式</button></li><li class="tab"><button type="button" data-href="#test4-2">MFC对象</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">mfc.h</button></li><li class="tab"><button type="button" data-href="#test4-2">01FirstMFC.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>没变</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;afxwin.h&gt;</span><br><span class="line"></span><br><span class="line">//定义MyFirstApp类作为 应用程序类CWinApp的子类</span><br><span class="line">class MyFirstApp :public CWinApp &#123;</span><br><span class="line">public:</span><br><span class="line">//基类的虚函数（接口），子类去实现</span><br><span class="line">//MFC程序的入口函数</span><br><span class="line">virtual BOOL InitInstance();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//框架窗口类</span><br><span class="line">class MainWindow :public CFrameWnd &#123;//这是一个用C++对象表明的Windows窗口</span><br><span class="line">public:</span><br><span class="line">MainWindow();//构造函数</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mfc.h&quot;</span><br><span class="line"></span><br><span class="line">MyFirstApp theApp;</span><br><span class="line"></span><br><span class="line">BOOL MyFirstApp::InitInstance()</span><br><span class="line">&#123;</span><br><span class="line">//1.创建一个框架窗口类对象</span><br><span class="line">MainWindow* pMain = new MainWindow();//调用上面定义的方法</span><br><span class="line">//2.显示窗口</span><br><span class="line">pMain-&gt;ShowWindow(m_nCmdShow);</span><br><span class="line">//3.更新窗口</span><br><span class="line">pMain-&gt;UpdateWindow();</span><br><span class="line">//4.保存框架类对象的指针</span><br><span class="line">this-&gt;m_pMainWnd = pMain;//建立Window对象和App对象的关联关系</span><br><span class="line"></span><br><span class="line">return TRUE;//初始化正常则返回TRUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">Create(NULL, TEXT(&quot;我的第一个MFC程序&quot;));</span><br><span class="line"></span><br><span class="line">//通过windows api创建一个按钮</span><br><span class="line"><span class="addition">+HWND hBtn = ::CreateWindow(TEXT(&quot;Button&quot;),</span></span><br><span class="line"><span class="addition">+TEXT(&quot;按钮&quot;),</span></span><br><span class="line"><span class="addition">+WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,</span></span><br><span class="line"><span class="addition">+150, 45,</span></span><br><span class="line"><span class="addition">+160, 65,</span></span><br><span class="line"><span class="addition">+this-&gt;m_hWnd,</span></span><br><span class="line"><span class="addition">+(HMENU)10001,</span></span><br><span class="line"><span class="addition">+AfxGetInstanceHandle(),</span></span><br><span class="line"><span class="addition">+NULL);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>运行结果：</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211028185052142.png" alt="image-20211028185052142" style="zoom: 50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">mfc.h</button></li><li class="tab"><button type="button" data-href="#test4-2">01FirstMFC.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;afxwin.h&gt;</span><br><span class="line"></span><br><span class="line">//定义MyFirstApp类作为 应用程序类CWinApp的子类</span><br><span class="line">class MyFirstApp :public CWinApp &#123;</span><br><span class="line">public:</span><br><span class="line">//基类的虚函数（接口），子类去实现</span><br><span class="line">//MFC程序的入口函数</span><br><span class="line">virtual BOOL InitInstance();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//框架窗口类</span><br><span class="line">class MainWindow :public CFrameWnd &#123;//这是一个用C++对象表明的Windows窗口</span><br><span class="line">public:</span><br><span class="line">MainWindow();//构造函数</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"><span class="addition">+//子窗口，当成成员变量</span></span><br><span class="line"><span class="addition">+CButton *pBtn;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mfc.h&quot;</span><br><span class="line"></span><br><span class="line">MyFirstApp theApp;</span><br><span class="line"></span><br><span class="line">BOOL MyFirstApp::InitInstance()</span><br><span class="line">&#123;</span><br><span class="line">//1.创建一个框架窗口类对象</span><br><span class="line">MainWindow* pMain = new MainWindow();//调用上面定义的方法</span><br><span class="line">//2.显示窗口</span><br><span class="line">pMain-&gt;ShowWindow(m_nCmdShow);</span><br><span class="line">//3.更新窗口</span><br><span class="line">pMain-&gt;UpdateWindow();</span><br><span class="line">//4.保存框架类对象的指针</span><br><span class="line">this-&gt;m_pMainWnd = pMain;//建立Window对象和App对象的关联关系</span><br><span class="line"></span><br><span class="line">return TRUE;//初始化正常则返回TRUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">Create(NULL, TEXT(&quot;我的第一个MFC程序&quot;));</span><br><span class="line"></span><br><span class="line">//通过windows api创建一个按钮</span><br><span class="line">HWND hBtn = ::CreateWindow(TEXT(&quot;Button&quot;),</span><br><span class="line">TEXT(&quot;按钮&quot;),</span><br><span class="line">WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,</span><br><span class="line">150, 45,</span><br><span class="line">160, 65,</span><br><span class="line">this-&gt;m_hWnd,</span><br><span class="line">(HMENU)10001,</span><br><span class="line">AfxGetInstanceHandle(),</span><br><span class="line">NULL);</span><br><span class="line"></span><br><span class="line"><span class="addition">+CRect r(300, 450, 500, 600);</span></span><br><span class="line"><span class="addition">+pBtn = new CButton();</span></span><br><span class="line"><span class="addition">+pBtn-&gt;Create(TEXT(&quot;CButton&quot;),</span></span><br><span class="line"><span class="addition">+WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,</span></span><br><span class="line"><span class="addition">+r,</span></span><br><span class="line"><span class="addition">+this,</span></span><br><span class="line"><span class="addition">+10002);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>运行结果：</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211028185745314.png" alt="image-20211028185745314" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details><h3 id="消息映射：从windows对象到MFC对象">消息映射：从windows对象到MFC对象</h3><p><strong>消息映射从语义上看就是事件驱动编程，从语法上是一个将消息和成员函数相互关联的表</strong>。比如，框架窗口接收到一个窗口绘制消息，MFC将搜索该窗口的消息映射，如果存在一个处理WM_PAINT消息的处理程序，然后就调用OnPaint。</p><p>MFC为100多种从WM_ACTIVATE到WM_WININICHANGE的Windows消息提供了宏。您可以从MFC文档中获取与特定的ON_WM宏相对应的消息处理程序的名称,然而要自己推断名称也是相当容易的,您可以将WM_替换为On,将除那些单词开头字母之外的所有其他字母变为小写字母。因此,如 WM_PAINT变为OnPaint、WM_LBUTTONDOWN变为OnLButtonDown等等。</p><p>MFC为执行消息映射在内部所做的工作隐藏在某些十分复杂的宏。</p><p>实现过程如下：</p><ol><li>通过将DECLARE_MESSAGE_MAP添加到类声明中，声明消息映射。</li><li>通过放置标识消息的宏来执行消息映射，相应的类将在对BEGIN_MESSAGE_MAP和END_MESSAGE_MAP的调用之间处理消息。</li><li>添加成员函数来处理消息。</li></ol><p>自定义消息：</p><p>如果您希望处理一个MFC没有为之提供消息映射宏的消息时会怎么样呢?您可以使用普通的ON_MESSAGE宏为消息创建一个条目,该宏接受两个参数:消息ID和对应类成员函数的地址。下面的语句就将WM_SETTEXT映射到了一个名为OnSetText 的成员函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ON_MESSAGE</span>(WM_SETTEXT,OnSetText)</span><br></pre></td></tr></table></figure><p><code>OnSetText</code>应以如下的方式进行声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">afx_msg LRSULT <span class="title">OnSetText</span><span class="params">(WPARAM wParam,LPARAM lParam)</span></span>;</span><br></pre></td></tr></table></figure><p>由MFC提供的其他特殊用途的消息映射宏包括:ON_COMMAND,它将菜单选择和其他的UI事件映射到类成员函数;ON_UPDATE_COMMAND_UI,它将菜单项和其他UI对象连接到保持它们与应用程序的内部状态同步的“更新处理程序”。</p><details class="folding-tag" ><summary> 例子：给MFC的按钮对象增加按下便弹窗的功能： </summary>              <div class='content'>              <div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">mfc.h</button></li><li class="tab"><button type="button" data-href="#test4-2">01FirstMFC.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;afxwin.h&gt;</span><br><span class="line"></span><br><span class="line">//定义MyFirstApp类作为 应用程序类CWinApp的子类</span><br><span class="line">class MyFirstApp :public CWinApp </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//基类的虚函数（接口），子类去实现</span><br><span class="line">//MFC程序的入口函数</span><br><span class="line">virtual BOOL InitInstance();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//框架窗口类</span><br><span class="line">class MainWindow :public CFrameWnd </span><br><span class="line">&#123;//这是一个用C++对象表明的Windows窗口</span><br><span class="line">public:</span><br><span class="line">MainWindow();//构造函数</span><br><span class="line"></span><br><span class="line"><span class="addition">+afx_msg void HandleButton();//自己写的成员函数</span></span><br><span class="line"><span class="addition">+DECLARE_MESSAGE_MAP()//宏</span></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">//子窗口，当成成员变量</span><br><span class="line">CButton *pBtn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mfc.h&quot;</span><br><span class="line"></span><br><span class="line"><span class="addition">+BEGIN_MESSAGE_MAP(MainWindow,CFrameWnd)</span></span><br><span class="line"><span class="addition">+ON_BN_CLICKED(10002,HandleButton)//ID号和成员函数</span></span><br><span class="line"><span class="addition">+END_MESSAGE_MAP()</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+void MainWindow::HandleButton()</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+::MessageBox(NULL, TEXT(&quot;Hello&quot;), TEXT(&quot;MFC&quot;), MB_OK);</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"></span><br><span class="line">MyFirstApp theApp;</span><br><span class="line"></span><br><span class="line">BOOL MyFirstApp::InitInstance()</span><br><span class="line">&#123;</span><br><span class="line">//1.创建一个框架窗口类对象</span><br><span class="line">MainWindow* pMain = new MainWindow();//调用上面定义的方法</span><br><span class="line">//2.显示窗口</span><br><span class="line">pMain-&gt;ShowWindow(m_nCmdShow);</span><br><span class="line">//3.更新窗口</span><br><span class="line">pMain-&gt;UpdateWindow();</span><br><span class="line">//4.保存框架类对象的指针</span><br><span class="line">this-&gt;m_pMainWnd = pMain;//建立Window对象和App对象的关联关系</span><br><span class="line"></span><br><span class="line">return TRUE;//初始化正常则返回TRUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">Create(NULL, TEXT(&quot;我的第一个MFC程序&quot;));</span><br><span class="line"></span><br><span class="line">//通过windows api创建一个按钮</span><br><span class="line">HWND hBtn = ::CreateWindow(TEXT(&quot;Button&quot;),</span><br><span class="line">TEXT(&quot;按钮&quot;),</span><br><span class="line">WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,</span><br><span class="line">150, 45,</span><br><span class="line">160, 65,</span><br><span class="line">this-&gt;m_hWnd,</span><br><span class="line">(HMENU)10001,</span><br><span class="line">AfxGetInstanceHandle(),</span><br><span class="line">NULL);</span><br><span class="line"></span><br><span class="line">CRect r(300, 450, 500, 600);</span><br><span class="line">pBtn = new CButton();</span><br><span class="line">pBtn-&gt;Create(TEXT(&quot;CButton&quot;),</span><br><span class="line">WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,</span><br><span class="line">r,</span><br><span class="line">this,</span><br><span class="line">10002);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>&gt; 运行结果：</p><p>点击CButton会弹窗<img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211028190407850.png" alt="image-20211028190407850" style="zoom:50%;" /></p>              </div>            </details><p>在类声明.h中：</p><p>术语afx_msg是用来表示一个其行为很像虚拟函数但却不需要虚表项的函数。</p><p>DECLARE_MESSAGE MAP通常是最后的语句,因为它使用C++关键字来指定其成员的可见度。您可以在 DECLARE_MESSAGE_MAP后面插入声明其他类成员的语句,但是如果这样做了,您还应当使用关键字public,protected或者private开头,以确保您希望为这些成员设置的可见度。</p><p>小结：</p><ul><li>MFC封装了Windows对象形成一个个C++对象</li><li>消息映射完成了这些C++对象与Windows消息的对应关系，形成了成员函数</li><li>程序员只需要关注业务逻辑，把这些逻辑编码到这些成员函数，完成业务系统</li></ul><h3 id="MFC对象与资源绑定">MFC对象与资源绑定</h3><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/u=1779600390,3709835931&amp;fm=253&amp;app=138&amp;f=JPEG.jpeg" alt="img"></p><p>MFC的入门困境之一就是App Wizard：App Wizard实际上就是帮我们写代码的工具</p><p>我们通过win32api手工和App Wizard分别实现一个对话框的例子，来理解MFC的生成方式</p><details class="folding-tag" ><summary> win32api和MFC两种方式实现一个对话框 </summary>              <div class='content'>              <blockquote><p>项目为02MFCDlg,项目中两个文件：mfc.h和02MFCDlg.cpp，内容复用项目01FirstMFC的mfc.h和01First.cpp</p></blockquote><p>新建资源一个对话框，在属性中将ID修改为IDD_DLGDEMO</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211107154930416.png" alt="image-20211107154930416" style="zoom:50%;" /><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">windows api方式建立对话框：</button></li><li class="tab"><button type="button" data-href="#test4-2">MFC方式</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>02MyDlg.cpp文件</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mfc.h&quot;</span><br><span class="line"><span class="addition">+ #include &quot;resource.h&quot;</span></span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(MainWindow,CFrameWnd)</span><br><span class="line">ON_BN_CLICKED(10002,HandleButton)//ID号和成员函数</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line">void MainWindow::HandleButton()</span><br><span class="line">&#123;</span><br><span class="line">//::MessageBox(NULL, TEXT(&quot;Hello&quot;), TEXT(&quot;MFC&quot;), MB_OK);</span><br><span class="line"><span class="addition">+::DialogBoxParam(</span></span><br><span class="line"><span class="addition">+AfxGetInstanceHandle(),</span></span><br><span class="line"><span class="addition">+(LPCTSTR)IDD_DLGDEMO,</span></span><br><span class="line"><span class="addition">+NULL,</span></span><br><span class="line"><span class="addition">+NULL,</span></span><br><span class="line"><span class="addition">+NULL</span></span><br><span class="line"><span class="addition">+);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyFirstApp theApp;</span><br><span class="line"></span><br><span class="line">BOOL MyFirstApp::InitInstance()</span><br><span class="line">&#123;</span><br><span class="line">//1.创建一个框架窗口类对象</span><br><span class="line">MainWindow* pMain = new MainWindow();//调用上面定义的方法</span><br><span class="line">//2.显示窗口</span><br><span class="line">pMain-&gt;ShowWindow(m_nCmdShow);</span><br><span class="line">//3.更新窗口</span><br><span class="line">pMain-&gt;UpdateWindow();</span><br><span class="line">//4.保存框架类对象的指针</span><br><span class="line">this-&gt;m_pMainWnd = pMain;//建立Window对象和App对象的关联关系</span><br><span class="line"></span><br><span class="line">return TRUE;//初始化正常则返回TRUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">Create(NULL, TEXT(&quot;我的第一个MFC程序&quot;));</span><br><span class="line"></span><br><span class="line">//通过windows api创建一个按钮</span><br><span class="line">HWND hBtn = ::CreateWindow(TEXT(&quot;Button&quot;),</span><br><span class="line">TEXT(&quot;按钮&quot;),</span><br><span class="line">WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,</span><br><span class="line">150, 45,</span><br><span class="line">160, 65,</span><br><span class="line">this-&gt;m_hWnd,</span><br><span class="line">(HMENU)10001,</span><br><span class="line">AfxGetInstanceHandle(),</span><br><span class="line">NULL);</span><br><span class="line"></span><br><span class="line">CRect r(300, 450, 500, 600);</span><br><span class="line">pBtn = new CButton();</span><br><span class="line">pBtn-&gt;Create(TEXT(&quot;CButton&quot;),</span><br><span class="line">WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,</span><br><span class="line">r,</span><br><span class="line">this,</span><br><span class="line">10002);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>点击按钮弹出对话框</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211029103646063.png" alt="image-20211029103646063"></p><p>但点击关闭无法关闭对话框</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p>右键-&gt;添加类</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211029175235730.png" alt="image-20211029175235730"></p><p>输入类名位CMyDlg，.h文件和.cpp文件两个框会随输入的类名变化</p><p>这里基类选择CDialog</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211107155547017.png" alt="image-20211107155547017"></p><p>点完成后会自动生成stdafx.h、MyDlg.h、MyDlg.cpp</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">stdafx.h</button></li><li class="tab"><button type="button" data-href="#test4-2">MyDlg.h</button></li><li class="tab"><button type="button" data-href="#test4-3">MyDlg.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxwin.h&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CMyDlg 对话框</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyDlg</span> :</span> <span class="keyword">public</span> CDialog</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC</span>(CMyDlg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CMyDlg</span>(CWnd* pParent = <span class="literal">NULL</span>);   <span class="comment">// 标准构造函数</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">CMyDlg</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AFX_DESIGN_TIME</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> IDD = IDD_DLGDEMO &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span>;    <span class="comment">// DDX/DDV 支持</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p>在这个cpp中引用resourse.h这个头文件，因为用到了IDD_DLGDEMO</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// MyDlg.cpp : 实现文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;MyDlg.h&quot;</span><br><span class="line">#include &quot;afxdialogex.h&quot;</span><br><span class="line"><span class="addition">+ #include &quot;resource.h&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 对话框</span><br><span class="line"></span><br><span class="line">IMPLEMENT_DYNAMIC(CMyDlg, CDialog)</span><br><span class="line"></span><br><span class="line">CMyDlg::CMyDlg(CWnd* pParent /*=NULL*/)</span><br><span class="line">: CDialog(IDD_DLGDEMO, pParent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyDlg::~CMyDlg()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CMyDlg::DoDataExchange(CDataExchange* pDX)</span><br><span class="line">&#123;</span><br><span class="line">CDialog::DoDataExchange(pDX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CMyDlg, CDialog)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 消息处理程序</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>在02MFCDlg.cpp中引用头文件MyDlg.h，再写两行代码</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mfc.h&quot;</span><br><span class="line">#include &quot;resource.h&quot;</span><br><span class="line"><span class="addition">+ #include &quot;MyDlg.h&quot;</span></span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(MainWindow,CFrameWnd)</span><br><span class="line">ON_BN_CLICKED(10002,HandleButton)//ID号和成员函数</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line">void MainWindow::HandleButton()</span><br><span class="line">&#123;</span><br><span class="line">//::MessageBox(NULL, TEXT(&quot;Hello&quot;), TEXT(&quot;MFC&quot;), MB_OK);</span><br><span class="line">//::DialogBoxParam(</span><br><span class="line">//AfxGetInstanceHandle(),</span><br><span class="line">//(LPCTSTR)IDD_DLGDEMO,</span><br><span class="line">//NULL,</span><br><span class="line">//NULL,</span><br><span class="line">//NULL</span><br><span class="line">//);</span><br><span class="line"><span class="addition">+CMyDlg dlg;</span></span><br><span class="line"><span class="addition">+dlg.DoModal();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyFirstApp theApp;</span><br><span class="line"></span><br><span class="line">BOOL MyFirstApp::InitInstance()</span><br><span class="line">&#123;</span><br><span class="line">//1.创建一个框架窗口类对象</span><br><span class="line">MainWindow* pMain = new MainWindow();//调用上面定义的方法</span><br><span class="line"> //2.显示窗口</span><br><span class="line">pMain-&gt;ShowWindow(m_nCmdShow);</span><br><span class="line">//3.更新窗口</span><br><span class="line">pMain-&gt;UpdateWindow();</span><br><span class="line">//4.保存框架类对象的指针</span><br><span class="line">this-&gt;m_pMainWnd = pMain;//建立Window对象和App对象的关联关系</span><br><span class="line"></span><br><span class="line">return TRUE;//初始化正常则返回TRUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">Create(NULL, TEXT(&quot;我的第一个MFC程序&quot;));</span><br><span class="line"></span><br><span class="line">//通过windows api创建一个按钮</span><br><span class="line">HWND hBtn = ::CreateWindow(TEXT(&quot;Button&quot;),</span><br><span class="line">TEXT(&quot;按钮&quot;),</span><br><span class="line">WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,</span><br><span class="line">150, 45,</span><br><span class="line">160, 65,</span><br><span class="line">this-&gt;m_hWnd,</span><br><span class="line">(HMENU)10001,</span><br><span class="line">AfxGetInstanceHandle(),</span><br><span class="line">NULL);</span><br><span class="line"></span><br><span class="line">CRect r(300, 450, 500, 600);</span><br><span class="line">pBtn = new CButton();</span><br><span class="line">pBtn-&gt;Create(TEXT(&quot;CButton&quot;),</span><br><span class="line">WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,</span><br><span class="line">r,</span><br><span class="line">this,</span><br><span class="line">10002);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211107160942085.png" alt="image-20211107160942085"></p><p>点击CButton弹出对话框，且对话框点击×能够关闭</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details><p>这里的App Wizard帮我们做了什么？</p><ul><li>App wizar帮我们用代码将Windows的资源、windows的对象封装成符合C++语法的MFC对象，简化我们编程。</li><li>类向导，就是把资源（rc文件中的对话框界面、控件图形）生成.h，.cpp文件中的特定的C++对象。我们可以直接以C++语法进行操作，完成用户与应用程序的交互。</li></ul><h3 id="App-Wizard添加成员变量功能演示与剖析">App Wizard添加成员变量功能演示与剖析</h3><details class="folding-tag" ><summary> 例子 </summary>              <div class='content'>              <p>向对话框添加一个button按钮</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108104828336.png" alt="image-20211108104828336"></p><p>选中按钮，右键-&gt;添加变量</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108104951547.png" alt="image-20211108104951547"></p><p>变量名这里起为：m_btn_OK</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108105142008.png" alt="image-20211108105142008"></p><p>点击完成后，我们看到MyDlg.h、MyDlg.cpp内容发生了修改</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108105526820.png" alt="image-20211108105526820"></p><details class="folding-tag" ><summary> 具体内容的变化 </summary>              <div class='content'>              <div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">MyDlg.h</button></li><li class="tab"><button type="button" data-href="#test4-2">MyDlg.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &quot;afxwin.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 对话框</span><br><span class="line"></span><br><span class="line">class CMyDlg : public CDialog</span><br><span class="line">&#123;</span><br><span class="line">DECLARE_DYNAMIC(CMyDlg)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">CMyDlg(CWnd* pParent = NULL);   // 标准构造函数</span><br><span class="line">virtual ~CMyDlg();</span><br><span class="line"></span><br><span class="line">// 对话框数据</span><br><span class="line">#ifdef AFX_DESIGN_TIME</span><br><span class="line">enum &#123; IDD = IDD_DLGDEMO &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持</span><br><span class="line"></span><br><span class="line">DECLARE_MESSAGE_MAP()</span><br><span class="line"><span class="addition">+ public:</span></span><br><span class="line"><span class="addition">+CButton m_btn_OK;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// MyDlg.cpp : 实现文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;MyDlg.h&quot;</span><br><span class="line">#include &quot;afxdialogex.h&quot;</span><br><span class="line">#include &quot;resource.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 对话框</span><br><span class="line"></span><br><span class="line">IMPLEMENT_DYNAMIC(CMyDlg, CDialog)</span><br><span class="line"></span><br><span class="line">CMyDlg::CMyDlg(CWnd* pParent /*=NULL*/)</span><br><span class="line">: CDialog(IDD_DLGDEMO, pParent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyDlg::~CMyDlg()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CMyDlg::DoDataExchange(CDataExchange* pDX)</span><br><span class="line">&#123;</span><br><span class="line">CDialog::DoDataExchange(pDX);</span><br><span class="line"><span class="addition">+DDX_Control(pDX, IDC_BUTTON1, m_btn_OK);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CMyDlg, CDialog)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 消息处理程序</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details><p>选中按钮，在属性-&gt;控件事件中可以看到关于按钮的控件事件。我们展开BN_CLICKED，添加OnBnClickedButton成员函数</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108110507011.png" alt="image-20211108110507011"></p><p>MyDlg.h、MyDlg.cpp内容发生了改变，具体为：</p><details class="folding-tag" ><summary> 具体内容的变化 </summary>              <div class='content'>              <div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">MyDlg.h</button></li><li class="tab"><button type="button" data-href="#test4-2">MyDlg.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &quot;afxwin.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 对话框</span><br><span class="line"></span><br><span class="line">class CMyDlg : public CDialog</span><br><span class="line">&#123;</span><br><span class="line">DECLARE_DYNAMIC(CMyDlg)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">CMyDlg(CWnd* pParent = NULL);   // 标准构造函数</span><br><span class="line">virtual ~CMyDlg();</span><br><span class="line"></span><br><span class="line">// 对话框数据</span><br><span class="line">#ifdef AFX_DESIGN_TIME</span><br><span class="line">enum &#123; IDD = IDD_DLGDEMO &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持</span><br><span class="line"></span><br><span class="line">DECLARE_MESSAGE_MAP()</span><br><span class="line">public:</span><br><span class="line">CButton m_btn_OK;</span><br><span class="line"><span class="addition">+afx_msg void OnBnClickedButton1();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// MyDlg.cpp : 实现文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;MyDlg.h&quot;</span><br><span class="line">#include &quot;afxdialogex.h&quot;</span><br><span class="line">#include &quot;resource.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 对话框</span><br><span class="line"></span><br><span class="line">IMPLEMENT_DYNAMIC(CMyDlg, CDialog)</span><br><span class="line"></span><br><span class="line">CMyDlg::CMyDlg(CWnd* pParent /*=NULL*/)</span><br><span class="line">: CDialog(IDD_DLGDEMO, pParent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyDlg::~CMyDlg()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CMyDlg::DoDataExchange(CDataExchange* pDX)</span><br><span class="line">&#123;</span><br><span class="line">CDialog::DoDataExchange(pDX);</span><br><span class="line">DDX_Control(pDX, IDC_BUTTON1, m_btn_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+ BEGIN_MESSAGE_MAP(CMyDlg, CDialog)</span></span><br><span class="line"><span class="addition">+ON_BN_CLICKED(IDC_BUTTON1, &amp;CMyDlg::OnBnClickedButton1)</span></span><br><span class="line"><span class="addition">+ END_MESSAGE_MAP()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 消息处理程序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+ void CMyDlg::OnBnClickedButton1()</span></span><br><span class="line"><span class="addition">+ &#123;</span></span><br><span class="line"><span class="addition">+ // TODO: 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details><p>这里向MyDlg.cpp中的OnBnClickedButton1()添加控件通知处理程序代码，为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">::<span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;CMyDlg的Button&quot;</span>), MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&gt; 运行结果：</p><p>点击Button1按钮弹出对话框</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108111556825.png" alt="image-20211108111556825"></p>              </div>            </details><p>小结：</p><p>添加成员变量向导，是将控件（比如按钮）作为成员变量添加到对话框这个类里</p><p>(控件也是窗体，子窗体在父窗体里；对应C++语法就是类中的成员变量)</p><h3 id="App-Wizard值类型与控件类型">App Wizard值类型与控件类型</h3><p>添加成员变量向导中的类别有Control和Value两种，啥区别？</p><details class="folding-tag" ><summary> 例子：点击按钮，会修改文本框中的文本 </summary>              <div class='content'>              <p>向对话框添加文本框</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108112753083.png" alt="image-20211108112753083"></p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">不使用添加成员变量的方式，用传统win api的方式</button></li><li class="tab"><button type="button" data-href="#test4-2">使用添加变量的方式</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>使用传统Windows api的方式，拿句柄</p><p>将MyDlg.cpp的OnBnClickedButton1()函数内容修改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="comment">//::MessageBox(NULL, TEXT(&quot;Hello&quot;), TEXT(&quot;CMyDlg的Button&quot;), MB_OK);</span></span><br><span class="line"></span><br><span class="line">HWND hEdit = ::<span class="built_in">GetDlgItem</span>(<span class="keyword">this</span>-&gt;m_hWnd, IDC_EDIT1);<span class="comment">//this-&gt;m_hWnd：MFC当前对象的句柄</span></span><br><span class="line">::<span class="built_in">SetWindowText</span>(hEdit, <span class="built_in">TEXT</span>(<span class="string">&quot;我是Edit&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&gt; 运行结果：</p><p>按下按钮后文本框内容被修改</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108114048302.png" alt="image-20211108114048302"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">控件类型</button></li><li class="tab"><button type="button" data-href="#test4-2">值类型</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>对文本框添加变量，变量名这里起为:m_edit_ct1，类别选为Control</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108114254529.png" alt="image-20211108114254529"></p><p>MyDlg.h、MyDlg.cpp的内容发生了变化，具体变化为：</p><details class="folding-tag" ><summary> 具体内容的变化 </summary>              <div class='content'>              <div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">MyDlg.h</button></li><li class="tab"><button type="button" data-href="#test4-2">MyDlg.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &quot;afxwin.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 对话框</span><br><span class="line"></span><br><span class="line">class CMyDlg : public CDialog</span><br><span class="line">&#123;</span><br><span class="line">DECLARE_DYNAMIC(CMyDlg)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">CMyDlg(CWnd* pParent = NULL);   // 标准构造函数</span><br><span class="line">virtual ~CMyDlg();</span><br><span class="line"></span><br><span class="line">// 对话框数据</span><br><span class="line">#ifdef AFX_DESIGN_TIME</span><br><span class="line">enum &#123; IDD = IDD_DLGDEMO &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持</span><br><span class="line"></span><br><span class="line">DECLARE_MESSAGE_MAP()</span><br><span class="line">public:</span><br><span class="line">CButton m_btn_OK;</span><br><span class="line">afx_msg void OnBnClickedButton1();</span><br><span class="line"><span class="addition">+CEdit m_edit_ct1;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// MyDlg.cpp : 实现文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;MyDlg.h&quot;</span><br><span class="line">#include &quot;afxdialogex.h&quot;</span><br><span class="line">#include &quot;resource.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 对话框</span><br><span class="line"></span><br><span class="line">IMPLEMENT_DYNAMIC(CMyDlg, CDialog)</span><br><span class="line"></span><br><span class="line">CMyDlg::CMyDlg(CWnd* pParent /*=NULL*/)</span><br><span class="line">: CDialog(IDD_DLGDEMO, pParent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyDlg::~CMyDlg()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CMyDlg::DoDataExchange(CDataExchange* pDX)</span><br><span class="line">&#123;</span><br><span class="line">CDialog::DoDataExchange(pDX);</span><br><span class="line">DDX_Control(pDX, IDC_BUTTON1, m_btn_OK);</span><br><span class="line"><span class="addition">+DDX_Control(pDX, IDC_EDIT1, m_edit_ct1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CMyDlg, CDialog)</span><br><span class="line">ON_BN_CLICKED(IDC_BUTTON1, &amp;CMyDlg::OnBnClickedButton1)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 消息处理程序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void CMyDlg::OnBnClickedButton1()</span><br><span class="line">&#123;</span><br><span class="line">// TODO: 在此添加控件通知处理程序代码</span><br><span class="line">//::MessageBox(NULL, TEXT(&quot;Hello&quot;), TEXT(&quot;CMyDlg的Button&quot;), MB_OK);</span><br><span class="line"></span><br><span class="line">HWND hEdit = ::GetDlgItem(this-&gt;m_hWnd, IDC_EDIT1);//this-&gt;m_hWnd：MFC当前对象的句柄</span><br><span class="line">::SetWindowText(hEdit, TEXT(&quot;我是Edit&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details><p>在MyDlg.cpp的OnBnClickedButton1()函数中使用对象m_edit_ct1,可以看到这个对象里已封装了很多的方法供程序员调用</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108165436693.png" alt="image-20211108165436693"></p><p>修改OnBnClickedButton1()函数为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="comment">//::MessageBox(NULL, TEXT(&quot;Hello&quot;), TEXT(&quot;CMyDlg的Button&quot;), MB_OK);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//HWND hEdit = ::GetDlgItem(this-&gt;m_hWnd, IDC_EDIT1);//this-&gt;m_hWnd：MFC当前对象的句柄</span></span><br><span class="line"><span class="comment">//::SetWindowText(hEdit, TEXT(&quot;我是Edit&quot;));</span></span><br><span class="line"></span><br><span class="line">m_edit_ct1.<span class="built_in">SetWindowTextW</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Control类型改的！&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&gt; 运行结果（运行前我把文本框拉长了，要不显示不全）：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108165940141.png" alt="image-20211108165940141"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p>对文本框添加变量，由于先前添加过Control类别，不能再添加Control类别</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108170209157.png" alt="image-20211108170209157"></p><p>我们添加Value类别，可以看到变量类型（自动）显示CSstring，变量名这里我们起为m_edit_cs</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108170233964.png" alt="image-20211108170233964"></p><p>MyDlg.h、MyDlg.cpp的内容发生了变化，具体变化为：</p><details class="folding-tag" ><summary> 具体内容的变化 </summary>              <div class='content'>              <div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">MyDlg.h</button></li><li class="tab"><button type="button" data-href="#test4-2">MyDlg.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &quot;afxwin.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 对话框</span><br><span class="line"></span><br><span class="line">class CMyDlg : public CDialog</span><br><span class="line">&#123;</span><br><span class="line">DECLARE_DYNAMIC(CMyDlg)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">CMyDlg(CWnd* pParent = NULL);   // 标准构造函数</span><br><span class="line">virtual ~CMyDlg();</span><br><span class="line"></span><br><span class="line">// 对话框数据</span><br><span class="line">#ifdef AFX_DESIGN_TIME</span><br><span class="line">enum &#123; IDD = IDD_DLGDEMO &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持</span><br><span class="line"></span><br><span class="line">DECLARE_MESSAGE_MAP()</span><br><span class="line">public:</span><br><span class="line">CButton m_btn_OK;</span><br><span class="line">afx_msg void OnBnClickedButton1();</span><br><span class="line">CEdit m_edit_ct1;</span><br><span class="line"><span class="addition">+CString m_edit_cs;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// MyDlg.cpp : 实现文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;MyDlg.h&quot;</span><br><span class="line">#include &quot;afxdialogex.h&quot;</span><br><span class="line">#include &quot;resource.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 对话框</span><br><span class="line"></span><br><span class="line">IMPLEMENT_DYNAMIC(CMyDlg, CDialog)</span><br><span class="line"></span><br><span class="line">CMyDlg::CMyDlg(CWnd* pParent /*=NULL*/)</span><br><span class="line">: CDialog(IDD_DLGDEMO, pParent)</span><br><span class="line">, m_edit_cs(_T(&quot;&quot;))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyDlg::~CMyDlg()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CMyDlg::DoDataExchange(CDataExchange* pDX)</span><br><span class="line">&#123;</span><br><span class="line">CDialog::DoDataExchange(pDX);</span><br><span class="line">DDX_Control(pDX, IDC_BUTTON1, m_btn_OK);</span><br><span class="line">DDX_Control(pDX, IDC_EDIT1, m_edit_ct1);</span><br><span class="line"><span class="addition">+DDX_Text(pDX, IDC_EDIT1, m_edit_cs);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CMyDlg, CDialog)</span><br><span class="line">ON_BN_CLICKED(IDC_BUTTON1, &amp;CMyDlg::OnBnClickedButton1)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CMyDlg 消息处理程序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void CMyDlg::OnBnClickedButton1()</span><br><span class="line">&#123;</span><br><span class="line">// TODO: 在此添加控件通知处理程序代码</span><br><span class="line">//::MessageBox(NULL, TEXT(&quot;Hello&quot;), TEXT(&quot;CMyDlg的Button&quot;), MB_OK);</span><br><span class="line"></span><br><span class="line">//HWND hEdit = ::GetDlgItem(this-&gt;m_hWnd, IDC_EDIT1);//this-&gt;m_hWnd：MFC当前对象的句柄</span><br><span class="line">//::SetWindowText(hEdit, TEXT(&quot;我是Edit&quot;));</span><br><span class="line"></span><br><span class="line">m_edit_ct1.SetWindowTextW(TEXT(&quot;Control类型改的！&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details><p>修改OnBnClickedButton1()函数为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="comment">//::MessageBox(NULL, TEXT(&quot;Hello&quot;), TEXT(&quot;CMyDlg的Button&quot;), MB_OK);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//HWND hEdit = ::GetDlgItem(this-&gt;m_hWnd, IDC_EDIT1);//this-&gt;m_hWnd：MFC当前对象的句柄</span></span><br><span class="line"><span class="comment">//::SetWindowText(hEdit, TEXT(&quot;我是Edit&quot;));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//m_edit_ct1.SetWindowTextW(TEXT(&quot;Control类型改的！&quot;));</span></span><br><span class="line"></span><br><span class="line">m_edit_cs = <span class="built_in">TEXT</span>(<span class="string">&quot;我是CS类型的CEdit！&quot;</span>);</span><br><span class="line"><span class="built_in">UpdateData</span>(FALSE);<span class="comment">//上一句只是改了内容，没这一句，不会显示在文本框中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&gt; 运行结果：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108171306054.png" alt="image-20211108171306054"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details><p>小结：</p><p>所谓App Wizard就是一种让我们可以用C++的语法，操作这些对象的机制</p><p>只要我们查阅msdn，查阅MFC的手册，我们就可以完成逻辑业务的开发</p><h3 id="对话框应用程序程序设计">对话框应用程序程序设计</h3><ul><li>以对话框应用程序设计为例，熟悉MFC开发环境，提高定制MFC开发的能力</li></ul><details class="folding-tag" ><summary> 创建MFC项目03MFCCheckboxDemo，基于对话框 </summary>              <div class='content'>              <p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108173901400.png" alt="image-20211108173901400"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108173919424.png" alt="image-20211108173919424"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108174007226.png" alt="image-20211108174007226"></p><p>保持默认，下一步</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108174034447.png" alt="image-20211108174034447"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108174045530.png" alt="image-20211108174045530"></p><p>点击完成</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108174140449.png" alt="image-20211108174140449"></p><details class="folding-tag" ><summary> 题外话 </summary>              <div class='content'>              <p>（题外话：CMy03MFCCheckboxDemoApp是进程实例，CMy03MFCCheckboxDemoDlg是我们画出来的窗口）</p>              </div>            </details>              </div>            </details><details class="folding-tag" ><summary> 观察体会下自动生成的文件 </summary>              <div class='content'>              <p>右边的文件都是自动生成的</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108200808483.png" alt="image-20211108200808483"></p><p>运行一下：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108201017683.png" alt="image-20211108201017683"></p><p>查看下资源视图</p><p>有个aboutbox资源、对话框资源</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108201129888.png" alt="image-20211108201129888"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108201224517.png" alt="image-20211108201224517"></p><p>在类视图中双击CAboutDlg，转到定义处</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span>IDD=IDD_ABOUTBOX&#125;;</span><br></pre></td></tr></table></figure><p>上面这句代码完成aboutbox资源与C++对象的绑定</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108201403404.png" alt="image-20211108201403404"></p><p>对话框的资源同理</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108201653583.png" alt="image-20211108201653583"></p>              </div>            </details><details class="folding-tag" ><summary> 例子：CheckBox置顶功能 </summary>              <div class='content'>              <p>向对话框添加一个Check Box，修改ID和Caption</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108202229723.png" alt="image-20211108202229723"></p><p>运行一下:</p><p>可以勾上也可以取消，只不过我们还没对勾上时进行业务逻辑开发</p> <img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108202257655.png" style="height:200px;"/> <img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108202307520.png" style="height:200px;"/> <p>对这个复选框添加变量：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108202504093.png" alt="image-20211108202504093"></p><p>选中checkbox，属性窗口中选中控件事件，添加按下时的成员函数</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108202714620.png" alt="image-20211108202714620"></p><p>编写成员函数内容为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy03MFCCheckboxDemoDlg::OnBnClickedChkTopmost</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="keyword">if</span> (m_chk_ct1.<span class="built_in">GetCheck</span>())<span class="comment">//被选中</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SetWindowPos</span>(&amp;wndTopMost, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//没被选中</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//取消置顶</span></span><br><span class="line"><span class="built_in">SetWindowPos</span>(&amp;wndNoTopMost, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&gt; 运行结果：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108204038526.png" alt="image-20211108204038526"></p>              </div>            </details><hr><details class="folding-tag" ><summary> 例子：Combox控件及TRACE使用 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 项目创建 </summary>              <div class='content'>              <p>创建MFC应用程序项目04CComboxDemo，基于对话框，去掉SDL检查</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108205003456.png" alt="image-20211108205003456"></p><p>不选系统菜单，不选“关于”框（资源中就没aboutbox了）</p>              </div>            </details><p>向对话框添加Combo Box控件，属性中Data内容为选择框条目，条目间以;分隔</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108210051055.png" alt="image-20211108210051055"></p><p>运行：</p><p>按下拉，有3个条目可选择</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108210133089.png" alt="image-20211108210133089"></p><p>向对话框添加Button按钮，对按钮添加变量</p> <img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108210440139.png" style="height:180px;"/> <img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108210407224.png" style="height:200px;"/> <p>对按钮添加BN_CLICKED事件的成员函数OnBnClickedButton1</p><p>一：通过按钮获取Combox的内容</p><p>将成员函数OnBnClickedButton1编写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy04CComboxDemoDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">TCHAR ws[<span class="number">256</span>];</span><br><span class="line">((CComboBox*)<span class="built_in">GetDlgItem</span>(IDC_COMBO1))-&gt;<span class="built_in">GetWindowTextW</span>(ws, <span class="number">256</span>);</span><br><span class="line"><span class="comment">//GetDlgItem返回类型为CWnd，强转为CComboBox类型</span></span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;---%S\n&quot;</span>, ws);</span><br><span class="line"><span class="comment">//用TRACE，方便调试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用Messagebox可能会阻碍当前进程运行，而TRACE是在输出窗口输出，不会影响进程执行</p><p>&gt; 运行:</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108211241354.png" alt="image-20211108211241354"></p><p>输出窗口输出</p><p>二：通过按钮往Combox里添加选择条目</p><p>将成员函数OnBnClickedButton1编写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy04CComboxDemoDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="comment">//TCHAR ws[256];</span></span><br><span class="line"><span class="comment">//((CComboBox*)GetDlgItem(IDC_COMBO1))-&gt;GetWindowTextW(ws, 256);</span></span><br><span class="line"><span class="comment">////GetDlgItem返回类型为CWnd，强转为CComboBox类型</span></span><br><span class="line"><span class="comment">//TRACE(&quot;---%S\n&quot;, ws);</span></span><br><span class="line"><span class="comment">////用TRACE，方便调试</span></span><br><span class="line"></span><br><span class="line">CComboBox* pCmb = (CComboBox*)<span class="built_in">GetDlgItem</span>(IDC_COMBO1);</span><br><span class="line">pCmb-&gt;<span class="built_in">AddString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;444&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&gt; 运行：</p><p>原本只有3个条目</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108211925406.png" alt="image-20211108211925406"></p><p>每点一次Button1，会加一条444</p> <img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/F[3SF9ZK5{N1H95B2AG1O8.png" style="height:220px;"/> <img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211108212113786.png" style="height:220px;"/>               </div>            </details><hr><details class="folding-tag" ><summary> 例子：List Box与windows消息 </summary>              <div class='content'>              <blockquote><p>创建MFC应用程序项目05CListBoxDemo，基于对话框，去SDL检查，去系统菜单</p></blockquote><p>添加List Box</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109101027916.png" alt="image-20211109101027916"></p><p>右键-&gt;类向导</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109102139461.png" alt="image-20211109102139461"></p><p>在<kbd>消息</kbd>中选择<kbd>WM_LBUTTONDOWN</kbd>，点<kbd>添加处理程序</kbd>，会生成一个OnLButtonDown的函数，选择它点<kbd>编辑代码</kbd>会跳到这个函数体</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109102326460.png" alt="image-20211109102326460"></p><p>编辑函数体</p><details class="folding-tag" ><summary> 加个弹窗演示一下 </summary>              <div class='content'>              <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void CMy05CListBoxDemoDlg::OnLButtonDown(UINT nFlags, CPoint point)</span><br><span class="line">&#123;</span><br><span class="line">// TODO: 在此添加消息处理程序代码和/或调用默认值</span><br><span class="line"><span class="addition">+AfxMessageBox(TEXT(&quot;Hello Test&quot;));</span></span><br><span class="line">CDialogEx::OnLButtonDown(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p>在客户区一些区域按下鼠标左键会弹窗（后边会提事件冒泡）</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109103206124.png" alt="image-20211109103206124"></p>              </div>            </details><details class="folding-tag" ><summary> 每次按下鼠标左键往List Box里添加文本 </summary>              <div class='content'>              <p>修改函数体为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy05CListBoxDemoDlg::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="comment">//AfxMessageBox(TEXT(&quot;Hello Test&quot;));</span></span><br><span class="line"></span><br><span class="line">CListBox* pList = (CListBox*)<span class="built_in">GetDlgItem</span>(IDC_LIST1);</span><br><span class="line">pList-&gt;<span class="built_in">AddString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;1111&quot;</span>));</span><br><span class="line"></span><br><span class="line">CDialogEx::<span class="built_in">OnLButtonDown</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时要在这个文件前边#include “resource.h”</p><p>运行：</p><p><img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109103959866.png" style="height:180px;"/> <img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109104010216.png" style="height:180px;"/> <img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109104024209.png" style="height:180px;"/></p>              </div>            </details>              </div>            </details><details class="folding-tag" ><summary> 小综合例子：List Box、Button、Edit与事件冒泡概念 </summary>              <div class='content'>              <p>添加Button（修改Caption为&gt;&gt;)、Static Text</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109105351361.png" alt="image-20211109105351361"></p><p>直接对Button按钮添加成员函数（不先添加变量也行的）</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109105458336.png" alt="image-20211109105458336"></p><p>编写函数体为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy05CListBoxDemoDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line">CListBox* pList = (CListBox*)<span class="built_in">GetDlgItem</span>(IDC_LIST1);</span><br><span class="line">CStatic* pCs = (CStatic*)<span class="built_in">GetDlgItem</span>(IDC_STATIC);</span><br><span class="line">WCHAR ws[<span class="number">256</span>];</span><br><span class="line">pList-&gt;<span class="built_in">GetText</span>(pList-&gt;<span class="built_in">GetCurSel</span>(), ws);</span><br><span class="line">pCs-&gt;<span class="built_in">SetWindowTextW</span>(ws);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p>先鼠标按下左键往List Box里添加条目，然后按Button按钮，但List Box的条目没有显示在Static文本框中</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109105923855.png" alt="image-20211109105923855"></p><details class="folding-tag" ><summary> 原因 </summary>              <div class='content'>              <p>下断</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109144127945.png" alt="image-20211109144127945"></p><p>运行，添加条目后点Button按钮</p><p>点击鼠标左键确实进到了OnBnClickedButton1()函数</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109144359366.png" alt="image-20211109144359366"></p><p>对pList-&gt;GetCurSel()添加监视</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109144553330.png" alt="image-20211109144553330"></p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109144615635.png" alt="image-20211109144615635"  /><p>说明没选中</p><p>点击 <img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109144813882.png" style="height:30px;"/> ，点击红色断点把断点取消<img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109144851611.png" style="height:90px;"/></p><p>这次选中条目再按Button按钮，可以了（有个小bug：1111不是跑到Static而是下方，<s>请假装没看到</s>）</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109144933932.png" alt="image-20211109144933932"></p>              </div>            </details><details class="folding-tag" ><summary> 事件冒泡简要介绍 </summary>              <div class='content'>              <p>同样是鼠标按下左键，为何按Button（获取List Box选中的条目然后给Static设置文本）和其他区域（给List Box添加条目）有不同的效果？</p><p>答：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109150426958.png" alt="image-20211109150426958"></p><p>在子窗体区域按下鼠标左键，父窗体也能感知到，但这个事件被子窗体处理，父窗体就不处理了，这是MFC一个很好的封装。</p><p>如果需要由父窗体来处理这个事件，可以改。但实际应用中，都是子窗体处理，父窗体无需处理。程序员直接开发就完事，虽然可能会感到困惑。</p>              </div>            </details>              </div>            </details><h3 id="标准控件综合案例：网页管理专家">标准控件综合案例：网页管理专家</h3><p>需求与功能点说明：</p><ol><li>进一步巩固MFC使用C++语法封装windows窗体的概念，演示基于C++类的窗体间传值</li><li>使用剪贴板完成进程间通信（进一步探讨进程间内存共享的概念）</li><li>如何在VC中启动新进程</li><li>MFC中如何完成Cstring字符串分割</li></ol><p>现实意义：</p><p>双击条目打开网址，然后粘贴用户名，一个比较方便快捷的网页用户收藏夹</p><details class="folding-tag" ><summary> 资源布局 </summary>              <div class='content'>              <blockquote><p>MFC应用程序，项目名称为05AddrExpert，对话框，去SDL检查，去系统菜单，高级功能全去</p></blockquote><p>对默认的窗体进行调整</p><p>调整前后：</p><p><img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109155749695.png" style="height:200px;"/>  <img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109205813784.png" style="height:220px;"/></p><table><thead><tr><th>控件类型</th><th>Caption</th><th>ID</th></tr></thead><tbody><tr><td>Button</td><td>添加网址</td><td>IDC_BTNADD</td></tr><tr><td>List Box</td><td>没改</td><td>没改</td></tr></tbody></table><p>在<kbd>资源文件</kbd>添加资源-Dialog</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109210027247.png" alt="image-20211109210027247"></p><table><thead><tr><th>控件类型</th><th>ID</th></tr></thead><tbody><tr><td>Dialog</td><td>IDD_DLGADDR</td></tr></tbody></table><p>加一些控件及修改：</p><table><thead><tr><th>控件类型</th><th>ID</th></tr></thead><tbody><tr><td>Edit Control</td><td>IDC_EDITADDR</td></tr><tr><td>Edit Control</td><td>IDC_EDITUSER</td></tr></tbody></table><table><thead><tr><th>控件类型</th><th>Caption</th></tr></thead><tbody><tr><td>Static Text</td><td>网址</td></tr><tr><td>Static Text</td><td>用户名</td></tr></tbody></table><table><thead><tr><th>控件类型</th><th>Caption</th><th>Name</th></tr></thead><tbody><tr><td>Button</td><td>确认添加</td><td>没变</td></tr></tbody></table><p>（要对这个对话框添加类，有了相应的.h、.cpp文件，才能往里添加代码，才把资源变成MFC可以识别的类）</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109211715478.png" alt="image-20211109211715478"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109211752955.png" alt="image-20211109211752955"></p>              </div>            </details><details class="folding-tag" ><summary> 添加网址和字符串切割 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 确认添加 按钮 </summary>              <div class='content'>              <p>对<code>确认添加</code>按钮控件事件中的<code>BN_CLICKED</code>添加<code>OnBnClickedButton1</code></p><p>在<code>DlgAddr.h</code>加两个<code>CString</code>成员</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CDlgAddr 对话框</span><br><span class="line"></span><br><span class="line">class CDlgAddr : public CDialogEx</span><br><span class="line">&#123;</span><br><span class="line">DECLARE_DYNAMIC(CDlgAddr)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">CDlgAddr(CWnd* pParent = NULL);   // 标准构造函数</span><br><span class="line">virtual ~CDlgAddr();</span><br><span class="line"></span><br><span class="line">//add by Dingst</span><br><span class="line"><span class="addition">+CString strAddr;</span></span><br><span class="line"><span class="addition">+CString strUser;</span></span><br><span class="line"></span><br><span class="line">// 对话框数据</span><br><span class="line">#ifdef AFX_DESIGN_TIME</span><br><span class="line">enum &#123; IDD = IDD_DIALOG1 &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持</span><br><span class="line"></span><br><span class="line">DECLARE_MESSAGE_MAP()</span><br><span class="line">public:</span><br><span class="line">afx_msg void OnBnClickedButton1();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写<code>OnBnClickedButton1</code>函数体（<code>DlgAddr.cpp</code>文件）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDlgAddr::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="built_in">GetDlgItemText</span>(IDC_EDITADDR, strAddr);</span><br><span class="line"><span class="built_in">GetDlgItemText</span>(IDC_EDITUSER, strUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" ><summary> 添加网址 按钮 </summary>              <div class='content'>              <p>对<kbd>添加网址</kbd>按钮控件事件中的<code>BN_CLICKED</code>添加<code>OnBnClickedBtnadd</code></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211109213028529.png" alt="image-20211109213028529"></p><p>编写函数体<code>OnBnClickedBtnadd</code>（05AddrExpertDlg.cpp文件，前边<code>#include &quot;DlgAddr.h&quot;</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy05AddrExpertDlg::OnBnClickedBtnadd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line">CDlgAddr dlg;</span><br><span class="line">dlg.<span class="built_in">DoModal</span>();<span class="comment">//显示对话框</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将网址和用户名内容放到List Box中</span></span><br><span class="line">CListBox* pList = (CListBox*)(<span class="built_in">GetDlgItem</span>(IDC_LIST1));</span><br><span class="line">pList-&gt;<span class="built_in">AddString</span>(dlg.strAddr + <span class="string">&quot;;&quot;</span> + dlg.strUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p> <img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/添加网址.gif" style="height:400px;"/>               </div>            </details><details class="folding-tag" ><summary> List Box控件 </summary>              <div class='content'>              <p>对<kbd>List Box</kbd>控件事件中的<code>LBN_DBLCLK</code>添加<code>OnLbnDblclkList1</code></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211110103625328.png" alt="image-20211110103625328"></p><p>编写函数体<code>OnLbnDblclkList1</code>（05AddrExpertDlg.cpp文件）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy05AddrExpertDlg::OnLbnDblclkList1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">CListBox* pList = ((CListBox*)<span class="built_in">GetDlgItem</span>(IDC_LIST1));</span><br><span class="line"></span><br><span class="line">CString strTemp;</span><br><span class="line">pList-&gt;<span class="built_in">GetText</span>(pList-&gt;<span class="built_in">GetCurSel</span>(), strTemp);<span class="comment">//pList-&gt;GetCurSel()选哪一行</span></span><br><span class="line"><span class="comment">//我们拿到的都是形如&quot;https://mail.qq.com;123@qq.com&quot;</span></span><br><span class="line"><span class="comment">//要对字符串进行切割，MFC有提供切割的函数</span></span><br><span class="line"></span><br><span class="line">CString output;</span><br><span class="line"><span class="built_in">AfxExtractSubString</span>(output, strTemp, <span class="number">0</span>, <span class="string">&#x27;;&#x27;</span>);<span class="comment">//&#x27;;&#x27;号0个</span></span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;0----&gt;%S&quot;</span>, output);<span class="comment">//运行看下对不对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p>添加网址后双击这个条目，可以看到输出窗口，切割成功</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211110104441337.png" alt="image-20211110104441337"></p>              </div>            </details>              </div>            </details><details class="folding-tag" ><summary> 打开网址 </summary>              <div class='content'>              <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void CMy05AddrExpertDlg::OnLbnDblclkList1()</span><br><span class="line">&#123;</span><br><span class="line">// TODO: 在此添加控件通知处理程序代码</span><br><span class="line">CListBox* pList = ((CListBox*)GetDlgItem(IDC_LIST1));</span><br><span class="line"></span><br><span class="line">CString strTemp;</span><br><span class="line">pList-&gt;GetText(pList-&gt;GetCurSel(), strTemp);//pList-&gt;GetCurSel()选哪一行</span><br><span class="line">//我们拿到的都是形如&quot;https://mail.qq.com;123@qq.com&quot;</span><br><span class="line">//要对字符串进行切割，MFC有提供切割的函数</span><br><span class="line"></span><br><span class="line">CString output;</span><br><span class="line">AfxExtractSubString(output, strTemp, 0, &#x27;;&#x27;);//&#x27;;&#x27;号0个</span><br><span class="line">TRACE(&quot;0----&gt;%S&quot;, output);//运行下在输出窗口看切割对不对</span><br><span class="line"></span><br><span class="line"><span class="addition">+ShellExecute(NULL, TEXT(&quot;open&quot;), output, NULL, NULL, SW_SHOW);//打开网址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p>添加网址后，双击条目，现象：打开了浏览器进入了网址</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211110105046199.png" alt="image-20211110105046199"></p>              </div>            </details><details class="folding-tag" ><summary> 剪贴板功能 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 参考以及拓展 </summary>              <div class='content'>              <p>剪贴板流程：</p><p><a href="https://www.zhihu.com/question/398335345/answer/1258940042">当我们在电脑按下ctrl+c，剪切板储存了哪些信息？ - ShellBin的回答 - 知乎</a></p><p>流程图解：</p><p><a href="https://www.zhihu.com/question/66284095/answer/240367965">电脑复制粘贴背后发生了什么？ - SuperSodaSea的回答 - 知乎</a></p><p>MSDN：</p><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/dataxchg/clipboard?redirectedfrom=MSDN">剪贴板</a></p>              </div>            </details><p>Windows系统里，剪贴板(clipboard)功能，可以在不同的进程里进行数据交换，也就是说两个进程上是可以共享数据，要实现这样的功能，Windows系统提供了API函数GlobalAlloc来分配全局内存，可以让不同的进程实现数据共享。</p><ol><li>打开并清空剪贴板<br><code>OpenClipboard &amp; EmptyClipboard</code></li><li>分配全局内存<br><code>GlobalAlloc</code></li><li>向全局内存放入想要拷贝的内容<br><code>SetClipboardData</code></li><li>把内容送到剪贴板<br><code>CloseClipboard</code></li><li>关闭剪贴板，以使其他程序可以访问，释放掉全局内存<br><code>GlobalFree</code></li></ol><p>继续编写函数体<code>OnLbnDblclkList1</code>（05AddrExpertDlg.cpp文件）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy05AddrExpertDlg::OnLbnDblclkList1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">CListBox* pList = ((CListBox*)<span class="built_in">GetDlgItem</span>(IDC_LIST1));</span><br><span class="line"></span><br><span class="line">CString strTemp;</span><br><span class="line">pList-&gt;<span class="built_in">GetText</span>(pList-&gt;<span class="built_in">GetCurSel</span>(), strTemp);<span class="comment">//pList-&gt;GetCurSel()选哪一行</span></span><br><span class="line"><span class="comment">//我们拿到的都是形如&quot;https://mail.qq.com;123@qq.com&quot;</span></span><br><span class="line"><span class="comment">//要对字符串进行切割，MFC有提供切割的函数</span></span><br><span class="line"></span><br><span class="line">CString output;</span><br><span class="line"><span class="built_in">AfxExtractSubString</span>(output, strTemp, <span class="number">0</span>, <span class="string">&#x27;;&#x27;</span>);<span class="comment">//&#x27;;&#x27;号0个</span></span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;0----&gt;%S&quot;</span>, output);<span class="comment">//运行下在输出窗口看切割对不对</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ShellExecute</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;open&quot;</span>), output, <span class="literal">NULL</span>, <span class="literal">NULL</span>, SW_SHOW);<span class="comment">//打开网址</span></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="built_in">AfxExtractSubString</span>(output, strTemp, <span class="number">1</span>, <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">HGLOBAL p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">OpenClipboard</span>())<span class="comment">//剪贴板没被其他进程占用，能打开</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">EmptyClipboard</span>();<span class="comment">//清空剪切板</span></span><br><span class="line">USES_CONVERSION;<span class="comment">//这个宏会告诉编译器，在紧接的代码中我们要用OLE库中代码(如ansi到unicode的A2W(...))的转换宏</span></span><br><span class="line"><span class="comment">//MFC是Unicode或多字节</span></span><br><span class="line"><span class="keyword">char</span> szName[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(szName, <span class="built_in">T2A</span>(output));<span class="comment">//T2A，Unicode/多字节转char数组</span></span><br><span class="line"></span><br><span class="line">HGLOBAL hMem = <span class="built_in">GlobalAlloc</span>(GHND, <span class="built_in"><span class="keyword">sizeof</span></span>(szName));<span class="comment">//分配全局内存</span></span><br><span class="line"><span class="keyword">char</span>* pmem = (<span class="keyword">char</span>*)<span class="built_in">GlobalLock</span>(hMem);<span class="comment">//锁定全局内存</span></span><br><span class="line"><span class="built_in">memcpy</span>(pmem, szName, <span class="built_in"><span class="keyword">sizeof</span></span>(szName));<span class="comment">//向全局内存放入内容</span></span><br><span class="line"><span class="built_in">SetClipboardData</span>(CF_TEXT, hMem);<span class="comment">//把内容送到剪贴板</span></span><br><span class="line"><span class="built_in">CloseClipboard</span>();<span class="comment">//关闭剪贴板，以使其他程序可以访问</span></span><br><span class="line">p = <span class="built_in">GlobalFree</span>(hMem);<span class="comment">//释放全局内存</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p>添加网址https://mail.qq.com，用户名123@qq.com。双击条目后浏览器会转到网址，剪贴板有123@qq.com</p><img no-lazy class="inline" src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/网页管理专家-剪贴板.gif" style="height:400px;"/> <details class="folding-tag" ><summary> 用户空间与内核空间 </summary>              <div class='content'>              <p><a href="https://www.cnblogs.com/ai616818/archive/2012/04/18/2455520.html">内核空间由所有进程共享</a></p><p>0~2G为用户空间，所有进程共享2-4G的内核空间。剪贴板本质上是内核空间的一块内存存储区。</p><p>网页管理专家这个进程按剪贴板使用的流程，在内核空间申请全局内存，放入用户名，再把这块内容送到剪贴板，释放剪贴板，释放全局内存（因为其他进程也可能会申请全局内存，如果不释放，系统空间就那么大，用完会内存泄漏）。因为内核空间共享，所以浏览器使用剪贴板时有用户名这个剪贴选项。</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211114151007350.png" alt="image-20211114151007350"></p>              </div>            </details>              </div>            </details><h3 id="MFC多线程技术">MFC多线程技术</h3><h4 id="MFC线程概论">MFC线程概论</h4><p>MFC中有两类线程，分别称为工作者线程和用户界面线程。二者的区别在于工作者线程没有消息循环，而用户界面线程有自己的消息队列和消息循环。</p><p>工作者线程没有消息机制，通常用来执行后台计算和维护任务，如冗长的计算过程，打印机的后台打印等。用户界面线程一般用于处理独立于其他线程之外的用户输入，响应用户及系统所产省的事件和消息等。但对于Win32的API编程而言，这两种线程是没有区别的，他们都只需要线程的启动地址即可启动线程来执行任务。</p><p>在MFC中，一般用于全局函数AfxBeginThread()来创建并初始化一个线程的运行，该函数有两种重载形式，分别用于创建工作者线程和用户界面线程。两种重载函数原型和参数分别说明如下：<br>（1）工作者线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CWndThread *<span class="title">AfxBeginThread</span><span class="params">(AFX_THREADPROC pfnThreadProc,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID pParam,</span></span></span><br><span class="line"><span class="params"><span class="function">UINT nPriority=THREAD_PRIORITY_NORMAL,</span></span></span><br><span class="line"><span class="params"><span class="function">UNIT nStackSize=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dwCreateFlags=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">LPSECURITY_ATTRIBUTES lpSecurityAttrs=<span class="literal">NULL</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>（2）UI线程（用户界面线程）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CWndThread *<span class="title">AfxBeginThread</span><span class="params">(CRuntimeClass *pThreadClass)</span>,</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> nPriority</span>=THREAD_PRIORITY_NORMAL,</span><br><span class="line">UINT nStackSize=<span class="number">0</span>,</span><br><span class="line">DWORD dwCreateFlags=<span class="number">0</span>,</span><br><span class="line">LPSECURITY_ATTRIBUTES lpSecurityAttrs=<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><details class="folding-tag" ><summary> 使用MFC多线程的简单例子 </summary>              <div class='content'>              <blockquote><p>Win32控制台应用程序，项目名06MFCWorkerThread，选空项目，去预编译头、去SDL</p><p>项目-属性-<code>在共享DLL中使用MFC</code></p></blockquote><p>新建源文件<code>MFCWorkerThread.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">UINT <span class="title">MyFunc</span><span class="params">(LPVOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我的线程ID是:%d\n&quot;</span>, <span class="built_in">AfxGetThread</span>()-&gt;m_nThreadID);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AfxBeginThread</span>(MyFunc, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211115163453006.png" alt="image-20211115163453006"></p>              </div>            </details><p>AfxBeginThread()创建线程的流程不论哪个AfxBeginThread()，首先都是创建MFC线程对象，然后创建Win32线程对象。</p><p><code>AfxBeginThread创建线程的流程图</code></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/1606677-20190311204758391-1595626385.png" alt="img"></p><h4 id="MFC线程技术剖析">MFC线程技术剖析</h4><p>MFC的核心类库中有一个名为CWinThread的类，这个类在MFC的底层机理中占举足轻重的地位。</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211115192528572.png" alt="image-20211115192528572"></p><p>线程状态用类_AFX_THREAD_STATE描述;模块状态用类_AFX_MODULE_STATE描述;模块-线程状态用类_AFX_MODULE_THREAD_STATE描述。这些类都从类CNoTrackObject派生。</p><p>进程状态用类_AFX_BASE_MODULE_STATE描述，从模块状态_AFX_MODULE_STATE派生。</p><p>进程状态是一个可以独立执行的MFC应用程序的模块状态。还有其他状态如DLL的模块状态等也从模块状态类_AFX_MODULE_STATE派生。</p><p>MFC状态类的层次：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/1606677-20190311205013773-1733349773.png" alt="img"></p><p>模块、线程、模块-线程状态的关系</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/1606677-20190311205027669-1132928868.png" alt="img"></p><h4 id="多线程实践案例：多线程文件搜索器">多线程实践案例：多线程文件搜索器</h4><p>前继知识：搜索文件的api</p><p>查找文件的时候，首先使用<code>FindFirstFile</code>函数，如果函数执行成功，返回句柄<code>hFindFile</code>来对应这个寻找操作，接下来可以利用这个句柄循环调用FindNextFile函数继续查找其他文件，直到该函数返回失败（FALSE）为止。最后还要调用<code>FindClose</code>函数关闭<code>hFindFile</code>句柄</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hFindFile=::<span class="built_in">FindFirstFile</span>(lpFileName,lpFindData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hFindFile!=INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="comment">//..//处理本次找到的文件</span></span><br><span class="line">&#125;<span class="keyword">while</span>(::<span class="built_in">FindNextFile</span>(hFindFile,lpFindData));</span><br><span class="line">::<span class="built_in">FindClose</span>(hFindFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details class="folding-tag" ><summary> 小例子 </summary>              <div class='content'>              <blockquote><p>Win32控制台应用程序，项目名<code>07MultiThreadFindFile</code>，选空项目，去预编译头、去SDL</p><p>项目-属性-<code>在共享DLL中使用MFC</code>，<code>使用多字节字符集</code></p></blockquote><p>新建源文件<code>FileFind.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> szFileName[] = <span class="string">&quot;d:\\Codefield\\*.*&quot;</span>;</span><br><span class="line">WIN32_FIND_DATA findData;</span><br><span class="line">HANDLE hFindFile;</span><br><span class="line"></span><br><span class="line">hFindFile = ::<span class="built_in">FindFirstFile</span>(szFileName, &amp;findData);</span><br><span class="line"><span class="keyword">if</span> (hFindFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (findData.cFileName[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) <span class="comment">//不打印.和..</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (findData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) <span class="comment">//是目录就打印</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, findData.cFileName);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (::<span class="built_in">FindNextFile</span>(hFindFile, &amp;findData));</span><br><span class="line">::<span class="built_in">FindClose</span>(hFindFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211115201443315.png" alt="image-20211115201443315"></p><p>我电脑D盘下的Codefield目录</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211115201708380.png" alt="image-20211115201708380"></p><details class="folding-tag" ><summary> 如果去掉continue那个if </summary>              <div class='content'>              <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;afxwin.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char szFileName[] = &quot;d:\\Codefield\\*.*&quot;;</span><br><span class="line">WIN32_FIND_DATA findData;</span><br><span class="line">HANDLE hFindFile;</span><br><span class="line"></span><br><span class="line">hFindFile = ::FindFirstFile(szFileName, &amp;findData);</span><br><span class="line">if (hFindFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line"><span class="deletion">-if (findData.cFileName[0] == &#x27;.&#x27;) //不打印.和..</span></span><br><span class="line"><span class="deletion">-&#123;</span></span><br><span class="line"><span class="deletion">-continue;</span></span><br><span class="line"><span class="deletion">-&#125;</span></span><br><span class="line">if (findData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) //是目录就打印</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s \n&quot;, findData.cFileName);</span><br><span class="line">&#125;</span><br><span class="line">&#125; while (::FindNextFile(hFindFile, &amp;findData));</span><br><span class="line">::FindClose(hFindFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p>多了.和…</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211115201535980.png" alt="image-20211115201535980"></p>              </div>            </details>              </div>            </details><hr><p>多线程实践案例：（多线程文件查找器）</p><p>文件搜索器要在指定的目录及所有子层目录中查找文件，然后向用户显示出查找的结果。如果使用多线程的话，就意味着各线程要同时在不同目录中搜索文件。</p><p>这个程序最关键的地方是定义了一个动态的目录列表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CTypedSimpleList&lt;CDirectoryNode*&gt; m_listDir;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CDirectoryNode</span> :</span> <span class="keyword">public</span> CNoTrackObject</span><br><span class="line">&#123;</span><br><span class="line">    CDirectoryNode* pNext; <span class="comment">// CTypedSimpleList类模板要用此成员</span></span><br><span class="line">    <span class="keyword">char</span> szDir[MAX_PATH];  <span class="comment">// 要查找的目录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在线程执行查找文件任务的时候，</p><p>如果找到的是目录就将它添加到列表中</p><p>若找到的是文件，就用自定义CheckFile函数进行比较，判断是否符合查找条件，若符合就打印出来，显示给用户。</p><p>线程在查找完一个目录以后，再从m_listDir列表中取出一个新的目录进行查找，同时将该目录对应的结点从表中删除。</p><p>当m_listDir为空时，线程进入暂停状态，等待其他线程向m_listDir中添加新的目录。</p><details class="folding-tag" ><summary> 代码实现及运行结果 </summary>              <div class='content'>              <div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">FileFind.cpp</button></li><li class="tab"><button type="button" data-href="#test4-2">RapidFind.h</button></li><li class="tab"><button type="button" data-href="#test4-3">RapidFind.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;RapidFind.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">UINT <span class="title">FinderEntry</span><span class="params">(LPVOID lpParam)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CRapidFinder* pFinder = <span class="keyword">new</span> <span class="built_in">CRapidFinder</span>(<span class="number">64</span>);<span class="comment">//开64个线程</span></span><br><span class="line">CDirectoryNode* pNode = <span class="keyword">new</span> CDirectoryNode;<span class="comment">//创建结点</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//测试的数据，查询D盘下所有含有stdafx字符串的文件 </span></span><br><span class="line"><span class="keyword">char</span> szPath[] = <span class="string">&quot;D:\\&quot;</span>;<span class="comment">//需要查找的目录</span></span><br><span class="line"><span class="keyword">char</span> szFile[] = <span class="string">&quot;stdafx&quot;</span>;<span class="comment">//需要查找的字符串</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//对CRapider的信息进行设置</span></span><br><span class="line"><span class="built_in">strcpy</span>(pNode-&gt;szDir, szPath);<span class="comment">//设置要搜索的目录</span></span><br><span class="line">pFinder-&gt;m_listDir.<span class="built_in">AddHead</span>(pNode);<span class="comment">//将要搜索的目录添加到list中，当做头结点</span></span><br><span class="line"><span class="built_in">strcpy</span>(pFinder-&gt;m_szMatchName, szFile);<span class="comment">//需要搜素的文件名</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建辅助线程</span></span><br><span class="line">pFinder-&gt;m_nThreadCount = pFinder-&gt;m_nMaxThread;</span><br><span class="line"><span class="comment">//创建辅助线程，并等待查找结束</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pFinder-&gt;m_nMaxThread; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AfxBeginThread</span>(FinderEntry, pFinder);</span><br><span class="line">&#125;</span><br><span class="line">::<span class="built_in">WaitForSingleObject</span>(pFinder-&gt;m_hExitEvent, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印查找结果</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;一共找到了同名文件%d\n&quot;</span>, pFinder-&gt;m_nResultCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pFinder;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UINT <span class="title">FinderEntry</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CRapidFinder* pFinder = (CRapidFinder*)lpParam;</span><br><span class="line">CDirectoryNode* pNode = <span class="literal">NULL</span>;<span class="comment">//m_listDir从pNode中获取</span></span><br><span class="line">BOOL bActive = TRUE;<span class="comment">//当前线程工作状态（既然进入了线程回调函数，肯定是TRUE）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只要m_listDir有目录</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//取出待查的新目录</span></span><br><span class="line"><span class="comment">//这个动作各线程之间要互斥完成，临界区代码前后控制一下</span></span><br><span class="line">::<span class="built_in">EnterCriticalSection</span>(&amp;pFinder-&gt;m_cs);</span><br><span class="line"><span class="keyword">if</span> (pFinder-&gt;m_listDir.<span class="built_in">IsEmpty</span>())<span class="comment">//是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">bActive = FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//不为空，取出目录</span></span><br><span class="line">&#123;</span><br><span class="line">pNode = pFinder-&gt;m_listDir.<span class="built_in">GetHead</span>();</span><br><span class="line">pFinder-&gt;m_listDir.<span class="built_in">Remove</span>(pNode);</span><br><span class="line">&#125;</span><br><span class="line">::<span class="built_in">LeaveCriticalSection</span>(&amp;pFinder-&gt;m_cs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//bActive指示了当前线程的工作状态</span></span><br><span class="line"><span class="comment">//如果m_listDir队列当前为空，那么我们当前线程先等待。</span></span><br><span class="line"><span class="comment">//eg.9个线程停止了，1个线程还在工作，但9个线程不能释放掉，因为剩下的1个工作线程如果发现新的目录，要分配9个线程过来帮忙</span></span><br><span class="line"><span class="keyword">if</span> (!bActive)</span><br><span class="line">&#123;</span><br><span class="line">::<span class="built_in">EnterCriticalSection</span>(&amp;pFinder-&gt;m_cs);</span><br><span class="line">pFinder-&gt;m_nThreadCount--;<span class="comment">//前后通过临界区锁控制了这条语句的唯一性，防止线程之间切换带来的不可预料</span></span><br><span class="line"><span class="keyword">if</span> (pFinder-&gt;m_nThreadCount == <span class="number">0</span>)<span class="comment">//没有线程在工作，都在等待中。那么离开临界区</span></span><br><span class="line">&#123;</span><br><span class="line">::<span class="built_in">LeaveCriticalSection</span>(&amp;pFinder-&gt;m_cs);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">::<span class="built_in">LeaveCriticalSection</span>(&amp;pFinder-&gt;m_cs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入等待状态</span></span><br><span class="line"><span class="built_in">ResetEvent</span>(pFinder-&gt;m_hDirEvent);<span class="comment">//告诉总线程，我在等待，如果有发现新目录可以通知我去干活</span></span><br><span class="line">::<span class="built_in">WaitForSingleObject</span>(pFinder-&gt;m_hDirEvent, INFINITE);</span><br><span class="line"></span><br><span class="line">::<span class="built_in">EnterCriticalSection</span>(&amp;pFinder-&gt;m_cs);</span><br><span class="line"><span class="comment">//此时当前线程再度获得CPU的推进机会</span></span><br><span class="line">pFinder-&gt;m_nThreadCount++;<span class="comment">//当前的活动线程数量+1</span></span><br><span class="line">::<span class="built_in">LeaveCriticalSection</span>(&amp;pFinder-&gt;m_cs);</span><br><span class="line"></span><br><span class="line">bActive = TRUE;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************实现基于pNode的目录查找*******************************/</span></span><br><span class="line">WIN32_FIND_DATA fileData;</span><br><span class="line">HANDLE hFindFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pNode-&gt;szDir[<span class="built_in">strlen</span>(pNode-&gt;szDir) - <span class="number">1</span>] != <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcat</span>(pNode-&gt;szDir, <span class="string">&quot;\\&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcat</span>(pNode-&gt;szDir, <span class="string">&quot;*.*&quot;</span>);</span><br><span class="line"></span><br><span class="line">hFindFile = ::<span class="built_in">FindFirstFile</span>(pNode-&gt;szDir, &amp;fileData);</span><br><span class="line"><span class="keyword">if</span> (hFindFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;<span class="comment">//是目录，添加到m_listDir</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fileData.cFileName[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)<span class="comment">//不打印.和..</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fileData.dwFileAttributes&amp;FILE_ATTRIBUTE_DIRECTORY)<span class="comment">//如果是目录，则添加进m_listDir</span></span><br><span class="line">&#123;</span><br><span class="line">CDirectoryNode* p = <span class="keyword">new</span> CDirectoryNode;</span><br><span class="line"><span class="built_in">strncpy</span>(p-&gt;szDir, pNode-&gt;szDir, <span class="built_in">strlen</span>(pNode-&gt;szDir) - <span class="number">3</span>);</span><br><span class="line"><span class="built_in">strcat</span>(p-&gt;szDir, fileData.cFileName);</span><br><span class="line"></span><br><span class="line">::<span class="built_in">EnterCriticalSection</span>(&amp;pFinder-&gt;m_cs);</span><br><span class="line">pFinder-&gt;m_listDir.<span class="built_in">AddHead</span>(p);</span><br><span class="line">::<span class="built_in">LeaveCriticalSection</span>(&amp;pFinder-&gt;m_cs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个事件对象设置为受信状态</span></span><br><span class="line"><span class="comment">//唤醒一个线程</span></span><br><span class="line"><span class="built_in">SetEvent</span>(pFinder-&gt;m_hDirEvent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//如果是文件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pFinder-&gt;<span class="built_in">CheckFile</span>(fileData.cFileName))<span class="comment">//找到文件名</span></span><br><span class="line">&#123;</span><br><span class="line">::<span class="built_in">EnterCriticalSection</span>(&amp;pFinder-&gt;m_cs);</span><br><span class="line">::<span class="built_in">InterlockedIncrement</span>((<span class="keyword">long</span>*)&amp;pFinder-&gt;m_nResultCount);<span class="comment">//找到的文件的数量+1</span></span><br><span class="line">::<span class="built_in">LeaveCriticalSection</span>(&amp;pFinder-&gt;m_cs);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, fileData.cFileName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (::<span class="built_in">FindNextFile</span>(hFindFile, &amp;fileData));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上，此结点的保存的目录已经全部搜索完毕</span></span><br><span class="line"><span class="keyword">delete</span> pNode;</span><br><span class="line">pNode = <span class="literal">NULL</span>;<span class="comment">//删完设置为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::<span class="built_in">SetEvent</span>(pFinder-&gt;m_hDirEvent);</span><br><span class="line"><span class="comment">//判断当前线程是否是最后一个结束循环的线程</span></span><br><span class="line"><span class="keyword">if</span> (::<span class="built_in">WaitForSingleObject</span>(pFinder-&gt;m_hDirEvent, <span class="number">0</span>) != WAIT_TIMEOUT)<span class="comment">//如果没超时</span></span><br><span class="line">&#123;   <span class="comment">//则通知主线程，最后一个搜索线程已经结束了</span></span><br><span class="line">::<span class="built_in">SetEvent</span>(pFinder-&gt;m_hExitEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int main(void)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//char szFileName[] = &quot;d:\\Codefield\\*.*&quot;;</span></span><br><span class="line"><span class="comment">//WIN32_FIND_DATA findData;</span></span><br><span class="line"><span class="comment">//HANDLE hFindFile;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//hFindFile = ::FindFirstFile(szFileName, &amp;findData);</span></span><br><span class="line"><span class="comment">//if (hFindFile != INVALID_HANDLE_VALUE)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//do &#123;</span></span><br><span class="line"><span class="comment">////if (findData.cFileName[0] == &#x27;.&#x27;)</span></span><br><span class="line"><span class="comment">////&#123;</span></span><br><span class="line"><span class="comment">////continue;</span></span><br><span class="line"><span class="comment">////&#125;</span></span><br><span class="line"><span class="comment">//if (findData.dwFileAttributes&amp;FILE_ATTRIBUTE_DIRECTORY)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;%s \n&quot;, findData.cFileName);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125; while (::FindNextFile(hFindFile, &amp;findData));</span></span><br><span class="line"><span class="comment">//::FindClose(hFindFile);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CDirectoryNode</span> :</span><span class="keyword">public</span> CNoTrackObject &#123;<span class="comment">//文件夹目录结构体</span></span><br><span class="line">CDirectoryNode* pNext;<span class="comment">//链表的指针域</span></span><br><span class="line"><span class="keyword">char</span> szDir[MAX_PATH];<span class="comment">//文件夹名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRapidFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CRapidFinder</span>(<span class="keyword">int</span> nMaxThread);<span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">CRapidFinder</span>();<span class="comment">//虚析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CheckFile</span><span class="params">(LPCTSTR lpszFileName)</span></span>;<span class="comment">//判断是否是要查找的文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_nResultCount;<span class="comment">//结果的数量</span></span><br><span class="line"><span class="keyword">int</span> m_nThreadCount;<span class="comment">//活动线程的数量</span></span><br><span class="line"></span><br><span class="line">CTypedSimpleList&lt;CDirectoryNode*&gt; m_listDir;<span class="comment">//文件夹列表</span></span><br><span class="line"></span><br><span class="line">CRITICAL_SECTION m_cs;<span class="comment">//临界区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_nMaxThread;<span class="comment">//最大线程数量</span></span><br><span class="line"><span class="keyword">char</span> m_szMatchName[MAX_PATH];<span class="comment">//要搜索的文件</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//通知线程的工作状态</span></span><br><span class="line">HANDLE m_hDirEvent;<span class="comment">//我们向m_listDir添加新的目录，授信  10个线程，9个停止，1个工作 若m_listDir为空，线程不能停止</span></span><br><span class="line">HANDLE m_hExitEvent;<span class="comment">//各个搜索线程是否已经结束</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;RapidFind.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化我们的m_nMaxThread</span></span><br><span class="line">CRapidFinder::<span class="built_in">CRapidFinder</span>(<span class="keyword">int</span> nMaxThread) :<span class="built_in">m_nMaxThread</span>(nMaxThread)</span><br><span class="line">&#123;</span><br><span class="line">m_nResultCount = <span class="number">0</span>;<span class="comment">//构造函数初始化为0，一开始肯定找到0个</span></span><br><span class="line">m_nThreadCount = <span class="number">0</span>;<span class="comment">//同上，活动线程数量为0</span></span><br><span class="line">m_szMatchName[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">m_listDir.<span class="built_in">Construct</span>(<span class="built_in">offsetof</span>(CDirectoryNode, pNext));<span class="comment">//调用CTypedSimpleList的构造方法</span></span><br><span class="line">m_hDirEvent = ::<span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);<span class="comment">//创建事件对象</span></span><br><span class="line">m_hExitEvent = ::<span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);<span class="comment">//创建事件对象</span></span><br><span class="line">::<span class="built_in">InitializeCriticalSection</span>(&amp;m_cs);<span class="comment">//初始化临界区对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CRapidFinder::~<span class="built_in">CRapidFinder</span>()</span><br><span class="line">&#123;</span><br><span class="line">::<span class="built_in">CloseHandle</span>(m_hDirEvent);<span class="comment">//关闭句柄</span></span><br><span class="line">::<span class="built_in">CloseHandle</span>(m_hExitEvent);<span class="comment">//关闭句柄</span></span><br><span class="line">::<span class="built_in">DeleteCriticalSection</span>(&amp;m_cs);<span class="comment">//删除临界区对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过比对文件名的方式检查搜到的文件是不是要搜索的文件，这里不采用md5检验和的方式</span></span><br><span class="line"><span class="function">BOOL <span class="title">CRapidFinder::CheckFile</span><span class="params">(LPCTSTR lpszFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> string[MAX_PATH];</span><br><span class="line"><span class="keyword">char</span> strSearch[MAX_PATH];</span><br><span class="line"><span class="built_in">strcpy</span>(string, lpszFileName);<span class="comment">//把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间</span></span><br><span class="line"><span class="built_in">strcpy</span>(strSearch, m_szMatchName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串全部转换为大写</span></span><br><span class="line">_strupr(string);</span><br><span class="line">_strupr(strSearch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//strstr返回字符串中首次出现子串的地址</span></span><br><span class="line"><span class="comment">//比如有a.txt文件，用户可能输入搜索a，它不输入后缀名</span></span><br><span class="line"><span class="comment">//这里我们用包含关系</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(string, strSearch) != <span class="literal">NULL</span>)<span class="comment">//查找的文件名在里面</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;<span class="comment">//默认不相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>运行结果：</p><p>（程序中搜的是D盘下stdafx文件（预编译的头文件））</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211116171849882.png" alt="image-20211116171849882"></p><details class="folding-tag" ><summary> 消息循环的Crash bug </summary>              <div class='content'>              <p><code>FileFind.cpp</code>文件中76~78行</p><p>如果是写INFINITY，在运行时，快输出总共找到同名文件多少时，会有中断异常</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//进入等待状态</span><br><span class="line">ResetEvent(pFinder-&gt;m_hDirEvent);//告诉总线程，我在等待，如果有发现新目录可以通知我去干活</span><br><span class="line"><span class="deletion">-::WaitForSingleObject(pFinder-&gt;m_hDirEvent, INFINITE);</span></span><br><span class="line"><span class="addition">+::WaitForSingleObject(pFinder-&gt;m_hDirEvent, INFINITY);</span></span><br></pre></td></tr></table></figure><p>在win32线程中INFINITE和INFINch差别不明显。但是在MFC中使用INFINITY会一直等待下去，导致工作者线程就不会进入消息循环，导致总线程crash掉</p>              </div>            </details>              </div>            </details><h3 id="MFC多线程技术（线程间通信）">MFC多线程技术（线程间通信）</h3><p>一般而言，应用程序中的一个次要线程总是为主线程执行特定的任务，这样，主线程和次要线程间必定有一个信息传递的渠道，也就是主线程和次要线程间要进行通信。这种线程间的通信不但是难以避免的，而且在多线程编程中也是复杂和频繁的，下面对通信方式进行简要说明：</p><p>使用全局变量进行通信</p><ul><li>如果线程间所需传递的信息较复杂，我们可以定义一个结构，通过传递指向该结构的指针进行传递消息。</li></ul><p>使用自定义消息</p><ul><li>我们可以在一个线程的执行函数中向另一个线程发送自定义的消息来达到通信的目的。一个线程向另外一个线程发送消息是通过操作系统实现的。利用Windows操作系统的消息驱动机制，当一个线程发出一条消息时，操作系统首先接收到该消息，然后把该消息转发给目标线程，接收消息的线程必须已经建立了消息循环。</li></ul><hr><p>案例：编写一个应用程序，在主窗口按下鼠标左键的时候，会启动一个用户UI线程；当用户在线程窗口界面按下鼠标左键的时候，会弹出一个信息框。</p><details class="folding-tag" ><summary> 实现 </summary>              <div class='content'>              <blockquote><p>创建MFC应用程序项目08MFCUIDEMO；基于对话框，去SDL检查；去系统菜单；高级功能全去</p></blockquote><p>在<code>资源文件</code>添加一个Dialog资源，添加<code>Static Text</code>控件，<code>Caption</code>修改为线程窗口</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211116205221391.png" alt="image-20211116205221391"></p><p>对该对话框右键<code>添加类</code>，类名为<code>CThreadWnd</code>；</p><p>VS2015会自动生成<code>ThreadWnd.h</code>、<code>ThreaddWnd.cpp</code>文件</p><details class="folding-tag" ><summary> 用窗口的方式实现 </summary>              <div class='content'>              <p>在主对话框中，右键<code>类向导</code>，<code>消息</code>中添加<code>WM_LBUTTONDOWM</code>消息的处理</p><p>程序；</p><p>在<code>08MFCUIDEMODlg.cpp</code>文件中<code>#include &quot;ThreadWnd.h&quot;</code></p><p>并编辑上述添加的处理程序代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy08MFCUIDEMODlg::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="comment">//AfxMessageBox(TEXT(&quot;Hello&quot;));用弹窗检验一下</span></span><br><span class="line"></span><br><span class="line">CThreadWnd *pDlg = <span class="keyword">new</span> <span class="built_in">CThreadWnd</span>();</span><br><span class="line">pDlg-&gt;<span class="built_in">DoModal</span>();</span><br><span class="line"></span><br><span class="line">CDialogEx::<span class="built_in">OnLButtonDown</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p>在主窗口点击左键会弹出对话框，不把次对话框关闭，主界面就不响应鼠标的左键点击</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211117155702315.png" alt="image-20211117155702315"></p>              </div>            </details><details class="folding-tag" ><summary> 用UI线程的方法弹出窗口 </summary>              <div class='content'>              <p>次窗口的对话框中<kbd>类向导</kbd>，<kbd>添加类</kbd></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211117100859457.png" alt="image-20211117100859457"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211117101015010.png" alt="image-20211117101015010"></p><p><code>类名</code>输为<code>CMyThread</code>，<code>基类</code>输为<code>CWndThread</code>；VS2015会自动生成<code>CMyThread.h</code>和<code>MyThread.cpp</code>文件</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211117112200808.png" alt="image-20211117112200808"></p><p>在<kbd>虚函数</kbd>中选中<code>InitInstance</code>、<code>ExitInstance</code>，<kbd>添加函数</kbd></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211117112343950.png" alt="image-20211117112343950"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211117112541941.png" alt="image-20211117112541941"></p><p>在VS2015生成的<code>MyThread.cpp</code>文件前<code>#include &quot;ThreadWnd.h&quot;</code>，同时编写函数体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMyThread::InitInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line"></span><br><span class="line">CThreadWnd *pDlg = <span class="keyword">new</span> <span class="built_in">CThreadWnd</span>();</span><br><span class="line">pDlg-&gt;<span class="built_in">DoModal</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CWinThread::<span class="built_in">InitInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>08MFCUIDEMODlg.cpp</code>文件前<code>#include &quot;MyThread.h&quot;</code>,同时编写函数体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy08MFCUIDEMODlg::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="comment">//AfxMessageBox(TEXT(&quot;Hello&quot;));用弹窗检验一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CThreadWnd *pDlg = new CThreadWnd();</span></span><br><span class="line"><span class="comment">//pDlg-&gt;DoModal();</span></span><br><span class="line"></span><br><span class="line">CMyThread* pThread = <span class="keyword">new</span> <span class="built_in">CMyThread</span>();</span><br><span class="line">pThread-&gt;<span class="built_in">CreateThread</span>();<span class="comment">//CWinThread类的方法</span></span><br><span class="line"></span><br><span class="line">CDialogEx::<span class="built_in">OnLButtonDown</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p>在主窗口点击左键会弹出对话框，不把次对话框关闭，主界面也不响应鼠标的左键点击</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211117160345128.png" alt="image-20211117160345128"></p>              </div>            </details>              </div>            </details><p>DoModal阻塞的是窗体消息</p><p>MFC之所以会分成所谓的UI线程和工作者线程和核心区别在于二者是否加入窗体消息循环</p><details class="folding-tag" ><summary> 关于UI线程和工作者线程更多的资料 </summary>              <div class='content'>              <p><a href="https://blog.csdn.net/libaineu2004/article/details/40398405">UI线程和工作者线程</a></p>              </div>            </details><h3 id="自定义消息通信机制综合案例：日志切割器">自定义消息通信机制综合案例：日志切割器</h3><p>MFC中多线程技术分为UI线程和工作者线程。核心思想是希望我们把耗时长的操作（比如文件读写）放到工作者线程中，这些操作在执行过程中不会占用消息循环。如果放到UI线程，占用消息循环，会造成主界面假死用户交互体验差。</p><p>这是逻辑上的一个划分，那么UI线程与工作者线程之间不可避免需要通信。</p><p>本节用日志切割器的案例来学习与体会线程间通信和同步问题。</p><hr><p>读写文件是编程过程中一个很重要的环节。为了消除长时间的读写操作对线程造成的阻塞，一般都要在辅助线程中读写文件。这就涉及到线程间通信和线程同步的问题。</p><p>本节将通过实现一个日志切割系统来说明如何将线程封装到类中，提供线程安全的接口，最终将以一个CFileCutter类的形式提供给用户使用。</p><p><strong>现实意义</strong>：早期windows的服务器，每当有外来用户进行访问，log日志便会记录，log日志会不断增长，用记事本打开这样大的日志会非常缓慢。因此，我们对该日志进行切割，变成小文件，方便访问。</p><p><strong>分析</strong>：这种读写文件的操作肯定放到工作者线程，如果放到界面会卡死，用户体验差。</p><p><strong>设计</strong>：</p><p>线程间通信的方法很多，如果是工作线程有事情要通知主窗口线程，最好的方法就是发送消息。除了要向主窗口发送基本的“开始工作”和“结束工作”通知消息外，还应该把当前的工作进度告诉主窗口，以便显示给用户。</p><p>为此，CFileCutter类定义了以下3个消息：</p><p>CFileCutter类发给主窗口的通知消息//FileCutter.h文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_CUTTERSTART WM_USER + 100  <span class="comment">//wParm==nTatolCount</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_CUTTERSTOP WM_USER + 101  <span class="comment">//wParam==nExiteCode,lParm==nCompletedCount</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_CUTTERSTATUS WM_USER + 102 <span class="comment">//lParam==nCompletedCount</span></span></span><br></pre></td></tr></table></figure><hr><p>我们想增加一个用户自定义消息WM_USER_THREADEND的步骤是：</p><ol><li><p>在头文件<code>stdafx.h</code>中增加一个自定义消息宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_USER_THREADEND WM_USER + 1</span></span><br></pre></td></tr></table></figure></li><li><p>在增加新消息的窗口或对话框类的头文件中增加一个回调函数声明，注意要声明为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span></span></span><br><span class="line"><span class="function">afx_msg LRESULT <span class="title">OnUserThreadend</span><span class="params">(WPARAM wParam, LPARAM lParam)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在窗口或对话框的cpp文件的<code>BEGIN_MESSAGE_MAP</code>，<code>END_MESSAGE_MAP</code>中增加一行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ON_MESSAGE</span>(WM_USER_THREADEND, OnUserThreadend)</span><br></pre></td></tr></table></figure></li><li><p>在窗口或对话框的cpp文件中增加回调函数的实现，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">ThreadDialog::OnUserThreadend</span><span class="params">(WPARAM wParam, LPARAM lParam)</span></span></span><br></pre></td></tr></table></figure></li><li><p>自定义消息的触发</p></li></ol><hr><p>刚开始进行分割时，工作线程向主窗口发送<code>WM_CUTTERSTART</code>消息，<code>wParam</code>参数的值域为分割以后的文件数量。主窗口接收到这个消息后可以设置进度条的取值范围，提示用户正在工作等。</p><p>工作线程在分割文件的过程中，每处理完一个文件就向主窗口发送一个<code>WM_CUTTERSTATUS</code>消息，<code>lParam</code>参数的值为已经完成的文件的总数量。主窗口接收到这个消息后可以更新进度条的位置，向用户显示状态信息等。</p><p>停止工作以后，工作线程向主窗口发送<code>WM_CUTTERSTOP</code>消息，<code>lParam</code>参数的值还是已经完成的文件的总数量，其<code>wParam</code>参数的值为工作退出代码，说明了工作退出的原因。</p><hr><p>实现：</p><blockquote><p>创建Win32项目09MFCLogCutter；勾空项目；直接点完成</p><p>项目右键-在共享DLL中使用MFC</p></blockquote><details class="folding-tag" ><summary> 资源布局 </summary>              <div class='content'>              <p>把已经做好的<code>resource.h</code>和<code>FileCutter.rc</code>文件复制到这个项目下</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211117184844960.png" alt="image-20211117184844960"></p><p><kbd>头文件</kbd>右键<kbd>添加</kbd>-&gt;<kbd>现有项</kbd>添加<code>resource.h</code></p><p><kbd>资源文件</kbd>右键<kbd>添加</kbd>-&gt;<kbd>新建项</kbd>添加<code>FileCutter.rc</code></p><p>瞅瞅资源文件</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211117195137905.png" alt="image-20211117195137905"></p>              </div>            </details><details class="folding-tag" ><summary> 代码基本框架 </summary>              <div class='content'>              <p>这里不用App Wizard，手工添加</p><p><kbd>头文件</kbd>右键<kbd>添加</kbd>-&gt;<kbd>现有项</kbd>添加<code>Cutter.h</code></p><p>编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxcmn.h&gt;</span><span class="comment">//通用控件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyApp</span> :</span><span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMainDialog</span> :</span><span class="keyword">public</span> CDialog &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CMainDialog</span>(CWnd* pParentWnd = <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">//进度条</span></span><br><span class="line">CProgressCtrl m_Progress;</span><br><span class="line"><span class="comment">//辅助类：CFileCutter--To Do--</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于我们需要实时更新工作者线程和主线程</span></span><br><span class="line"><span class="comment">//动态的控制程序界面的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UIControl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相应windows消息的一系列函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">OnInitDialog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCancel</span><span class="params">()</span></span>;<span class="comment">//退出</span></span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnSourceBrowser</span><span class="params">()</span></span>;<span class="comment">//选择源文件的按钮响应函数</span></span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnDestBrowser</span><span class="params">()</span></span>;<span class="comment">//选择目的文件夹的按钮响应函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnStart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnStop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnSelect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义消息，需要辅助类，这里先注释没做</span></span><br><span class="line"><span class="comment">//afx_msg long OnCutterStart(WPARAM wParam, LPARAM lParam);</span></span><br><span class="line"><span class="comment">//afx_msg long OnCutterStatus(WPARAM wParam, LPARAM lParam);</span></span><br><span class="line"><span class="comment">//afx_msg long OnCutterStop(WPARAM wParam, LPARAM lParam);</span></span><br><span class="line"><span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><kbd>源文件</kbd>右键<kbd>添加</kbd>-&gt;<kbd>新建项</kbd>添加<code>Cutter.cpp</code></p><p>编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Cutter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">CMyApp theApp;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CMyApp::InitInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMainDialog dlg;</span><br><span class="line">m_pMainWnd = &amp;dlg;</span><br><span class="line">dlg.<span class="built_in">DoModal</span>();</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMainDialog::<span class="built_in">CMainDialog</span>(CWnd* pParentWnd) :<span class="built_in">CDialog</span>(IDD_FILECUTTER_DIALOG, pParentWnd)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMainDialog,CDialog)</span><br><span class="line"><span class="built_in">ON_BN_CLICKED</span>(IDC_SOURCEBROWSER,OnSourceBrowser)</span><br><span class="line"><span class="built_in">ON_BN_CLICKED</span>(IDC_DESTBROWSER,OnDestBrowser)</span><br><span class="line"><span class="built_in">ON_BN_CLICKED</span>(IDC_START,OnStart)</span><br><span class="line"><span class="built_in">ON_BN_CLICKED</span>(IDC_STOP,OnStart)</span><br><span class="line"><span class="built_in">ON_BN_CLICKED</span>(IDC_SELECTSPLIT,OnSelect)</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义消息：WM_CUTTERSTART：是在我们线程的辅助类里面的，这里先注释后面再实现</span></span><br><span class="line"><span class="comment">//ON_MESSAGE(WM_CUTTERSTART,OnCutterStart)</span></span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CMainDialog::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialog::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMainDialog::UIControl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMainDialog::OnCancel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMainDialog::OnSelect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMainDialog::OnSourceBrowser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMainDialog::OnDestBrowser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMainDialog::OnStart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMainDialog::OnStop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/MFC/image-20211117194207831.png" alt="image-20211117194207831"></p>              </div>            </details><p>核心代码：</p><kbd>头文件</kbd>右键<kbd>添加</kbd>-><kbd>新建项</kbd>添加`FileCutter.h`<p>编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义自定义消息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_CUTTERSTART WM_USER+100<span class="comment">//wParam封装的时nTotal</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_CUTTERSTOP WM_USER+101<span class="comment">//wParam=nExitCode,lParam=nCompleteCount</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_CUTTERSTATUS WM_USER+102<span class="comment">//lParam=完成的数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFileCutter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//工作码</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ExitCode</span> &#123;</span></span><br><span class="line">exitSuccess,<span class="comment">//成功退出</span></span><br><span class="line">exitUserForce,<span class="comment">//用户强制退出</span></span><br><span class="line">exitSourceErr,<span class="comment">//文件有错误，工作时文件突然没了</span></span><br><span class="line">exitDestErr</span><br><span class="line">&#125;;<span class="comment">//我们永远不能轻信多线程的推进是可靠的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">CFileCutter</span>(HWND hWndNotify);<span class="comment">//要传句柄，因为工作者线程要和窗体通信</span></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">CFileCutter</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">IsRunning</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_bRunning; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">StartSplit</span><span class="params">(LPCTSTR lpszDDwstDir, LPCTSTR lpszSourceFile, UINT uFileSize)</span></span>;<span class="comment">//开始切割</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SuspendCutter</span><span class="params">()</span></span>;<span class="comment">//暂停切割</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">ResumeCutter</span><span class="params">()</span></span>;<span class="comment">//继续切割</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StopCutter</span><span class="params">()</span></span>;<span class="comment">//停止切割</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">//设置状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSplit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UINT <span class="keyword">friend</span> _CutterEntry(LPVOID lpParam);<span class="comment">//线程会侵入别的模块，这里我们用友元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数信息</span></span><br><span class="line">CString m_strSource;<span class="comment">//源文件</span></span><br><span class="line">CString m_strDest;<span class="comment">//目标文件夹</span></span><br><span class="line">UINT m_uFileSize;<span class="comment">//文件单元大小</span></span><br><span class="line">BOOL m_bSplit;<span class="comment">//切割情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//状态标志</span></span><br><span class="line">BOOL m_bContinue;</span><br><span class="line">BOOL m_bRunning;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步</span></span><br><span class="line">CRITICAL_SECTION m_cs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HWND m_hWndNotify;<span class="comment">//接收UI线程和当前工作线程的窗口句柄</span></span><br><span class="line">HANDLE m_hWorkEvent;<span class="comment">//通知开始工作线程的事件对象</span></span><br><span class="line">CWinThread* m_pThread;<span class="comment">//工作线程</span></span><br><span class="line">BOOL m_bSuspend;<span class="comment">//是否暂停</span></span><br><span class="line">BOOL m_bExitThread;<span class="comment">//是否退出</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><kbd>源文件</kbd>右键<kbd>添加</kbd>-><kbd>新建项</kbd>添加`FileCutter.cpp`<p>编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>用临界区确保唯一性</p><h2 id="原理篇二-MFC核心框架完全实现">原理篇二-MFC核心框架完全实现</h2><h2 id="工程篇-MFC通用技术">工程篇-MFC通用技术</h2><h2 id="综合案例-拼图游戏">综合案例-拼图游戏</h2><h2 id="MFC案例-视频图像摄像头">MFC案例-视频图像摄像头</h2>]]></content>
      
      
      <categories>
          
          <category> Windows安全 </category>
          
          <category> 编程篇 </category>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE格式</title>
      <link href="/posts/5bf78d14.html"/>
      <url>/posts/5bf78d14.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1>what</h1><details class="folding-tag" ><summary> 参考 </summary>              <div class='content'>              <p>《加密与解密4th》P404~405</p>              </div>            </details><p>&gt; Portable Executable File Format(可移植的执行体)。</p><ul><li>目前Windows平台上主流的的可执行文件格式。</li><li>PE早期衍生于COFF格式，意在被设计为一种通用于所有Windows平台和CPU（x86、MIPS、Alpha等）的文件格式</li><li>头文件<code>winnt.h</code>中描述了PE及COFF格式相关的数据结构定义、枚举类型、常量定义。（有关PE的编程会用到该头文件）</li><li>64位的windows下新格式叫PE32+，无新结构，只是32位字段被扩展成64位。</li></ul><p><strong>&gt; PE文件框架结构：</strong></p><p>​概念：Section（区块、区段、节等）</p><p><strong>&gt; 组成部分：</strong></p><ul><li>DOS头部</li><li>PE头</li><li>区块</li></ul><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE格式/image-20211024210243106.png" alt="image-20211024210243106" style="zoom: 50%;" /><details class="folding-tag" ><summary> 一览图 </summary>              <div class='content'>              <div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">常用</button></li><li class="tab"><button type="button" data-href="#test1-2">横版</button></li><li class="tab"><button type="button" data-href="#test1-3">长括号（不常用）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE%E6%A0%BC%E5%BC%8F/image-20211024211522957.png" alt="image-20211024211522957"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE%E6%A0%BC%E5%BC%8F/image-20211024211746328.png" alt="image-20211024211746328"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE%E6%A0%BC%E5%BC%8F/image-20211024211620335.png" alt="image-20211024211620335"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details><h1>计算</h1><details class="folding-tag" ><summary> 参考 </summary>              <div class='content'>              <p>《加密与解密4th》P</p><p>《0day软件漏洞分析》</p>              </div>            </details><h2 id="基本概念-2">基本概念</h2><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703205118380.png" alt="image-20210703205118380" style="zoom: 50%;" /><p>&gt; PE在磁盘上，是文件形式存放</p><ul><li>文件偏移地址（File Offset）/物理地址（RAW Offset）：某个数据相对于文件头的偏移量，文件头起始值为0</li></ul><p>&gt; 双击运行PE后，由Windows加载器（PE加载器）映射到虚拟内存中：</p><ul><li>映像基址/基地址（ImageBase）：PE在内存映像中的起始地址</li><li>虚拟地址（VA，Virtual Address)：在虚拟空间中的绝对地址</li><li>相对虚拟地址（RVA，Relative Virtual Address）：相对于基地址的偏移量</li></ul><details class="folding-tag" ><summary> 题外话-何为虚拟内存 </summary>              <div class='content'>              <img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703225854916.png" alt="image-20210703225854916" style="zoom: 50%;" />              </div>            </details><h2 id="RVA、VA、ImageBase">RVA、VA、ImageBase</h2><p>三者知二可得剩余</p><ul><li><p>VA=基址+RVA</p><details class="folding-tag" ><summary> 例子 </summary>              <div class='content'>              <p>某个EXE文件从400000h处载入，它的代码区始于401000h</p><p>则代码区块的RVA为：目标地址401000h-载入地址400000h=RVA1000h</p>              </div>            </details></li></ul><h2 id="文件偏移地址">文件偏移地址</h2><blockquote><p>先停一下，后期需要再整理</p><p>mark：<a href="https://www.kanxue.com/chm.htm?id=567&amp;pid=node1000148">PE文件格式学习小结 之 文件偏移地址计算器功能的实现</a></p></blockquote><p>PE在磁盘与在映射的内存中，区块的对齐值（间隙）可以一致，也可以不一致。</p><p>一致：同一数据在磁盘文件中的偏移与在内存中的偏移<u>相同</u>，不需要转换。</p><p>不一致：同一数据在磁盘文件中的偏移与在内存中的偏移<u>不相同</u>，<u>需要</u>转换。</p><ul><li>在磁盘中，为了节约文件大小（也就节约了磁盘空间），区块间一个典型对齐值为200H</li><li>映射到内存中，x86以分页管理对内存单元进行寻址，每页4k（十进制数4096=1000H）为单位寻址更高效，一个典型的对齐值为1000H</li><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703230636614.png" alt="image-20210703230636614" style="zoom: 67%;" /></li></ul><h3 id="节偏移">节偏移</h3><details class="folding-tag" ><summary> 另外的方法：引入节偏移算文件偏移地址 </summary>              <div class='content'>              <p>磁盘与内存的“区块间隙”不一致，我们在计算文件偏移时，引入一个概念<strong>节偏移</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">\Delta k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">Δ</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>去消除两者不一致的差异</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE格式/image-20211025111938667.png" alt="image-20211025111938667" style="zoom: 50%;" /><p>文件被映射到内存中，MS-DOS头部、PE文件头和块表的偏移位置和大小都没有改变，而各区块的偏移位置发生了变化（具体为<u>.text块与块表之间</u>的间隙，.text块往高端地址后，<u>相邻区块之间的间隙</u>）。</p><p>以.text区块为例：</p><ul><li>在磁盘文件中，.text区块起始端与文件头的偏移量为add1（File Offset）</li><li>映射到内存后，.text块起始段与文件头（基地址）的偏移量为add2（RVA）</li></ul><p>内存映像中，.text块与块表之间的一大段空隙（以0填充的数据）就是我们要消除的差异。</p><p>我们用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">\Delta k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">Δ</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>表示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">Δ</mi><mi>k</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>R</mi><mi>V</mi><mi>A</mi><mo>−</mo><mi>F</mi><mi>i</mi><mi>l</mi><mi>e</mi><mtext> </mtext><mi>O</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mi>A</mi><mo>−</mo><mi>I</mi><mi>m</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>B</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo stretchy="false">)</mo><mo>−</mo><mi>F</mi><mi>i</mi><mi>l</mi><mi>e</mi><mtext> </mtext><mi>O</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi></mrow></mstyle></mtd></mtr></mtable></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}\begin{split}\Delta k&amp;=RVA-File\ Offset\\&amp;=(VA-ImageBase)-File\ Offset\end{split}\end{equation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Δ</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10764em;">ff</span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">ma</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span><span class="mord mathnormal">se</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10764em;">ff</span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></p><p>在同一个区块中，节偏移是一样的（PE映射到内存后，区块内部没变，只是区块之间间隙变了），所以得到某个区块的节偏移后，可对这个区块里的任何数据的File Offset与VA进行转换。</p><p>每个区块的大小不同，所以各个区块之间的填充大小不同。所以要求数据位于哪个区块，然后求出它位于的那个区块的节偏移。</p><hr><p>公式为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>F</mi><mi>i</mi><mi>l</mi><mi>e</mi><mtext> </mtext><mi>O</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mi>A</mi><mo>−</mo><mi>I</mi><mi>m</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>B</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo stretchy="false">)</mo><mo>−</mo><mi mathvariant="normal">Δ</mi><mi>k</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>R</mi><mi>V</mi><mi>A</mi><mo>−</mo><mi mathvariant="normal">Δ</mi><mi>k</mi></mrow></mstyle></mtd></mtr></mtable></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}\begin{split}File\ Offset&amp;=(VA-ImageBase)-\Delta k\\&amp;=RVA-\Delta k\end{split}\end{equation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10764em;">ff</span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">ma</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span><span class="mord mathnormal">se</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">Δ</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">Δ</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></p><p>解释：所求数据的文件偏移地址=（数据的虚拟地址-映像基址）-相应的节偏移</p>              </div>            </details><p>在实际操作过程，我是用<u>区块文件偏移地址</u>+<u>数据相对区块起始的偏移量</u>来计算</p><h3 id="手算">手算</h3><p>&gt; 题目：</p><p>有一个表，或者其他形式可以间接得到各个区块的<u>RVA</u>和<u>文件偏移地址</u></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE%E6%A0%BC%E5%BC%8F/image-20211025143954673.png" alt="image-20211025143954673"></p><p>求虚拟内存地址为VA的数据的文件偏移地址</p><p>&gt; 步骤：</p><ol><li>VA-映像基址，得到要求数据的RVA</li><li>（数据的RVA与各区块起始RVA对比）判断这个数据位于哪个区块，用数据的RVA-区块起始RVA，得<u>目标数据相对于区块起始地址的偏移量</u></li><li>用区块的文件偏移地址+步骤2中的相对偏移量=即为要求的数据的文件偏移地址</li></ol><h3 id="编程算">编程算</h3><p>&gt; 步骤（穷举然后挨个判断处于哪个区块）：</p><ol><li>循环扫描区块表得出各个区块在内存中的<u>起始RVA</u>（根据IMAGE_SECTION_HEADER中的<em>VirtualAddress</em>字段）和区块的大小（根据IMAGE_SECTION_HEADER中的<em>SizeofRawData</em>字段），两者相加得到<u>各个区块的结束RVA</u>，最后判断目标RVA处于哪个区块中</li><li>用目标RVA-它处于区块的起始RVA，得到目标相对于区块起始地址的偏移量RVA2</li><li>在区块表中获取该区块在文件中的偏移地址（根据IMAGE_SECTION_HEADER中的<em>PointerToRawData</em>字段），将这个偏移量+步骤二的RVA2就得到目标的文件偏移地址</li></ol><p>待我长发及腰，啊呸…</p><h1>MS-DOS头部</h1><details class="folding-tag" ><summary> 参考 </summary>              <div class='content'>              <p><a href="https://www.bilibili.com/video/BV1us411P7nL?p=2&amp;spm_id_from=pageDriver">小甲鱼视频【系统篇】《解密系列》PE结构详解2</a></p>              </div>            </details><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mi>S</mi><mo>−</mo><mi>D</mi><mi>O</mi><mi>S</mi><mtext>头部</mtext><mi mathvariant="normal">/</mi><mi>D</mi><mi>O</mi><mi>S</mi><mtext>文件头</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>I</mi><mi>M</mi><mi>A</mi><mi>G</mi><mi>E</mi><mi mathvariant="normal">_</mi><mi>D</mi><mi>O</mi><mi>S</mi><mi mathvariant="normal">_</mi><mi>H</mi><mi>E</mi><mi>A</mi><mi>D</mi><mi>E</mi><mi>R</mi><mi mathvariant="normal">/</mi><mi>D</mi><mi>O</mi><mi>S</mi><mtext> </mtext><mi>M</mi><mi>Z</mi><mtext>头（长度不定）</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>D</mi><mi>O</mi><mi>S</mi><mtext> </mtext><mi>S</mi><mi>T</mi><mi>U</mi><mi>B</mi><mo stretchy="false">(</mo><mtext>长度不定</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">MS-DOS头部/DOS文件头\begin{cases}IMAGE\_DOS\_HEADER/DOS\ MZ头（长度不定）\\DOS\ STUB(长度不定)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">MS</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">OS</span><span class="mord cjk_fallback">头部</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">OS</span><span class="mord cjk_fallback">文件头</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">GE</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">OS</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.00773em;">ER</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">OS</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.07153em;">MZ</span><span class="mord cjk_fallback">头（长度不定）</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">OS</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.13889em;">ST</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord cjk_fallback">长度不定</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h2 id="IMAGE-DOS-HEADER">IMAGE_DOS_HEADER</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DOS_HEADER STRUCT </span><br><span class="line">&#123; </span><br><span class="line">+<span class="number">0</span>h  WORD  e_magic     <span class="comment">// Magic DOS signature                DOS可执行文件标记 </span></span><br><span class="line">+<span class="number">2</span>h  WORD  e_cblp      <span class="comment">// Bytes on last page of file    </span></span><br><span class="line">+<span class="number">4</span>h  WORD  e_cp        <span class="comment">// Pages in file </span></span><br><span class="line">+<span class="number">6</span>h  WORD  e_crlc      <span class="comment">// Relocations </span></span><br><span class="line">+<span class="number">8</span>h  WORD  e_cparhdr   <span class="comment">// Size of header in paragraphs </span></span><br><span class="line">+<span class="number">0</span>ah WORD  e_minalloc  <span class="comment">// Minimun extra paragraphs needs </span></span><br><span class="line">+<span class="number">0</span>ch WORD  e_maxalloc  <span class="comment">// Maximun extra paragraphs needs </span></span><br><span class="line">+<span class="number">0</span>eh WORD  e_ss        <span class="comment">// intial(relative)SS value           DOS代码的初始化堆栈SS </span></span><br><span class="line">+<span class="number">10</span>h WORD  e_sp        <span class="comment">// intial SP value                    DOS代码的初始化堆栈指针SP </span></span><br><span class="line">+<span class="number">12</span>h WORD  e_csum      <span class="comment">// Checksum </span></span><br><span class="line">+<span class="number">14</span>h WORD  e_ip        <span class="comment">// intial IP value                    DOS代码的初始化指令入口[指针IP] </span></span><br><span class="line">+<span class="number">16</span>h WORD  e_cs        <span class="comment">// intial(relative)CS value           DOS代码的初始堆栈入口 </span></span><br><span class="line">+<span class="number">18</span>h WORD  e_lfarlc    <span class="comment">// File Address of relocation table </span></span><br><span class="line">+<span class="number">1</span>ah WORD  e_ovno      <span class="comment">// Overlay number </span></span><br><span class="line">+<span class="number">1</span>ch WORD  e_res[<span class="number">4</span>]    <span class="comment">// Reserved words </span></span><br><span class="line">+<span class="number">24</span>h WORD  e_oemid     <span class="comment">// OEM identifier(for e_oeminfo) </span></span><br><span class="line">+<span class="number">26</span>h WORD  e_oeminfo   <span class="comment">// OEM information;e_oemid specific  </span></span><br><span class="line">+<span class="number">29</span>h WORD  e_res2[<span class="number">10</span>]  <span class="comment">// Reserved words </span></span><br><span class="line">+<span class="number">3</span>ch DWORD e_lfanew    <span class="comment">// Offset to start of PE header       指向PE文件头 </span></span><br><span class="line">&#125;IMAGE_DOS_HEADER_ENDS</span><br></pre></td></tr></table></figure><p>两个字段比较重要：</p><ul><li><p>e_magic：DOS可执行文件的标识符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DOS_SIGNATURE 0x5A4D <span class="comment">//MZ</span></span></span><br></pre></td></tr></table></figure></li><li><p>e_lfanew：该字段固定位于文件开始偏移3Ch字节处，指出PE头的相对偏移（RVA）。</p></li></ul><h1>PE文件头</h1><h1>区块</h1>]]></content>
      
      
      <categories>
          
          <category> Windows安全 </category>
          
          <category> 系统篇 </category>
          
          <category> PE格式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程开发工具</title>
      <link href="/posts/6f49a03d.html"/>
      <url>/posts/6f49a03d.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1>VS code</h1><p>有空在填</p><h1>VS2019</h1><h2 id="创建新项目">创建新项目</h2><p>打开VS2019-&gt;“创建新项目&quot;窗口中选择&quot;空项目”-&gt;设置“位置”和“项目名称”</p><h2 id="各类文件">各类文件</h2><details class="folding-tag" ><summary> 参考 </summary>              <div class='content'>              <p><a href="https://shiyousan.com/post/636441130259624698">探究Visual Studio生成的.vs文件夹内部结构和作用</a></p><p><a href="https://blog.csdn.net/weixin_44229927/article/details/108128059?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai">【Visual Studio】关于*.sln *.vcxproj *.vcxproj.filters *.vcxproj.user的简单理解</a></p><p><a href="https://www.cnblogs.com/westlife-11358/p/9253470.html">sln、sdf、vcxproj、vcxproj.filter各是什么文件</a></p><p><a href="https://blog.csdn.net/beibeix2015/article/details/112275012">visual studio项目 .sln .vcxproj .vcproj 文件的区别和关系</a></p>              </div>            </details><blockquote><p>以一个空项目TestDirectory为例</p></blockquote><p>创建后文件目录结构：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/image-20211022110254601.png" alt="image-20211022110254601"></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">.vs</button></li><li class="tab active"><button type="button" data-href="#test1-2">*.sln</button></li><li class="tab"><button type="button" data-href="#test1-3">*.vcxproj</button></li><li class="tab"><button type="button" data-href="#test1-4">*.vcxproj.filters</button></li><li class="tab"><button type="button" data-href="#test1-5">*.vcxproj.user</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><ul><li>用来存储当前用户在解决方案中的工作配置(具体包括VS关闭前最后的窗口布局、最后打开的选项卡/操作记录/文件文档、某些自定义配置/开发环境、调试断点等这类设置信息和状态)。这样每当用户关闭解决方案后再重新打开，能以先前的工作配置继续工作。</li><li>该目录本身具有临时性，删除后不影响解决方案的启动和运行，vs会自动重新生成（相当于第一次打开这个项目），只是之前的工作配置及记录没有了。</li><li>如果团队中有使用源代码版本控制系统，这个文件夹要加入忽略规则，毕竟没必要同步每个人的使用习惯和当前工作进度。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test1-2"><p>解决方案文件</p><ul><li>管理该方案中的多个vcxproj，一个方案下可以有多个项目。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>工程文件</p><ul><li><p>将工程中的所有文件和配置信息都记录在一起形成整体的文件。</p></li><li><p>VS2010及以后版本的VS工程文件为*.vcproj</p></li><li><p>VS2008及先前版本为*.vcxproj</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p>可理解为视图文件</p><ul><li><p>定义了工程在VS中打开后的<strong>目录结构</strong>，修改该文件后重新build时vs不会重新build工程</p></li><li><p>筛选器文件，指定哪些是头文件，哪些是source文件等等。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><ul><li>user是本地化用户配置，允许多个用户使用自己喜好的方式配置这个项目（例如打开项目时候窗体位置等与项目内容无关的配置）</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="MFC开发中遇到的问题">MFC开发中遇到的问题</h2><p>VS2019安装：</p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_41897154/article/details/105189154">https://blog.csdn.net/qq_41897154/article/details/105189154</a></p><p><a href="https://www.jb51.net/article/175149.htm">https://www.jb51.net/article/175149.htm</a></p><p><a href="https://blog.csdn.net/qq_45391763/article/details/101482454">https://blog.csdn.net/qq_45391763/article/details/101482454</a></p><p><a href="https://jingyan.baidu.com/article/6fb756ec2f80e4241858fbc0.html">https://jingyan.baidu.com/article/6fb756ec2f80e4241858fbc0.html</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/image-20211028180450599.png" alt="image-20211028180450599"></p><p>勾上适用于最新v142生成工具的C++MFC</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/image-20211028175027895.png" alt="image-20211028175027895"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/image-20211028182607325.png" alt="image-20211028182607325"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/image-20211102204439074.png" alt="image-20211102204439074"></p><p><strong>头文件中#program once的含义及用法</strong></p><p>功能：确保该头文件只被编译一次</p><p>现在大部分编译器都支持这个杂注</p><details class="folding-tag" cyan open><summary> 参考网址 </summary>              <div class='content'>              <p><a href="https://www.cnblogs.com/feifanrensheng/p/9130959.html">#pragma once含义及用法</a></p><p><a href="https://bbs.csdn.net/topics/220009652">vs头文件中的#pragma once是什么意思？-CSDN社区</a></p>              </div>            </details><h1>VS2015</h1><ul><li>工作中追求稳定用次新版本，因为第三方库不一定支持新版本</li></ul><details class="folding-tag" ><summary> 安装出现setup blocked，未来遇到在研究 </summary>              <div class='content'>              <p>下载地址：<br>进入https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/</p><p>点击下载按钮，登录微软账号</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/image-20211107134921978.png" alt="image-20211107134921978"></p><p>左侧筛选VS2015，右侧点击VS2015SDK下载</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/image-20211107135025169.png" alt="image-20211107135025169"></p><p>双击下载后的exe出现setup blocked</p>              </div>            </details><p>换一种方法</p><p>下载iso，后解压，双击安装程序，安装过程提示安装包受损，通过下载证书后再次打开</p><p><a href="https://www.cnblogs.com/wanghongyun/p/6130057.html">iso下载</a></p><p><a href="https://blog.csdn.net/weixin_29599033/article/details/113322867">vs2015安装_VS2015安装教程</a></p><p><a href="https://www.cnblogs.com/tmdsleep/p/5492732.html">证书解决</a></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/image-20211107144212759.png" alt="image-20211107144212759"></p><p>安装证书后依然要搜索包</p><p>把安装包的复制到第三个选项</p><p>参考：<a href="https://www.zhihu.com/question/33643147">win10安装visual studio 2015 出现安装包丢失或损坏是什么原因？</a></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/image-20211107145749145.png" alt="image-20211107145749145"></p><p>安装好了，改一下深色主题</p><p><a href="https://jingyan.baidu.com/article/3052f5a1edb86097f31f86b1.html">如何更改vs2015的皮肤颜色</a></p><p>改一下文本编辑器为等宽字体,显示行号</p><p><a href="https://jingyan.baidu.com/article/5bbb5a1bfe6a5713eba1792b.html">如何设置vs显示行号</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WIN32 API档案速查</title>
      <link href="/posts/57d48d90.html"/>
      <url>/posts/57d48d90.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1>进程</h1><h2 id="结构体STARTUPINFO">结构体STARTUPINFO</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfow">STARTUPINFOW structure (processthreadsapi.h)</a></p></blockquote><p>CreateProcess的in参数，定制新进程中窗口的大小、位置等属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFO</span>&#123;</span></span><br><span class="line">  DWORD  cb;                <span class="comment">//结构体长度</span></span><br><span class="line">  LPWSTR lpReserved;        <span class="comment">//结构长度</span></span><br><span class="line">  LPWSTR lpDesktop;         <span class="comment">//保留</span></span><br><span class="line">  LPWSTR lpTitle;           <span class="comment">//指定桌面名称，保留</span></span><br><span class="line">  DWORD  dwX;               <span class="comment">//如果为控制台进程则为显示的标题</span></span><br><span class="line">  DWORD  dwY;               <span class="comment">//窗口横坐标</span></span><br><span class="line">  DWORD  dwXSize;           <span class="comment">//窗口纵坐标</span></span><br><span class="line">  DWORD  dwYSize;           <span class="comment">//窗口宽度</span></span><br><span class="line">  DWORD  dwXCountChars;     <span class="comment">//控制台窗口字符行数</span></span><br><span class="line">  DWORD  dwYCountChars;</span><br><span class="line">  DWORD  dwFillAttribute;   <span class="comment">//控制台窗口填充模式</span></span><br><span class="line">  DWORD  dwFlags;           <span class="comment">//创建标记</span></span><br><span class="line">  WORD   wShowWindow;       <span class="comment">//窗口显示标记，如同ShowWindow中的标记</span></span><br><span class="line">  WORD   cbReserved2;       <span class="comment">//保留参数</span></span><br><span class="line">  LPBYTE lpReserved2;       <span class="comment">//保留参数</span></span><br><span class="line">  HANDLE hStdInput;         <span class="comment">//标准输入句柄</span></span><br><span class="line">  HANDLE hStdOutput;        <span class="comment">//标准输出句柄</span></span><br><span class="line">  HANDLE hStdError;         <span class="comment">//标准错误句柄</span></span><br><span class="line">&#125; STARTUPINFO, *LPSTARTUPINFO;</span><br></pre></td></tr></table></figure><h2 id="结构体PROCESS-INFORMATION">结构体PROCESS_INFORMATION</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION structure (processthreadsapi.h)</a></p></blockquote><p>CreateProcess的out参数，进程与线程的句柄和ID</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">  HANDLE hProcess;          <span class="comment">//新建进程内核句柄</span></span><br><span class="line">  HANDLE hThread;           <span class="comment">//主线程内核句柄</span></span><br><span class="line">  DWORD  dwProcessId;       <span class="comment">//新建进程ID</span></span><br><span class="line">  DWORD  dwThreadId;        <span class="comment">//主线程ID</span></span><br><span class="line">&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;</span><br></pre></td></tr></table></figure><h2 id="CreateProcess">CreateProcess</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw">CreateProcessW function (processthreadsapi.h)</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR               lpApplicationName,      <span class="comment">//应用程序名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPWSTR                lpCommandLine,          <span class="comment">//命令行字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpProcessAttributes,    <span class="comment">//进程的安全属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpThreadAttributes,     <span class="comment">//线程的安全属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL                  bInheritHandles,        <span class="comment">//是否继承父进程的属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwCreationFlags,        <span class="comment">//创建标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID                lpEnvironment,          <span class="comment">//指向新的环境块的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR               lpCurrentDirectory,     <span class="comment">//指向当前目录名的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSTARTUPINFOW        lpStartupInfo,          <span class="comment">//传递给新进程的信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPPROCESS_INFORMATION lpProcessInformation    <span class="comment">//新进程返回的信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="CloseHandle">CloseHandle</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle function (handleapi.h)</a></p></blockquote><p>Closes an open object handle.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CloseHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hObject</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="快照遍历">快照遍历</h2><h3 id="CreateToolhelp32Snapshot">CreateToolhelp32Snapshot</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot function (tlhelp32.h)</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateToolhelp32Snapshot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD th32ProcessID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">zh-cn</button></li><li class="tab"><button type="button" data-href="#test1-2">en</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>对指定的进程、（或）进程使用的堆、模块、线程做一个快照</p><p><code>[in]dwFlags</code></p><p>指定获取的列表类型</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>TH32CS_SNAPHEAPLIST</td><td>枚举<u>th32ProcessID</u>参数指定的进程中的堆</td></tr><tr><td>TH32CS_SNAPMODULE</td><td>枚举<u>th32ProcessID</u>参数指定的进程中的模块</td></tr><tr><td>TH32CS_SNAPPROCESS</td><td>枚举系统范围内的进程，此时<u>th32ProcessID</u>被忽略</td></tr><tr><td>TH32CS_SNAPTHREAD</td><td>枚举系统范围内的线程，此时<u>th32ProcessID</u>被忽略</td></tr></tbody></table><p><code>[in]th32ProcessID</code></p><p>进程ID，指定哪个进程，当获取系统进程列表或当前进程时取0</p><p>返回值：</p><ul><li>调用成功，返回一个快照句柄</li><li>调用失败，返回INVALID_HANDLE_VALUE</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>Takes a snapshot of the specified processes, as well as the heaps, modules, and threads used by these processes.</p><p><strong>Parameters</strong></p><p><code>[in] dwFlags</code></p><p>The portions of the system to be included in the snapshot. This parameter can be one or more of the following values.</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left"><strong>TH32CS_INHERIT</strong>0x80000000</td><td style="text-align:left">Indicates that the snapshot handle is to be inheritable.</td></tr><tr><td style="text-align:left"><strong>TH32CS_SNAPALL</strong></td><td style="text-align:left">Includes all processes and threads in the system, plus the heaps and modules of the process specified in <em>th32ProcessID</em>. Equivalent to specifying the <strong>TH32CS_SNAPHEAPLIST</strong>, <strong>TH32CS_SNAPMODULE</strong>, <strong>TH32CS_SNAPPROCESS</strong>, and <strong>TH32CS_SNAPTHREAD</strong> values combined using an OR operation (‘|’).</td></tr><tr><td style="text-align:left"><strong>TH32CS_SNAPHEAPLIST</strong>0x00000001</td><td style="text-align:left">Includes all heaps of the process specified in <em>th32ProcessID</em> in the snapshot. To enumerate the heaps, see <a href="https://docs.microsoft.com/en-us/windows/desktop/api/tlhelp32/nf-tlhelp32-heap32listfirst">Heap32ListFirst</a>.</td></tr><tr><td style="text-align:left"><strong>TH32CS_SNAPMODULE</strong>0x00000008</td><td style="text-align:left">Includes all modules of the process specified in <em>th32ProcessID</em> in the snapshot. To enumerate the modules, see <a href="https://docs.microsoft.com/en-us/windows/desktop/api/tlhelp32/nf-tlhelp32-module32first">Module32First</a>. If the function fails with <strong>ERROR_BAD_LENGTH</strong>, retry the function until it succeeds.<strong>64-bit Windows:</strong> Using this flag in a 32-bit process includes the 32-bit modules of the process specified in <em>th32ProcessID</em>, while using it in a 64-bit process includes the 64-bit modules. To include the 32-bit modules of the process specified in <em>th32ProcessID</em> from a 64-bit process, use the <strong>TH32CS_SNAPMODULE32</strong> flag.</td></tr><tr><td style="text-align:left"><strong>TH32CS_SNAPMODULE32</strong>0x00000010</td><td style="text-align:left">Includes all 32-bit modules of the process specified in <em>th32ProcessID</em> in the snapshot when called from a 64-bit process. This flag can be combined with <strong>TH32CS_SNAPMODULE</strong> or <strong>TH32CS_SNAPALL</strong>. If the function fails with <strong>ERROR_BAD_LENGTH</strong>, retry the function until it succeeds.</td></tr><tr><td style="text-align:left"><strong>TH32CS_SNAPPROCESS</strong>0x00000002</td><td style="text-align:left">Includes all processes in the system in the snapshot. To enumerate the processes, see <a href="https://docs.microsoft.com/en-us/windows/desktop/api/tlhelp32/nf-tlhelp32-process32first">Process32First</a>.</td></tr><tr><td style="text-align:left"><strong>TH32CS_SNAPTHREAD</strong>0x00000004</td><td style="text-align:left">Includes all threads in the system in the snapshot. To enumerate the threads, see <a href="https://docs.microsoft.com/en-us/windows/desktop/api/tlhelp32/nf-tlhelp32-thread32first">Thread32First</a>.To identify the threads that belong to a specific process, compare its process identifier to the <strong>th32OwnerProcessID</strong> member of the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/tlhelp32/ns-tlhelp32-threadentry32">THREADENTRY32</a> structure when enumerating the threads.</td></tr></tbody></table><p><code>[in] th32ProcessID</code></p><p>The process identifier of the process to be included in the snapshot. This parameter can be zero to indicate the current process. This parameter is used when the <strong>TH32CS_SNAPHEAPLIST</strong>, <strong>TH32CS_SNAPMODULE</strong>, <strong>TH32CS_SNAPMODULE32</strong>, or <strong>TH32CS_SNAPALL</strong> value is specified. Otherwise, it is ignored and all processes are included in the snapshot.</p><p>If the specified process is the Idle process or one of the CSRSS processes, this function fails and the last error code is <strong>ERROR_ACCESS_DENIED</strong> because their access restrictions prevent user-level code from opening them.</p><p>If the specified process is a 64-bit process and the caller is a 32-bit process, this function fails and the last error code is <strong>ERROR_PARTIAL_COPY</strong> (299).</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="遍历进程">遍历进程</h3><h4 id="结构体PROCESSENTRY32">结构体PROCESSENTRY32</h4><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/ns-tlhelp32-processentry32">PROCESSENTRY32 structure (tlhelp32.h)</a></p></blockquote><p>Describes an entry from a list of the processes residing in the system address space when a snapshot was taken.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPROCESSENTRY32</span> &#123;</span></span><br><span class="line">  DWORD     dwSize;               <span class="comment">//结构的长度，预先设置</span></span><br><span class="line">  DWORD     cntUsage;             <span class="comment">//进程的引用计数</span></span><br><span class="line">  DWORD     th32ProcessID;        <span class="comment">//进程ID</span></span><br><span class="line">  ULONG_PTR th32DefaultHeapID;    <span class="comment">//进程默认的堆</span></span><br><span class="line">  DWORD     th32ModuleID;         <span class="comment">//进程模块ID</span></span><br><span class="line">  DWORD     cntThreads;           <span class="comment">//进程创建的线程数</span></span><br><span class="line">  DWORD     th32ParentProcessID;  <span class="comment">//进程的父进程ID</span></span><br><span class="line">  LONG      pcPriClassBase;       <span class="comment">//进程创建的线程的基本优先级</span></span><br><span class="line">  DWORD     dwFlags;              <span class="comment">//内部使用</span></span><br><span class="line">  CHAR      szExeFile[MAX_PATH];  <span class="comment">//进程对应可执行文件名</span></span><br><span class="line">&#125; PROCESSENTRY32,*PROCESSENTRY32;</span><br></pre></td></tr></table></figure><h4 id="Process32First">Process32First</h4><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32first">Process32First function (tlhelp32.h)</a></p></blockquote><p>Retrieves information about the <strong>first</strong> process encountered in a system snapshot.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Process32First</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE           hSnapshot,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPPROCESSENTRY32 lppe</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>参数解析：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>hSnapshot</td><td>A handle to the snapshot returned from a previous call to the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</td></tr><tr><td>lppe</td><td>A pointer to a <a href="https://docs.microsoft.com/en-us/windows/desktop/api/tlhelp32/ns-tlhelp32-processentry32">PROCESSENTRY32</a> structure.</td></tr></tbody></table><p>返回值：</p><p>Returns <strong>TRUE</strong> if the first entry of the process list has been copied to the buffer or <strong>FALSE</strong> otherwise. The <strong>ERROR_NO_MORE_FILES</strong> error value is returned by the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function if no processes exist or the snapshot does not contain process information.</p><h4 id="Process32Next">Process32Next</h4><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32next">Process32Next function (tlhelp32.h)</a></p></blockquote><p>Retrieves information about the <strong>next</strong> process recorded in a system snapshot.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Process32Next</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE           hSnapshot,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPPROCESSENTRY32 lppe</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>参数解析：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>hSnapshot</td><td>A handle to the snapshot returned from a previous call to the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</td></tr><tr><td>lppe</td><td>A pointer to a <a href="https://docs.microsoft.com/en-us/windows/desktop/api/tlhelp32/ns-tlhelp32-processentry32">PROCESSENTRY32</a> <a href="http://structure.It">structure.It</a> contains process information such as the name of the executable file, the process identifier, and the process identifier of the parent process.</td></tr></tbody></table><p>返回值：</p><p>Returns <strong>TRUE</strong> if the first entry of the process list has been copied to the buffer or <strong>FALSE</strong> otherwise. The <strong>ERROR_NO_MORE_FILES</strong> error value is returned by the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function if no processes exist or the snapshot does not contain process information.</p><h3 id="遍历进程使用的模块">遍历进程使用的模块</h3><h4 id="结构体MODULEENTRY32">结构体MODULEENTRY32</h4><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/ns-tlhelp32-moduleentry32">MODULEENTRY32 structure (tlhelp32.h)</a></p></blockquote><p>Describes an entry from a list of the modules belonging to the specified process.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMODULEENTRY32</span> &#123;</span></span><br><span class="line">  DWORD   dwSize;</span><br><span class="line">  DWORD   th32ModuleID;</span><br><span class="line">  DWORD   th32ProcessID;</span><br><span class="line">  DWORD   GlblcntUsage;</span><br><span class="line">  DWORD   ProccntUsage;</span><br><span class="line">  BYTE    *modBaseAddr;</span><br><span class="line">  DWORD   modBaseSize;</span><br><span class="line">  HMODULE hModule;</span><br><span class="line">  <span class="keyword">char</span>    szModule[MAX_MODULE_NAME32 + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">char</span>    szExePath[MAX_PATH];</span><br><span class="line">&#125; MODULEENTRY32;</span><br></pre></td></tr></table></figure><h4 id="Module32First">Module32First</h4><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-module32first">Module32First function (tlhelp32.h)</a></p></blockquote><p>Retrieves information about the first module associated with a process.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Module32First</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]      HANDLE          hSnapshot,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out] LPMODULEENTRY32 lpme</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="Module32Next">Module32Next</h4><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-module32next">Module32Next function (tlhelp32.h)</a></p></blockquote><p>Retrieves information about the next module associated with a process or thread.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Module32Next</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE          hSnapshot,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPMODULEENTRY32 lpme</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="ExitProcess">ExitProcess</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess">ExitProcess function (processthreadsapi.h)</a></p></blockquote><p>Ends the calling process and all its threads.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExitProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  UINT uExitCode</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>参数解析：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>uExitCode</td><td>The exit code for the process and all threads.</td></tr></tbody></table><p>uExitCode参数列表：<br>0表示正常退出，其他数字有其他消息的含义</p><h2 id="OpenProcess">OpenProcess</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess">OpenProcess function (processthreadsapi.h)</a></p></blockquote><p>Opens an existing local process object.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL  bInheritHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwProcessId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="TerminateProcess">TerminateProcess</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess">TerminateProcess function (processthreadsapi.h)</a></p></blockquote><p>Terminates the specified process and all of its threads.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TerminateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  UINT   uExitCode</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="CreateMutex">CreateMutex</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmutexw">CreateMutexW function (synchapi.h)</a></p></blockquote><p>Creates or opens a named or unnamed mutex object.</p><p>创建或打开一个已命名或未命名的互斥对象。</p><p>To specify an access mask for the object, use the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-createmutexexa">CreateMutexEx</a> function.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateMutexW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOL                  bInitialOwner,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCWSTR               lpName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h1>线程</h1><h2 id="结构体SECURITY-ATTRIBUTES">结构体SECURITY_ATTRIBUTES</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES structure</a></p></blockquote><p>The <strong>SECURITY_ATTRIBUTES</strong> structure contains the <a href="https://msdn.microsoft.com/en-us/library/ms721625(v=vs.85)"><em>security descriptor</em></a> for an object and specifies whether the handle retrieved by specifying this structure is inheritable. This structure provides security settings for objects created by various functions, such as <a href="https://msdn.microsoft.com/en-us/library/aa363858(v=vs.85)"><strong>CreateFile</strong></a>, <a href="https://msdn.microsoft.com/en-us/library/aa365152(v=vs.85)"><strong>CreatePipe</strong></a>, <a href="https://msdn.microsoft.com/en-us/library/ms682425(v=vs.85)"><strong>CreateProcess</strong></a>, <a href="https://msdn.microsoft.com/en-us/library/ms724844(v=vs.85)"><strong>RegCreateKeyEx</strong></a>, or <a href="https://msdn.microsoft.com/en-us/library/ms724919(v=vs.85)"><strong>RegSaveKeyEx</strong></a>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SECURITY_ATTRIBUTES</span> &#123;</span></span><br><span class="line">  DWORD  nLength;</span><br><span class="line">  LPVOID lpSecurityDescriptor;</span><br><span class="line">  BOOL   bInheritHandle;</span><br><span class="line">&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;</span><br></pre></td></tr></table></figure><h2 id="CreateThread">CreateThread</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread">CreateThread function (processthreadsapi.h)</a></p><p><a href="https://blog.csdn.net/believe_s/article/details/82623531?spm=1001.2014.3001.5501">CreateThread函数-CSDN现有的翻译</a></p></blockquote><p>Creates a thread to execute within the virtual address space of the calling process.</p><p>To create a thread that runs in the virtual address space of another process, use the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createremotethread">CreateRemoteThread</a> function.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,   <span class="comment">//线程安全性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            SIZE_T                  dwStackSize,          <span class="comment">//指定线程堆栈大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,       <span class="comment">//线程回调函数地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  __drv_aliasesMem LPVOID lpParameter,          <span class="comment">//传递给线程函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            DWORD                   dwCreationFlags,      <span class="comment">//指定线程创建后是否立即启动</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] LPDWORD                 lpThreadId            <span class="comment">//用于取得内核给新线程分配的ID号</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><p>lpThreadAttributes：一个指向SECURITY_ATTRIBUTES结构的指针，如果需要默认安全属性，传递NULL，如果希望此线程对象句柄可以被子进程继承的话，必须设定一个SECURITY_ATTRIBUTES结构。将它的binheritHandle成员初始化为TRUE。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SECURITY_ATTRIBUTES sa;</span><br><span class="line">sa.nLength=<span class="built_in"><span class="keyword">sizeof</span></span>(sa);</span><br><span class="line">sa.lpSecurityDescriptor=<span class="literal">NULL</span>;</span><br><span class="line">sa.blnheritHandle=TRUE;<span class="comment">//使CreateThread返回的句柄可以被继承</span></span><br><span class="line">HANDLE h=::<span class="built_in">CreateThread</span>(&amp;sa,......);<span class="comment">//句柄h可以被子进程继承</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>dwCreationFlags</strong></p><p>控制线程创建的标志。</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>该线程在创建后立即运行</td></tr><tr><td>CREATE_SUSPENDEDs 0x00000004</td><td>线程是在挂起状态下创建的，并且在<a href="https://msdn.microsoft.com/ffc4e474-635b-4bf7-a68f-073899fb3fde">调用ResumeThread</a>函数之前不会运行 。</td></tr><tr><td>STACK_SIZE_PARAM_IS_A_RESERVATION 0x00010000</td><td>所述dwStackSize参数指定堆栈的初始保留大小。如果未指定此标志，则dwStackSize指定提交大小。</td></tr></tbody></table><p><strong>返回值</strong></p><p>函数执行成功，返回新建线程的线程句柄，lpStartAddress参数指定线程函数的地址，新建线程将从此地址开始执行。直到return语句返回，线程结束，把控制权交给操作系统。</p><h2 id="线程回调函数ThreadProc">线程回调函数ThreadProc</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc callback function</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ LPVOID lpParameter</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>函数名自取，但是签名、参数要符合规约</p><h2 id="SetThreadPriority">SetThreadPriority</h2><p>Sets the priority value for the specified thread. This value, together with the priority class of the thread’s process, determines the thread’s base priority level.</p><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriority">SetThreadPriority function (processthreadsapi.h)</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetThreadPriority</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE hThread,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] <span class="keyword">int</span>    nPriority</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>nPriority参数列表：</p><table><thead><tr><th>优先级</th><th>含义</th></tr></thead><tbody><tr><td>THREAD_PRIORITY_IDLE</td><td>空闲</td></tr><tr><td>THREAD_PRIORITY_LOWEST</td><td>最低</td></tr><tr><td>THREAD_PRIORITY_BELOW_NORMAL</td><td>低于正常</td></tr><tr><td>THREAD_PRIORITY_NORMAL</td><td>正常</td></tr><tr><td>THREAD_PRIORITY_ABOVE_NORMAL</td><td>高于正常</td></tr><tr><td>THREAD_PRIORITY_HIGHEST</td><td>最高</td></tr><tr><td>THREAD_PRIORITY_TIME_CRITICAL</td><td>实时</td></tr></tbody></table><h2 id="ResumeThread">ResumeThread</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread">ResumeThread function (processthreadsapi.h)</a></p></blockquote><p>Decrements a thread’s suspend count. When the suspend count is decremented to zero, the execution of the thread is resumed.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">ResumeThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE hThread</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：</p><p>If the function succeeds, the return value is the thread’s previous suspend count.</p><p>If the function fails, the return value is (DWORD) -1. To get extended error information, call <a href="https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</p><h2 id="WaitForSingleObject">WaitForSingleObject</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject function (synchapi.h)</a></p></blockquote><p>Waits until the specified object is in the signaled state or the time-out interval elapses.</p><p>To enter an alertable wait state, use the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobjectex">WaitForSingleObjectEx</a> function. To wait for multiple objects, use <a href="https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects</a>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE hHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD  dwMilliseconds</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="WaitForMultipleObjects">WaitForMultipleObjects</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects function (synchapi.h)</a></p></blockquote><p>Waits until <strong>one or all</strong> of the specified objects are in the signaled state or the time-out interval elapses.</p><p>To enter an alertable wait state, use the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitformultipleobjectsex">WaitForMultipleObjectsEx</a> function.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD        nCount,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] <span class="keyword">const</span> HANDLE *lpHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] BOOL         bWaitAll,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD        dwMilliseconds</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="beginthread">_beginthread</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-160"><code>_beginthread</code>, <code>_beginthreadex</code></a></p></blockquote><p>A thread in an executable that calls the C run-time library (CRT) should use the <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/beginthread-beginthreadex">_beginthreadex</a> and <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/endthread-endthreadex">_endthreadex</a> functions for thread management rather than <strong>CreateThread</strong> and <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a>; this requires the use of the multithreaded version of the CRT. If a thread created using <strong>CreateThread</strong> calls the CRT, the CRT may terminate the process in low-memory conditions.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span> _beginthread( <span class="comment">// NATIVE CODE</span></span><br><span class="line">   <span class="built_in"><span class="keyword">void</span></span>( __cdecl *start_address )( <span class="keyword">void</span> * ),</span><br><span class="line">   <span class="keyword">unsigned</span> stack_size,</span><br><span class="line">   <span class="keyword">void</span> *arglist</span><br><span class="line">);</span><br><span class="line"><span class="keyword">uintptr_t</span> _beginthread( <span class="comment">// MANAGED CODE</span></span><br><span class="line">   <span class="built_in"><span class="keyword">void</span></span>( __clrcall *start_address )( <span class="keyword">void</span> * ),</span><br><span class="line">   <span class="keyword">unsigned</span> stack_size,</span><br><span class="line">   <span class="keyword">void</span> *arglist</span><br><span class="line">);</span><br><span class="line"><span class="keyword">uintptr_t</span> _beginthreadex( <span class="comment">// NATIVE CODE</span></span><br><span class="line">   <span class="keyword">void</span> *security,</span><br><span class="line">   <span class="keyword">unsigned</span> stack_size,</span><br><span class="line">   <span class="built_in"><span class="keyword">unsigned</span></span> ( __stdcall *start_address )( <span class="keyword">void</span> * ),</span><br><span class="line">   <span class="keyword">void</span> *arglist,</span><br><span class="line">   <span class="keyword">unsigned</span> initflag,</span><br><span class="line">   <span class="keyword">unsigned</span> *thrdaddr</span><br><span class="line">);</span><br><span class="line"><span class="keyword">uintptr_t</span> _beginthreadex( <span class="comment">// MANAGED CODE</span></span><br><span class="line">   <span class="keyword">void</span> *security,</span><br><span class="line">   <span class="keyword">unsigned</span> stack_size,</span><br><span class="line">   <span class="built_in"><span class="keyword">unsigned</span></span> ( __clrcall *start_address )( <span class="keyword">void</span> * ),</span><br><span class="line">   <span class="keyword">void</span> *arglist,</span><br><span class="line">   <span class="keyword">unsigned</span> initflag,</span><br><span class="line">   <span class="keyword">unsigned</span> *thrdaddr</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="临界区锁">临界区锁</h2><h3 id="Critical-Section-Objects">Critical Section Objects</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/sync/critical-section-objects">Critical Section Objects</a></p><p>扩展阅读：<a href="http://blog.sina.com.cn/s/blog_7953cead0100osnt.html">对于CRITICAL_SECTION用法的介绍和理解</a></p></blockquote><h3 id="InitializeCriticalSection">InitializeCriticalSection</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializecriticalsection">InitializeCriticalSection function (synchapi.h)</a></p></blockquote><p>Initializes a critical section object.</p><p>初始化一个临界区对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeCriticalSection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPCRITICAL_SECTION lpCriticalSection</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="EnterCriticalSection">EnterCriticalSection</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-entercriticalsection">EnterCriticalSection function (synchapi.h)</a></p></blockquote><p>Waits for ownership of the specified critical section object. The function returns when the calling thread is granted ownership.</p><p>进入临界区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnterCriticalSection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out] LPCRITICAL_SECTION lpCriticalSection</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="LeaveCriticalSection">LeaveCriticalSection</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection">LeaveCriticalSection function (synchapi.h)</a></p></blockquote><p>Releases ownership of the specified critical section object.</p><p>离开临界区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeaveCriticalSection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out] LPCRITICAL_SECTION lpCriticalSection</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="DeleteCriticalSection">DeleteCriticalSection</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-deletecriticalsection">DeleteCriticalSection function (synchapi.h)</a></p></blockquote><p>Releases all resources used by an unowned critical section object.</p><p>删除临界区对象资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteCriticalSection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out] LPCRITICAL_SECTION lpCriticalSection</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="互锁函数">互锁函数</h2><h3 id="InterlockedIncrement">InterlockedIncrement</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-interlockedincrement">InterlockedIncrement function (winnt.h)</a></p></blockquote><p>Increments (increases by one) the value of the specified 32-bit variable as an atomic operation.</p><p>To operate on 64-bit values, use the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/nf-winnt-interlockedincrement64">InterlockedIncrement64</a> function.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">InterlockedIncrement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out] LONG <span class="keyword">volatile</span> *Addend</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="InterlockedDecrement">InterlockedDecrement</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-interlockeddecrement">InterlockedDecrement function (winnt.h)</a></p></blockquote><p>Decrements (decreases by one) the value of the specified 32-bit variable as an atomic operation.</p><p>To operate on 64-bit values, use the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/nf-winnt-interlockeddecrement64">InterlockedDecrement64</a> function.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">InterlockedDecrement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out] LONG <span class="keyword">volatile</span> *Addend</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="InterlockedExchangeAdd">InterlockedExchangeAdd</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-interlockedexchangeadd">InterlockedExchangeAdd function (winnt.h)</a></p></blockquote><p>Performs an atomic addition of two 32-bit values.</p><p>To operate on 64-bit values, use the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-interlockedexchangeadd64">InterlockedExchangeAdd64</a> function.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">InterlockedExchangeAdd</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out] LONG <span class="keyword">volatile</span> *Addend,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]      LONG          Value</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="InterlockedExchangePointer">InterlockedExchangePointer</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-interlockedexchangepointer">InterlockedExchangePointer function (winnt.h)</a></p></blockquote><p>Atomically exchanges a pair of addresses.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">InterlockedExchangePointer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out] PVOID <span class="keyword">volatile</span> *Target,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]      PVOID          Value</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="信号量同步">信号量同步</h2><h3 id="CreateEvent">CreateEvent</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventa">CreateEventA function (synchapi.h)</a></p></blockquote><p>Creates or opens a named or unnamed event object.</p><p>To specify an access mask for the object, use the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-createeventexa">CreateEventEx</a> function.</p><p>创建时间对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEventA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPSECURITY_ATTRIBUTES lpEventAttributes, <span class="comment">//定义事件对象的安全属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOL                  bManualReset,      <span class="comment">//指定是否需要手工重置事件对象为受信状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOL                  bInitialState,     <span class="comment">//指定事件对象创建时的初始状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR                lpName             <span class="comment">//事件对象的名称  </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="OpenEvent">OpenEvent</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-openeventa">OpenEventA function (synchapi.h)</a></p></blockquote><p>Opens an existing named event object.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenEventA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD  dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] BOOL   bInheritHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCSTR lpName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="SetEvent">SetEvent</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setevent">SetEvent function (synchapi.h)</a></p></blockquote><p>Sets the specified event object to the signaled state.</p><p>设置具体的事件对象为受信状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE hEvent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="ReSetEvent">ReSetEvent</h3><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-resetevent">ResetEvent function (synchapi.h)</a></p></blockquote><p>Sets the specified event object to the nonsignaled state.</p><p>设置具体的事件对象为未受信状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ResetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE hEvent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h1>内存</h1><h2 id="ZeroMemory">ZeroMemory</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa366920(v=vs.85)">ZeroMemory macro</a></p></blockquote><p>Fills a block of memory with zeros.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PVOID  Destination,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] SIZE_T Length</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="ReadProcessMemory">ReadProcessMemory</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory">ReadProcessMemory function (memoryapi.h)</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReadProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPCVOID lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPVOID  lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T  nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] SIZE_T  *lpNumberOfBytesRead</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="WriteProcessMemory">WriteProcessMemory</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory function (memoryapi.h)</a></p></blockquote><p>Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPVOID  lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPCVOID lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T  nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] SIZE_T  *lpNumberOfBytesWritten</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h1>错误处理</h1><h2 id="GetLastError">GetLastError</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError function (errhandlingapi.h)</a></p></blockquote><p>Retrieves the calling thread’s last-error code value. The last-error code is maintained on a per-thread basis. Multiple threads do not overwrite each other’s last-error code.</p><p><strong>Visual Basic:</strong> Applications should call <strong>err.LastDllError</strong> instead of <strong>GetLastError</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_Post_equals_last_error_ DWORD <span class="title">GetLastError</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows安全 </category>
          
          <category> 编程篇 </category>
          
          <category> win api </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIN32 API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Windows黑客编程技术详解》</title>
      <link href="/posts/e8553cf2.html"/>
      <url>/posts/e8553cf2.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>书籍参考：<a href="https://book.douban.com/subject/30434801/">《Windows黑客编程技术详解》</a></p><h1>开始之前</h1><h2 id="前言-2">前言</h2><ol><li>“知其然，然后知其所以然”，本书重在“知其然”</li><li>章节独立性高，可以跳读</li><li>但对每一章，都由7个模块（背景、函数介绍、实现原理、编码实现、测试和总结）进行写作，建议按这个顺序进行阅读。</li></ol><h2 id="配套资源">配套资源</h2><p><a href="https://www.epubit.com/bookDetails?id=N39391&amp;typeName=%E6%90%9C%E7%B4%A2">异步社区-配套资源下载</a></p><p><a href="https://www.write-bug.com/article/1811.html">write-bug上配套资源</a></p><p><a href="https://www.write-bug.com/article/1966.html">书籍勘误及环境配置</a></p><h2 id="关于作者">关于作者</h2><p><a href="www.write-bug.com">Write-Bug技术共享平台</a>创始人</p><p>甘迪文，北邮网络空间安全学院研究生，导师崔宝江。19年步入清华大学攻读软工专业博士。</p><h1>用户层</h1><h2 id="基础技术">基础技术</h2><h3 id="运行单一实例">运行单一实例</h3><p>CreateMutex，通过文件名判断是否重复运行</p><p>GetLastError</p><h3 id="DLL延迟加载">DLL延迟加载</h3><p>代码涉及MFC，先mark</p><h3 id="资源释放">资源释放</h3><p>涉及资源，先mark</p><h2 id="注入技术">注入技术</h2><h3 id="全局钩子注入">全局钩子注入</h3><blockquote><p>SetWindowsHookEx设置全局钩子，CallNextHookEx函数传递钩子，UnhookWindowsHookEx卸载钩子</p><p>#pragma data_seg创建共享内存</p></blockquote><p>SetWindowsHookEx，创建全局钩子（全局钩子必须在一个DLL中），进程发生相应事件时，系统会把DLL加载在进程空间，以此完成DLL注入</p><p>在DLL中创建共享内存（共享数据段），在一个进程中修改了数据，另一个进程中也会被修改</p><h3 id="传统远线程注入">传统远线程注入</h3><p>利用CreateRemoteThread和LoadLibrary函数参数的相似性</p><p>OpenProcess获取进程句柄，在要注入的进程中申请内存VirtualAllocEx，写入数据WriteProcessMemory，用GetProcAddress获得LoadLibrary地址，CreateRemoteThread创建远程线程，实现DLL注入</p><blockquote><p>打开高权限进程会失败，因为系统SESSION 0隔离的安全机制</p></blockquote><h3 id="突破SESSION-0隔离的远线程注入">突破SESSION 0隔离的远线程注入</h3><p>前人逆向出的ZwCreateThreadEx，其他的原理和上边一样</p><h3 id="APC注入">APC注入</h3><blockquote><p>QueueUserAPC</p></blockquote><p>队列</p><p>线程被唤醒时APC中的注册函数会被执行，以此去执行DLL加载代码</p><h2 id="启动技术">启动技术</h2><h3 id="创建进程API">创建进程API</h3><blockquote><p>WinExec</p><p>ShellExecute</p><p>CreateProcess</p></blockquote><p>参数设置隐藏窗口</p><blockquote><p>EnumWindwos函数可以枚举屏幕上所有顶层窗口，包括隐藏窗口</p></blockquote><h3 id="突破SESSION-0隔离创建用户进程">突破SESSION 0隔离创建用户进程</h3><p>调用WTSGetActiveConsoleSessionId获取当前程序灰灰ID，即Session Id，然后据此调用WTSQueryUserToken函数检索用户令牌，并获取对应的用户令牌句柄，然后用DuplicateTokenEX创建新令牌并复制，最后根据新令牌调用CreateEnvironmentBlock函数创建一个环境快，传递给CreateProcessAsUser使用</p><h3 id="内存直接加载运行">内存直接加载运行</h3><p>病毒木马具有模拟PE加载器的功能，直接把PE文件中从内存加载到病毒木马的进程中，不通过LoadLibrary现成的API去操作，以此躲过杀毒软件</p><h2 id="自启动技术">自启动技术</h2><h3 id="注册表">注册表</h3><h3 id="快速启动目录">快速启动目录</h3><h3 id="计划任务">计划任务</h3><h3 id="系统服务">系统服务</h3><h2 id="提权技术">提权技术</h2><h3 id="进程访问令牌权限提升">进程访问令牌权限提升</h3><h3 id="Bypass-UAC">Bypass UAC</h3><h2 id="隐藏技术">隐藏技术</h2><h3 id="进程伪装">进程伪装</h3><h3 id="傀儡进程">傀儡进程</h3><h3 id="进程隐藏">进程隐藏</h3><h3 id="DLL劫持">DLL劫持</h3><h2 id="压缩技术">压缩技术</h2><h3 id="数据压缩API">数据压缩API</h3><h3 id="ZLIB压缩裤">ZLIB压缩裤</h3><h2 id="加密技术">加密技术</h2><h3 id="Windows自带的加密库">Windows自带的加密库</h3><h3 id="Crypto-密码库">Crypto++密码库</h3><h2 id="传输技术">传输技术</h2><h3 id="Socket通信">Socket通信</h3><h3 id="FTP通信">FTP通信</h3><h3 id="HTTP通信">HTTP通信</h3><h3 id="HTTPS通信">HTTPS通信</h3><h2 id="功能技术">功能技术</h2><h3 id="进程遍历">进程遍历</h3><h3 id="文件遍历">文件遍历</h3><h3 id="桌面截屏">桌面截屏</h3><h3 id="按键记录">按键记录</h3><h3 id="远程CMD">远程CMD</h3><h3 id="U盘监控">U盘监控</h3><h3 id="文件监控">文件监控</h3><h3 id="自删除">自删除</h3><h1>内核层</h1>]]></content>
      
      
      <categories>
          
          <category> Windows安全 </category>
          
          <category> 编程篇 </category>
          
          <category> win api </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIN32 API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows程序设计实例</title>
      <link href="/posts/97187543.html"/>
      <url>/posts/97187543.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p><a href="https://docs.microsoft.com/en-us/">MSDN</a></p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_32285693/article/list/2?t=1">奕星星奕-CSDN</a></p></blockquote><blockquote><p>note：环境多字节or宽字符；CorC++细节自己注意下，不唠叨</p></blockquote><h2 id="进程">进程</h2><h3 id="遍历">遍历</h3><h4 id="遍历进程信息">遍历进程信息</h4><blockquote><p>涉及：结构体PROCESSENTRY32；函数CreateToolhelp32Snapshot、Process32First、Process32Next</p></blockquote><p>从快照列表中获取进程信息使用Process32First和Process32Next函数，每次调用仅返回一个进程的信息，当不再有剩余信息时，函数返回FALSE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span>                   <span class="comment">//声明快照函数的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PROCESSENTRY32 pe32;                <span class="comment">//使用结构前，传递它的大小</span></span><br><span class="line">    pe32.dwSize=<span class="keyword">sizeof</span>(pe32);</span><br><span class="line"></span><br><span class="line">    HANDLE hProcessSnap=CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,<span class="number">0</span>);<span class="comment">//TH32CS_SNAPPROCESS,给所有系统进程一个快照</span></span><br><span class="line">    <span class="keyword">if</span>(hProcessSnap==INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历快照，轮流显示每个进程的信息</span></span><br><span class="line">    BOOL bMore=Process32First(hProcessSnap,&amp;pe32);  </span><br><span class="line">    <span class="keyword">while</span>(bMore)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进程名称:%s\n&quot;</span>,pe32.szExeFile);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进程ID:%lu\n&quot;</span>,pe32.th32ProcessID);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bMore=Process32Next(hProcessSnap,&amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不要忘记清楚掉snapshot对象</span></span><br><span class="line">    CloseHandle(hProcessSnap);          <span class="comment">//关闭内核对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&gt; 运行结果：</p><p>有点多，没截全部<img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211011163104917.png" alt="image-20211011163104917"></p><h4 id="遍历进程使用的模块-2">遍历进程使用的模块</h4><blockquote><p>涉及：结构体MODULEENTRY32、CreateToolhelp32Snapshot、Module32First、Module32Next</p></blockquote><blockquote><p>VS2019</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span> <span class="comment">//声明快照函数的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MODULEENTRY32 me32;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;me32, <span class="built_in"><span class="keyword">sizeof</span></span>(me32));</span><br><span class="line">    me32.dwSize = <span class="built_in"><span class="keyword">sizeof</span></span>(me32);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对本进程所有的模块进行快照</span></span><br><span class="line">    HANDLE hModuleSnap = ::<span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPMODULE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//TH32CS_SNAPMODULE:枚举th32ProcessID参数指定的进程中的模块</span></span><br><span class="line">    <span class="comment">//th32ProcessID:0,获取系统进程列表或当前进程时取0</span></span><br><span class="line">    <span class="keyword">if</span> (INVALID_HANDLE_VALUE == hModuleSnap) <span class="comment">//失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;创建失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有模块</span></span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">Module32First</span>(hModuleSnap, &amp;me32))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; me32.szExePath &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;模块在当前进程中的地址&quot;</span> &lt;&lt; me32.hModule &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">while</span> (::<span class="built_in">Module32Next</span>(hModuleSnap, &amp;me32));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&gt; 运行结果：<img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211021175413982.png" alt="image-20211021175413982"></p><h3 id="创建进程">创建进程</h3><blockquote><p>涉及：结构体STARTUPINFO、结构体PROCESS_INFORMATION；ZeroMemory、CreateProcess、CloseHandle</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    ZeroMemory(&amp;si,<span class="keyword">sizeof</span>(si));</span><br><span class="line">    si.dwFlags=STARTF_USESHOWWINDOW;    <span class="comment">//指定wShowWindow成员有效</span></span><br><span class="line">    si.wShowWindow=TRUE;</span><br><span class="line"></span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(CreateProcess(</span><br><span class="line">        <span class="literal">NULL</span>,                           <span class="comment">//不在此指定可执行文件的文件名</span></span><br><span class="line">        <span class="string">&quot;notepad.exe&quot;</span>,                  <span class="comment">//命令行参数</span></span><br><span class="line">        <span class="literal">NULL</span>,                           <span class="comment">//默认进程安全性</span></span><br><span class="line">        <span class="literal">NULL</span>,                           <span class="comment">//默认线程安全性</span></span><br><span class="line">        FALSE,                          <span class="comment">//指定当前进程内的句柄不可被子进程继承</span></span><br><span class="line">        CREATE_NEW_CONSOLE,             <span class="comment">//为新进程创建一个新的控制台窗口</span></span><br><span class="line">        <span class="literal">NULL</span>,                           <span class="comment">//使用本进程的环境变量</span></span><br><span class="line">        <span class="literal">NULL</span>,                           <span class="comment">//使用本进程的驱动器和目录</span></span><br><span class="line">        &amp;si,</span><br><span class="line">        &amp;pi)</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(pi.hThread);</span><br><span class="line">        CloseHandle(pi.hProcess);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;新进程的进程ID%lu\n&quot;</span>,pi.dwProcessId);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;新进程的主线程ID%lu\n&quot;</span>,pi.dwProcessId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>创建了一个记事本进程并弹出窗口，且终端输出ID<img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows程序设计实例/image-20211011153739495.png" alt="image-20211011153739495" style="zoom:67%;" /></p><h3 id="终止进程">终止进程</h3><blockquote><p>涉及：ExitProcess</p></blockquote><p>终止进程不是进程去终止自己的运行，而是向操作系统申请停止自己的调度，由操作系统内核去进程队列中撤销该进程，撤销完成后将这个撤销调用返回返回给进程。</p><p>终止当前进程也就是进程如何终止自己的运行，方法有两个：</p><ul><li>主线程的入口函数返回：返回时，启动函数调用exit，并将用户的返回值传给它。exit销毁所有的全局和静态对象，然后调用ExitProcess促使os终止应用程序。</li><li>程序也可以显式调用ExitProcess，但这样做无法销毁全局和静态对象。</li></ul><h4 id="C-资源泄露问题">C++资源泄露问题</h4><p>ExitProcess是C风格的API，不会处理C++运行时的相应概念</p><p>如果显式调用ExitProcess，它无法回收全局、静态的对象，从而造成资源泄漏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyObj</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CMyObj</span>() </span><br><span class="line">  &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我被构造了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">CMyObj</span>() </span><br><span class="line">  &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我被析构了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMyObj obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;               <span class="comment">//正常主函数返回会调用exit，销毁所有全局和静态对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211011165413487.png" alt="image-20211011165413487"></p><p>显式调用ExitProcess：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">class CMyObj </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">CMyObj() </span><br><span class="line">  &#123;</span><br><span class="line">printf(&quot;我被构造了\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">~CMyObj() </span><br><span class="line">  &#123;</span><br><span class="line">printf(&quot;我被析构了\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">CMyObj obj;</span><br><span class="line">            //显示调用ExitProcess强制撤销OS的调度运行，退出码0表示正常返回</span><br><span class="line"><span class="addition">+ ExitProcess(0);         //全局和静态的对象并没有被销毁。析构函数不会被调用</span></span><br><span class="line"></span><br><span class="line">return 0;               //正常主函数返回会调用exit，销毁所有全局和静态对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211011170028741.png" alt="image-20211011170028741"></p><p>发现析构函数没有被调用，资源泄露了</p><h4 id="通过进程ID终止进程">通过进程ID终止进程</h4><blockquote><p>涉及：OpenProcess、TerminateProcess</p></blockquote><blockquote><p>VS2019</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">TerminateProcessFromId</span><span class="params">(DWORD dwId)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    HANDLE hProcess = ::<span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hProcess)    <span class="comment">//不为空就把你关了</span></span><br><span class="line">    &#123;</span><br><span class="line">        bRet = ::<span class="built_in">TerminateProcess</span>(hProcess, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwId;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要关闭的目标进程号：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;dwId);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TerminateProcessFromId</span>(dwId)) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;进程终止成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;进程终止失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p>打开一个程序，这里以记事本为例，然后通过任务管理器获得该进程的PID</p><p>运行上述编写的代码，输入PID<img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211013111052174.png" alt="image-20211013111052174"></p><p>如果终止进程成功，记事本会被关闭</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211013111103835.png" alt="image-20211013111103835"></p><h3 id="内存修改器">内存修改器</h3><blockquote><p>涉及：CreateProcess、GetLastError、ReadProcessMemory、WriteProcessMemory、CloseHandle</p></blockquote><blockquote><p>参考：<a href="https://blog.csdn.net/qq_32285693/article/details/95653247">原版进程内存修改器-CSDN</a></p><p><a href="https://blog.csdn.net/wangqingchuan92/article/details/102535707">《Windows程序设计（第3版）》-内存修改器</a></p><p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1255389&amp;extra=page%3D1%26filter%3Dtypeid%26typeid%3D28">小修小改语言C++_52pojie</a></p></blockquote><p>内容：设计一个名为MemChange的应用程序，让它修改Test.exe进程里面的内容。</p><p>每个进程占用的内存空间是离散的，所以要访问进程内存中的一个值，就需要遍历整个64K—2G的地址空间。</p><p><strong>难点1.MemChange如何访问Test的进程空间</strong></p><p>解决方案：MemChange程序中使用CreateProcess把Test.exe拉起来，这样MemChange就可以访问Test.exe的进程空间</p><p><strong>难点2.如何搜索进程空间</strong></p><p>Windows采用分页机制管理内存，每页的大小为4K（x86处理器上），也就是说Windows以4K为单位为应用程序分配内存。依次遍历每个页面，在一个页面中逐字节进行比对，就可以查询到需要搜索的值。</p><p>测试程序Testor.c：</p><p>两个变量，一个全局，一个局部</p><p>每次用户输入，两个值会变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_nNum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">198</span>;</span><br><span class="line">    g_nNum = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//输出两个变量的值和地址，供我们进行比对</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i=%d,addr=%p    g_nNum=%d,addr=%p\n&quot;</span>, i, &amp;i, g_nNum, &amp;g_nNum);</span><br><span class="line">        i++;</span><br><span class="line">        g_nNum--;</span><br><span class="line">        getchar();                              <span class="comment">//暂停显示，等待用户输入，然后进行下次循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序MemChange.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE g_hProcess;                                      <span class="comment">//目标进程句柄</span></span><br><span class="line">DWORD g_arList[<span class="number">1024</span>];                                   <span class="comment">//存放查找数据的地址列表，假设最多1024个</span></span><br><span class="line"><span class="keyword">int</span> g_nListCnt;                                         <span class="comment">//有效地址的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">FindFirst</span><span class="params">(DWORD dwValue)</span></span>;                          <span class="comment">//对目标进程空间进行首次查找</span></span><br><span class="line"><span class="function">BOOL <span class="title">FindNext</span><span class="params">(DWORD dwValue)</span></span>;                           <span class="comment">//对目标空间进行下一次查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowList</span><span class="params">()</span></span>;                                        <span class="comment">//交互显示</span></span><br><span class="line"><span class="function">BOOL <span class="title">WriteMemory</span><span class="params">(DWORD dwAddr, DWORD dwValue)</span></span>;          <span class="comment">//进行修改目标进程空间的值</span></span><br><span class="line"><span class="function">BOOL <span class="title">CompareAPage</span><span class="params">(DWORD dwBaseAddr, DWORD dwValue)</span> </span>;    <span class="comment">//以一页为单位暴力搜索</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//通过CreateProcesss创建Testor.exe进程，这样是可以访问它的进程空间</span></span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    ZeroMemory(&amp;si,<span class="keyword">sizeof</span>(si));</span><br><span class="line">    si.cb=<span class="keyword">sizeof</span>(si);</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    ZeroMemory(&amp;pi,<span class="keyword">sizeof</span>(pi));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!CreateProcess(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="string">&quot;02Testor.exe&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        FALSE,</span><br><span class="line">        CREATE_NEW_CONSOLE,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;si,</span><br><span class="line">        &amp;pi)</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建进程失败 (%lu).\n&quot;</span>,GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g_hProcess=pi.hProcess;<span class="comment">//将目标进程的句柄保存在全局变量中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收要查找的数值</span></span><br><span class="line">    <span class="keyword">int</span> iVal;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入您要修改的变量数值\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;iVal);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进行第一次查找</span></span><br><span class="line">    FindFirst(iVal);</span><br><span class="line">    <span class="comment">//交互显示</span></span><br><span class="line">    ShowList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(g_nListCnt&gt;<span class="number">1</span>)<span class="comment">//不止一处,则通过修改变量的值后再次查找，这样缩小范围直至唯一确定要修改的变量的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请再一次输入您要修改的变量的数值\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;iVal);</span><br><span class="line">        <span class="comment">//进行下一次查找</span></span><br><span class="line">        FindNext(iVal);</span><br><span class="line">        ShowList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提示用户输入希望修改为多少，进行修改</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;目标地址是%p\n&quot;</span>,g_arList[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入新数据:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;iVal);</span><br><span class="line">    <span class="comment">//修改数值</span></span><br><span class="line">    <span class="keyword">if</span>(WriteMemory(g_arList[<span class="number">0</span>],iVal))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;修改成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;修改失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close process and thread handles. </span></span><br><span class="line">    CloseHandle( pi.hProcess );</span><br><span class="line">    CloseHandle( pi.hThread );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CompareAPage</span><span class="params">(DWORD dwBaseAddr, DWORD dwValue)</span><span class="comment">//以一页为单位暴力搜索</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BYTE arBytes[<span class="number">4096</span>];             <span class="comment">//一页为4k</span></span><br><span class="line">    <span class="keyword">if</span>(!ReadProcessMemory(g_hProcess,(LPVOID)dwBaseAddr,arBytes,<span class="number">4096</span>,<span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;               <span class="comment">//此页不可读</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD *pdw;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)<span class="number">4</span>*<span class="number">1024</span><span class="number">-3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pdw=(DWORD*)&amp;arBytes[i];    <span class="comment">//一次读4个字节，即int类型</span></span><br><span class="line">        <span class="keyword">if</span>(pdw[<span class="number">0</span>]==dwValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g_nListCnt&gt;=<span class="number">1024</span>)    <span class="comment">//满了</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            <span class="comment">//添加到全局变量中</span></span><br><span class="line">            g_arList[g_nListCnt++]=dwBaseAddr+i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">FindFirst</span><span class="params">(DWORD dwValue)</span><span class="comment">//对目标进程空间进行查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> DWORD dwOneGB=<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>; <span class="comment">//1GB大小</span></span><br><span class="line">    <span class="keyword">const</span> DWORD dwOnePage=<span class="number">4</span>*<span class="number">1024</span>;       <span class="comment">//一页4k</span></span><br><span class="line">    <span class="keyword">if</span>(g_hProcess==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看操作系统类型，以决定开始地址</span></span><br><span class="line">    DWORD dwBase;</span><br><span class="line">    OSVERSIONINFO vi;</span><br><span class="line">    ZeroMemory(&amp;vi,<span class="keyword">sizeof</span>(vi));</span><br><span class="line">    </span><br><span class="line">    GetVersionEx(&amp;vi);</span><br><span class="line">    <span class="keyword">if</span>(vi.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS)</span><br><span class="line">    &#123;</span><br><span class="line">        dwBase=<span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;              <span class="comment">//Windows 98系列，4MB</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dwBase=<span class="number">640</span>*<span class="number">1024</span>;                 <span class="comment">//Windows NT系列，64KB</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在开始地址到2GB的地址空间进行查找</span></span><br><span class="line">    <span class="keyword">for</span>(;dwBase&lt;<span class="number">2</span>*dwOneGB;dwBase+=dwOnePage)</span><br><span class="line">    &#123;</span><br><span class="line">        CompareAPage(dwBase,dwValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">FindNext</span><span class="params">(DWORD dwValue)</span><span class="comment">//对目标空间进行下一次查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet=FALSE;<span class="comment">//假定查找失败</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存一下原来的有效地址的个数</span></span><br><span class="line">    <span class="keyword">int</span> nOrgCnt=g_nListCnt;</span><br><span class="line">    g_nListCnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    DWORD dwReadValue;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nOrgCnt;i++)<span class="comment">//从第一次查找中的有效地址中再进行再次查找，即缩小范围</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ReadProcessMemory(g_hProcess,(LPVOID)g_arList[i],&amp;dwReadValue,<span class="keyword">sizeof</span>(dwReadValue),<span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dwReadValue==dwValue)</span><br><span class="line">            &#123;</span><br><span class="line">                g_arList[g_nListCnt++] = g_arList[i];</span><br><span class="line">bRet = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowList</span><span class="params">()</span><span class="comment">//交互显示</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g_nListCnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,g_arList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">WriteMemory</span><span class="params">(DWORD dwAddr, DWORD dwValue)</span><span class="comment">//进行修改目标进程空间的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> WriteProcessMemory(g_hProcess,(LPVOID)dwAddr,&amp;dwValue,<span class="keyword">sizeof</span>(dwValue),<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><blockquote><p>VS code,测试程序的exe要与主程序exe同级目录，CreateProcess第二个参数先寻当前目录<img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211017211248097.png" alt="image-20211017211248097"></p></blockquote><blockquote><p>可能存在的问题：</p><p>Win10某些版本下进行实验会失败，现象为：修改器按数值搜地址，搜到的地址和Testor.exe运行显示的地址不一样。</p><p>是因为OS版本问题，而不是编码逻辑。</p><p>这里用的是一个版本通用的02Testor.exe，不会出现上述问题</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211017212129638.png" alt="image-20211017212129638"></p><h3 id="CreateMutex控制进程唯一性">CreateMutex控制进程唯一性</h3><blockquote><p>涉及：CreateMutex</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是一个进程\n&quot;</span>);</span><br><span class="line">    HANDLE hMutex=CreateMutex(<span class="literal">NULL</span>,TRUE,TEXT(<span class="string">&quot;ONE&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(GetLastError()==ERROR_ALREADY_EXISTS)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hMutex)</span><br><span class="line">        &#123;</span><br><span class="line">            CloseHandle(hMutex);<span class="comment">//主动关闭句柄尽早释放资源；也可以不关，让系统去释放</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MessageBox(<span class="number">0</span>,TEXT(<span class="string">&quot;已经有一个正在运行了&quot;</span>),TEXT(<span class="string">&quot; &quot;</span>),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();<span class="comment">//让进程保持</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211017215139668.png" alt="image-20211017215139668"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211017215145786.png" alt="image-20211017215145786"></p><h2 id="线程">线程</h2><p>我们可以把每个函数看成线程的载体，线程就是用来推进CPU执行的，CPU执行的就是指令序列，而指令序列就是一行一行的代码，我们通过编写函数来推进线程，我们把函数映射成一个线程,从而完成CPU的推进，完成程序的指令序列。</p><h3 id="创建线程Demo">创建线程Demo</h3><blockquote><p>涉及：CreateThread、回调函数ThreadProc</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParam)</span></span>;<span class="comment">//线程回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个线程</span></span><br><span class="line">    hThread=CreateThread(</span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">//默认安全属性</span></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">//默认堆栈</span></span><br><span class="line">        ThreadProc,          <span class="comment">//线程回调函数地址</span></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">//默认的线程参数</span></span><br><span class="line">        <span class="number">0</span>,                   <span class="comment">//线程立即执行（是指投入就绪队列而不是马上获得CPU使用权）</span></span><br><span class="line">        &amp;dwThreadId</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;俺创建了一个新线程，它的id是%lu\n&quot;</span>,dwThreadId);</span><br><span class="line"></span><br><span class="line">    getchar();              <span class="comment">//等待，显示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是来自一个线程的输出:%d\n&quot;</span>,i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211018144010144.png" alt="image-20211018144010144"></p><p>分析：</p><p>12~19行创建线程后，先执行的是20行的printf，然后才是线程回调函数。证明了线程创建后并不是马上获得CPU调度，而是投入就绪队列，等待OS分配调度。这里可以理解为总线程时间片到了，然后就运行子线程（我们写的线程回调函数）</p><h3 id="概念：线程内核对象">概念：线程内核对象</h3><p>线程内核对象就是一个包含了线程状态信息的数据结构。每次对CreateThread函数的成功调用，系统都会在内部为新的线程分配一个内核对象。系统提供的管理线程的函数就是依靠访问线程内核对象来管理实现的。</p><p><strong>线程内核对象结构</strong></p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows程序设计实例/image-20211018145718052.png" alt="image-20211018145718052" style="zoom: 50%;" /><p><strong>创建线程内核对象时，系统对它的各个成员进行初始化</strong></p><p><strong>1&gt; 线程上下文句柄</strong></p><p>每个线程都有自己的一组CPU寄存器，成为线程的上下文。这组寄存器的值保存在一个CONTEXT结构里，反映了该线程上次运行时CPU寄存器的状态。</p><p><strong>2&gt; 使用技术Usage Count</strong></p><p>该成员记录线程内核对象的使用次数。使用技术初始状态为2，创建一个线程时，因为CreateThread函数返回了线程内核对象的句柄，相当于打开一次，就促使Usage Count值加1。如果调用OpenThread函数，会再加1。</p><p>因此在使用完他们的句柄之后，一定要调用CloseHandle函数进行关闭。使Usage Count值减1.</p><p>如果在刚创建线程时调用CloseHandle函数关闭CreateThread函数返回的句柄，Usage Count值减为1，但线程没有被终止。线程结束要关闭句柄，不然内存泄漏。</p><p><strong>3&gt; 暂停次数 Suspend Count</strong></p><p>该成员用于指明线程的暂停计数。</p><p>DWORD ResumeThread(HANDLE hThread); // 唤醒挂起线程</p><p>DWORD SuspendThread(HANDLE hThread); // 挂起线程</p><p>上面两个函数用于减少或增加Suspend Count。</p><p>在相同优先级下，当Suspend Count变为0时，系统可以调度该线程。</p><p><strong>4&gt; 退出代码 Exit Code</strong></p><p>Exit Code指定线程的退出代码，也可以说是线程函数的返回值。在线程运行期间，线程函数没有返回，值为STILL_ACTIVE。当线程结束后，系统自动将ExitCode设为线程函数的返回值。可以用GetExitCodeThread函数得到线程的退出代码。</p><p><strong>5&gt; 是否受信 Signaled</strong></p><p>Signaled指示了线程对象是否为受信状态。运行期间FALSE，即未受信，线程结束后，系统将其置为TRUE，针对此对象的等待函数（如WaitForSingleObject）就会返回。</p><h3 id="概念：线程的终止">概念：线程的终止</h3><p>线程正常终止时，会发生以下时间：</p><p>在线程函数中创建的所有C++对象将通过他们各自的析构函数被正确的销毁。</p><p>该线程使用的堆栈被释放。</p><p>系统将线程内核对象中的ExitCode的值由STILL_ACTIVE设置为线程函数返回的值。</p><p>系统将递减线程内核对象中Usage Count的值。</p><p><strong>线程终止的四种方法</strong></p><p>1、线程函数自然退出。（右花括号）</p><p>2、使用ExitThread函数来终止线程。</p><p>3、使用TeriminateThread函数在一个线程中强制终止另一个线程的运行。</p><p>4、使用ExitProcess函数结束进程。</p><p>线程自然退出这种情况是最安全的，但是其他三种方式（2、3、4）会存在一个问题，ExitThread、TeriminateThread、ExitProcess为C风格的Win32函数，不会调用C++的运行时，即在释放资源的时候，析构函数不会被执行。</p><p><a href="#C++%E8%B5%84%E6%BA%90%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98">具体实例：进程-终止进程-C++资源泄露问题</a></p><h3 id="低优先级的线程为什么会被先执行">低优先级的线程为什么会被先执行</h3><blockquote><p>涉及：CreateThread、线程回调函数、SetThreadPriority、ResumeThread、WaitForMultipleObjects</p></blockquote><p><strong>一、线程的优先级</strong><br>线程的优先级范围从0（最低）到31（最高）。当你产生线程时，并不是直接以数值制定某优先级，而是采用两个步骤。</p><p>第一个步骤是指定“优先级等级（Priority Class）”给进程</p><p>第二步骤是指定“相对优先级”给该进行的所有线程。</p><p>其中的代码在CreateProcess的dwCreationFlags参数中指定。如果你不指定，系统默认给的是NORMAL_PRIORITY_CLASS,除非父进程是IDLE_PRIORITY_CLASS(那么子进程也会是IDLE_PRIORITY_CLASS)。</p><p>要改变线程的优先级，用如下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetThreadPriority</span><span class="params">(HANDLE hThread,<span class="keyword">int</span> nPriority)</span></span></span><br></pre></td></tr></table></figure><p><strong>二、线程的优先级值</strong><br>查看API档案</p><p><strong>三、例子PriorityDemo</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程回调函数，自定义低优先级的</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadIdle</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) </span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Idle线程正在运行%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程回调函数，自定义高优先级的</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadNormal</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Normal线程正在运行%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwThreadId[<span class="number">2</span>];</span><br><span class="line">    HANDLE h[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个线程，置其状态为挂起状态</span></span><br><span class="line">    h[<span class="number">0</span>]=CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,ThreadIdle,<span class="literal">NULL</span>,CREATE_SUSPENDED,&amp;dwThreadId[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//CREATE__SUSPENDED</span></span><br><span class="line">    <span class="comment">//The thread is created in a suspended state, </span></span><br><span class="line">    <span class="comment">//and does not run until the ResumeThread function is called.</span></span><br><span class="line">    SetThreadPriority(h[<span class="number">0</span>],THREAD_BASE_PRIORITY_IDLE);<span class="comment">//设置为低优先级</span></span><br><span class="line">    ResumeThread(h[<span class="number">0</span>]);<span class="comment">//投入就绪队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个级别为Normal的线程</span></span><br><span class="line">    h[<span class="number">1</span>]=CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,ThreadNormal,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;dwThreadId[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//0,立即仅需就绪队列</span></span><br><span class="line"></span><br><span class="line">    WaitForMultipleObjects(</span><br><span class="line">        <span class="number">2</span>,          <span class="comment">//表示我们要等待的线程的内核对象的数量</span></span><br><span class="line">        h,          <span class="comment">//句柄数组</span></span><br><span class="line">        TRUE,       <span class="comment">//表示我们要等待的线程的内核对象的数量，只有都完成才结束</span></span><br><span class="line">        INFINITE    <span class="comment">//等待时间为无限长</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    getchar();      <span class="comment">//等待，显示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&gt; 运行：</p><p>第一次：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211018194051793.png" alt="image-20211018194051793"></p><p>第二次：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211018194152535.png" alt="image-20211018194152535"></p><p>&gt; 现象：Nromal线程并不一定先于Idle线程先运行</p><p>&gt; 分析：</p><p>这里的优先级是<strong>相对优先级</strong>的概念。</p><p><strong>原因一：操作系统也考虑到了公平性与效率性的问题。</strong></p><p>操作系统中有个很重要的思想，那就是尽可能地使CPU忙碌，提高利用率。</p><p>其中有种算法叫短作业优先，耗时短的作业先获得CPU调度权，那么在所有任务完毕时，所有作业的平均等待时间最短。但，有个缺点，有可能导致长作业饥饿，长作业每次还没来得及运行前又来了一个比它运行时间短的作业，这会造成不公平。</p><p>在Windows系统中，有考虑过这种问题，所有我们的优先级并不是绝对优先级。在绝大多数情况下用户态的优先级都是相对的，调度次序还是由操作系统进行调度，那么就会出现Normal优先级与Idle优先并不是严格的按照高优先级先运行，低优先后运行。</p><p><strong>原因二：现在的OS大多是多核系统</strong></p><p>假定这里有A核和B核，主线程可能和Idle线程在A核中，Normal线程分发到B核中，B核还在排队，A核是空闲，所以会出现Idle线程先于Normal线程运行的现象。</p><p>&gt; 总结：</p><p><strong>优先级只是一个相对的概念，不要想当然的认为高优先级的线程一定会先于低优先级的线程调用。</strong></p><h3 id="操作系统乱序推进线程指令的本质剖析">操作系统乱序推进线程指令的本质剖析</h3><blockquote><p>涉及：_beginthreadex、WaitForMultipleObjects、CloseHandle</p></blockquote><p><strong>C/C++运行期库</strong><br><strong>一、概念</strong></p><p>在实际的开发过程中，一般使用C/C++运行期函数_beginthreadex代替CreateThread函数。</p><p>_beginthreadex首先申请一些用于线程同步的变量，然后调用CreateThread</p><p>需要用#include &lt;process.h&gt;头文件</p><p>同样，使用_endthreadex代替ExitThread。该函数首先释放用于线程同步的变量，再调用ExitThread。<br>二、例子CountErr</p><blockquote><p>VS2019</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> g_Cnt=<span class="number">0</span>;      <span class="comment">//线程都共享进程空间中的资源，全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line">BOOL bFlag=FALSE; <span class="comment">//全局，常用这种方式用来在线程之间通信;工程上常用的方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT uId[<span class="number">2</span>];</span><br><span class="line">    HANDLE h[<span class="number">2</span>];</span><br><span class="line">    h[<span class="number">0</span>]=(HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId[<span class="number">0</span>]);</span><br><span class="line">    h[<span class="number">1</span>]=(HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId[<span class="number">1</span>]);</span><br><span class="line">    bFlag=TRUE;<span class="comment">//创建完两个线程后，标量标志设为TRUE，表示可以执行了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主线程休息1000ms，让出CPU的使用权，让我们的辅助线程运行</span></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    bFlag=FALSE;<span class="comment">//不让辅助线程执行，主线程恢复执行</span></span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>,h,TRUE,INFINITE);</span><br><span class="line">    <span class="comment">//关闭句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(h[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(h[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_Cnt=%d\n&quot;</span>,g_Cnt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的编程的重点：与时间有关的错误</span></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID lpParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span> (bFlag) </span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">g_Cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g_Cnt++对应三条汇编指令</span></span><br><span class="line"><span class="comment">//mov eax,g_Cnt</span></span><br><span class="line"><span class="comment">//add eax,1</span></span><br><span class="line"><span class="comment">//mov g_Cnt,eax</span></span><br><span class="line"><span class="comment">//线程乱序推进导致结果不可预料，并不是g_Cnt=2000</span></span><br></pre></td></tr></table></figure><p>&gt; 运行：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211018201549696.png" alt="image-20211018201549696"><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211018201620382.png" alt="image-20211018201620382"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211018201712334.png" alt="image-20211018201712334"></p><p>2000才是正确答案，主线程休息1000ms，副线程A和副线程B各让g_Cnt加1000，就是两千。而多次运行，大多数情况都不是正确的2000</p><p>&gt; 原因：</p><p>你以为的<code>g_Cnt++</code>是不可分割的一条指令，实际在汇编层面是三条指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,g_cnt</span><br><span class="line">add eax,1</span><br><span class="line">mov g_cont,eax</span><br></pre></td></tr></table></figure><p>线程A和线程B都是这三条指令</p><p>在线程调度中，由于异步性，导致这三条指令不是一次性顺序执行完，反而是乱序推进，所以g_Cnt结果是无法预料的，而不是我们想象的2000</p><blockquote><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211018202723593.png" alt="image-20211018202723593"></p><p>假定g_Cnt当前值为100</p><p>线程1中：g_Cnt被传送到eax寄存器中，此时eax的值变为100，然后将100与1相加存放在eax中，eax的值变为101</p><p>假定这个时候线程1被打断了，开始执行线程2</p><p>现在g_Cnt的值在线程1中还未被修改，所以g_Cnt的值还是100</p><p>在线程2中从g_Cnt的值读到eax中，所以eax的值从101变为100了。（已经发生错误了）</p><p>所以只要运行过中被打断，g_Cnt的结果是无法预料的。</p></blockquote><p>这就引出后边的内容，临界区、同步、异步等知识</p><h3 id="线程临界区管理">线程临界区管理</h3><p>这里讲两种方法控制临界区，一个临界区锁，一个互锁函数。</p><hr><p>临界变量：全局变量对全进程空间可见，任何一个线程都有可能访问它</p><p>临界区：访问临界资源的代码段</p><p>通过对访问代码段进行控制，就控制了对临界变量的访问过程</p><h4 id="临界区对象和临界区锁">临界区对象和临界区锁</h4><p>临界区对象是定义在数据段中的一个CRITICAL_SECTION结构，Windows内部使用这个结构记录一些同步信息，确保在同一段时间只有一个线程访问数据段中的数据。</p><p>相关函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化临界区对象资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeCriticalSection</span><span class="params">(LPCRITICAL_SECTION lpCriticalSection)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 进入临界区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnterCriticalSection</span><span class="params">(LPCRITICAL_SECTION lpCriticalSection)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 离开临界区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeaveCriticalSection</span><span class="params">(LPCRITICAL_SECTION lpCriticalSection)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 删除临界区对象资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteCriticalSection</span><span class="params">(LPCRITICAL_SECTION lpCriticalSection)</span></span>;</span><br></pre></td></tr></table></figure><p>函数参数lpCriticalSection为指向临界区源的对象</p><p><strong>例子</strong></p><blockquote><p>VS2019</p></blockquote><blockquote><p>涉及：四个临界区锁函数</p></blockquote><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">diff</button></li><li class="tab"><button type="button" data-href="#test1-2">完整程序</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;process.h&gt;</span><br><span class="line">  </span><br><span class="line">int g_Cnt=0;//线程都共享进程空间中的资源，全局变量</span><br><span class="line"></span><br><span class="line"><span class="addition">+ CRITICAL_SECTION g_cs;// 临界区对象</span></span><br><span class="line"></span><br><span class="line">UINT __stdcall ThreadFunc(LPVOID);</span><br><span class="line">BOOL bFlag=FALSE;//全局，常用这种方式用来在线程之间通信;工程上常用的方法</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    UINT uId[2];</span><br><span class="line">    HANDLE h[2];</span><br><span class="line"></span><br><span class="line"><span class="addition">+::InitializeCriticalSection(&amp;g_cs);  // 初始化临界区资源</span></span><br><span class="line">    </span><br><span class="line">    h[0]=(HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId[0]);</span><br><span class="line">    h[1]=(HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId[1]);</span><br><span class="line">    bFlag=TRUE;//创建完两个线程后，标量标志设为TRUE，表示可以执行了</span><br><span class="line">    </span><br><span class="line">    //主线程休息1000ms，让出CPU的使用权，让我们的辅助线程运行</span><br><span class="line">    Sleep(1000);</span><br><span class="line"></span><br><span class="line">    bFlag=FALSE;//不让辅助线程执行，主线程恢复执行</span><br><span class="line"></span><br><span class="line">    ::WaitForMultipleObjects(2,h,TRUE,INFINITE);</span><br><span class="line">    //关闭句柄</span><br><span class="line">    CloseHandle(h[0]);</span><br><span class="line">    CloseHandle(h[1]);</span><br><span class="line">        </span><br><span class="line"><span class="addition">+::DeleteCriticalSection(&amp;g_cs);  //删除临界区资源</span></span><br><span class="line"></span><br><span class="line">    printf(&quot;g_Cnt=%d\n&quot;,g_Cnt);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程的编程的重点：与时间有关的错误</span><br><span class="line">UINT __stdcall ThreadFunc(LPVOID lpParam) </span><br><span class="line">&#123; </span><br><span class="line">if (bFlag) </span><br><span class="line">    &#123;</span><br><span class="line"><span class="addition">+::EnterCriticalSection(&amp;g_cs);//进入临界区</span></span><br><span class="line">for(int i =0;i&lt;1000;i++)</span><br><span class="line">g_Cnt++;</span><br><span class="line"><span class="addition">+       ::LeaveCriticalSection(&amp;g_cs);//离开临界区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> g_Cnt=<span class="number">0</span>;<span class="comment">//线程都共享进程空间中的资源，全局变量</span></span><br><span class="line"></span><br><span class="line">CRITICAL_SECTION g_cs;<span class="comment">// 临界区对象</span></span><br><span class="line"></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line">BOOL bFlag=FALSE;<span class="comment">//全局，常用这种方式用来在线程之间通信;工程上常用的方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT uId[<span class="number">2</span>];</span><br><span class="line">    HANDLE h[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">::<span class="built_in">InitializeCriticalSection</span>(&amp;g_cs);  <span class="comment">// 初始化临界区资源</span></span><br><span class="line">    </span><br><span class="line">    h[<span class="number">0</span>]=(HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId[<span class="number">0</span>]);</span><br><span class="line">    h[<span class="number">1</span>]=(HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId[<span class="number">1</span>]);</span><br><span class="line">    bFlag=TRUE;<span class="comment">//创建完两个线程后，标量标志设为TRUE，表示可以执行了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主线程休息1000ms，让出CPU的使用权，让我们的辅助线程运行</span></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    bFlag=FALSE;<span class="comment">//不让辅助线程执行，主线程恢复执行</span></span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>,h,TRUE,INFINITE);</span><br><span class="line">    <span class="comment">//关闭句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(h[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(h[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">::<span class="built_in">DeleteCriticalSection</span>(&amp;g_cs);  <span class="comment">//删除临界区资源</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_Cnt=%d\n&quot;</span>,g_Cnt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的编程的重点：与时间有关的错误</span></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID lpParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span> (bFlag) </span><br><span class="line">    &#123;</span><br><span class="line">::<span class="built_in">EnterCriticalSection</span>(&amp;g_cs);<span class="comment">//进入临界区</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">g_Cnt++;</span><br><span class="line">        ::<span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);<span class="comment">//离开临界区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>&gt; 运行：<img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211018215504328.png" alt="image-20211018215504328"></p><p>对的，多次运行都是2000。</p><p>临界区对象能很好的保护共享数据，但是它不能够用于进程之间资源的锁定，因为它不是内核对象，如果要在进程间维持线程的同步，可以使用事件内核对象。</p><h4 id="互锁函数-2">互锁函数</h4><p>互锁函数为同步访问多线程共享变量提供了一个简单的机制。</p><p>如果变量在共享内存，不同进程的线程也可以使用此机制。</p><p>互锁函数包括：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子自加操作</span></span><br><span class="line">InterlockedIncrement</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 原子自减操作</span></span><br><span class="line">InterlockedDecrement</span><br><span class="line"> </span><br><span class="line">InterlockedExchangeAdd</span><br><span class="line"> </span><br><span class="line">InterlockedExchangePointer</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><blockquote><p>涉及：互锁的四个函数</p></blockquote><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">diff</button></li><li class="tab"><button type="button" data-href="#test4-2">完整程序</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;process.h&gt;</span><br><span class="line">  </span><br><span class="line">int g_Cnt=0;//线程都共享进程空间中的资源，全局变量</span><br><span class="line">BOOL bFlag=FALSE;//全局，常用这种方式用来在线程之间通信;工程上常用的方法</span><br><span class="line">UINT __stdcall ThreadFunc(LPVOID);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    UINT uId[2];</span><br><span class="line">    HANDLE h[2];</span><br><span class="line">    </span><br><span class="line">    h[0]=(HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId[0]);</span><br><span class="line">    h[1]=(HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId[1]);</span><br><span class="line">    bFlag=TRUE;//创建完两个线程后，标量标志设为TRUE，表示可以执行了</span><br><span class="line">    </span><br><span class="line">    //主线程休息1000ms，让出CPU的使用权，让我们的辅助线程运行</span><br><span class="line">    Sleep(1000);</span><br><span class="line"></span><br><span class="line">    bFlag=FALSE;//不让辅助线程执行，主线程恢复执行</span><br><span class="line"></span><br><span class="line">    ::WaitForMultipleObjects(2,h,TRUE,INFINITE);</span><br><span class="line">    //关闭句柄</span><br><span class="line">    CloseHandle(h[0]);</span><br><span class="line">    CloseHandle(h[1]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;g_Cnt=%d\n&quot;,g_Cnt);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程的编程的重点：与时间有关的错误</span><br><span class="line">UINT __stdcall ThreadFunc(LPVOID lpParam) </span><br><span class="line">&#123; </span><br><span class="line">if (bFlag) </span><br><span class="line">    &#123;</span><br><span class="line">for(int i =0;i&lt;1000;i++)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="deletion">-g_Cnt++;</span></span><br><span class="line"><span class="addition">+            //原子自加操作，不会被中断</span></span><br><span class="line"><span class="addition">+           :: InterlockedIncrement((long *)&amp;g_Cnt);</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> g_Cnt=<span class="number">0</span>;<span class="comment">//线程都共享进程空间中的资源，全局变量</span></span><br><span class="line">BOOL bFlag=FALSE;<span class="comment">//全局，常用这种方式用来在线程之间通信;工程上常用的方法</span></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT uId[<span class="number">2</span>];</span><br><span class="line">    HANDLE h[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    h[<span class="number">0</span>]=(HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId[<span class="number">0</span>]);</span><br><span class="line">    h[<span class="number">1</span>]=(HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId[<span class="number">1</span>]);</span><br><span class="line">    bFlag=TRUE;<span class="comment">//创建完两个线程后，标量标志设为TRUE，表示可以执行了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主线程休息1000ms，让出CPU的使用权，让我们的辅助线程运行</span></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    bFlag=FALSE;<span class="comment">//不让辅助线程执行，主线程恢复执行</span></span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>,h,TRUE,INFINITE);</span><br><span class="line">    <span class="comment">//关闭句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(h[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(h[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_Cnt=%d\n&quot;</span>,g_Cnt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的编程的重点：与时间有关的错误</span></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID lpParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span> (bFlag) </span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//原子自加操作，不会被中断</span></span><br><span class="line">            ::<span class="built_in">InterlockedIncrement</span>((<span class="keyword">long</span> *)&amp;g_Cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>运行：</p><p>结果对的，是2000</p><p>通过本节的学习，我们知道了如何控制关键的代码段不被系统打断，可以通过临界区或者互锁函数来实现关键代码段不被系统打断，可以保证数据得出正确的结果！</p><h4 id="锁的代价和对比">锁的代价和对比</h4><blockquote><p>VS2019</p></blockquote><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">源程序</button></li><li class="tab"><button type="button" data-href="#test1-2">临界区锁-diff</button></li><li class="tab"><button type="button" data-href="#test1-3">临界区锁-完整</button></li><li class="tab"><button type="button" data-href="#test1-4">互锁函数-diff</button></li><li class="tab"><button type="button" data-href="#test1-5">互锁函数-完整</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_Cnt_1 = <span class="number">0</span>;<span class="comment">//计数器1</span></span><br><span class="line"><span class="keyword">int</span> g_Cnt_2 = <span class="number">0</span>;<span class="comment">//计数器2</span></span><br><span class="line">BOOL bFlag = FALSE;<span class="comment">//全局，常用这种方式用来在线程之间通信;工程上常用的方法</span></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT uId[<span class="number">2</span>];</span><br><span class="line">    HANDLE h[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    h[<span class="number">0</span>] = (HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId[<span class="number">0</span>]);</span><br><span class="line">    h[<span class="number">1</span>] = (HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId[<span class="number">1</span>]);</span><br><span class="line">    bFlag = TRUE;<span class="comment">//创建完两个线程后，标量标志设为TRUE，表示可以执行了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程休息1000ms，让出CPU的使用权，让我们的辅助线程运行</span></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    bFlag = FALSE;<span class="comment">//不让辅助线程执行，主线程恢复执行</span></span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, h, TRUE, INFINITE);</span><br><span class="line">    <span class="comment">//关闭句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(h[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(h[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_Cnt_1 = %d,g_Cnt_2 = %d\n&quot;</span>, g_Cnt_1, g_Cnt_2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的编程的重点：与时间有关的错误</span></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (bFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        g_Cnt_1++;</span><br><span class="line">        g_Cnt_2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;process.h&gt;</span><br><span class="line">  </span><br><span class="line">int g_Cnt_1=0;//线程都共享进程空间中的资源，全局变量</span><br><span class="line">int g_Cnt_2=0;//计数器2</span><br><span class="line">BOOL bFlag=FALSE;//全局，常用这种方式用来在线程之间通信;工程上常用的方法</span><br><span class="line"><span class="addition">+ CRITICAL_SECTION g_cs;</span></span><br><span class="line"></span><br><span class="line">UINT __stdcall ThreadFunc(LPVOID);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    UINT uId[2];</span><br><span class="line">    HANDLE h[2];</span><br><span class="line">    </span><br><span class="line"><span class="addition">+   ::InitializeCriticalSection(&amp;g_cs);</span></span><br><span class="line">    h[0]=(HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId[0]);</span><br><span class="line">    h[1]=(HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId[1]);</span><br><span class="line">    bFlag=TRUE;//创建完两个线程后，标量标志设为TRUE，表示可以执行了</span><br><span class="line">    </span><br><span class="line">    //主线程休息1000ms，让出CPU的使用权，让我们的辅助线程运行</span><br><span class="line">    Sleep(1000);</span><br><span class="line"></span><br><span class="line">    bFlag=FALSE;//不让辅助线程执行，主线程恢复执行</span><br><span class="line"></span><br><span class="line">    ::WaitForMultipleObjects(2,h,TRUE,INFINITE);</span><br><span class="line">    //关闭句柄</span><br><span class="line">    CloseHandle(h[0]);</span><br><span class="line">    CloseHandle(h[1]);</span><br><span class="line"></span><br><span class="line"><span class="addition">+   ::DeleteCriticalSection(&amp;g_cs);</span></span><br><span class="line">printf(&quot;g_Cnt_1 = %d,g_Cnt_2 = %d\n&quot;, g_Cnt_1, g_Cnt_2);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程的编程的重点：与时间有关的错误</span><br><span class="line">UINT __stdcall ThreadFunc(LPVOID lpParam) </span><br><span class="line">&#123; </span><br><span class="line">while (bFlag) </span><br><span class="line">    &#123;</span><br><span class="line"><span class="addition">+       ::EnterCriticalSection(&amp;g_cs); </span></span><br><span class="line">        g_Cnt_1++;</span><br><span class="line">        g_Cnt_2++;</span><br><span class="line"><span class="addition">+       ::LeaveCriticalSection(&amp;g_cs);        </span></span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_Cnt_1 = <span class="number">0</span>;<span class="comment">//线程都共享进程空间中的资源，全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_Cnt_2 = <span class="number">0</span>;<span class="comment">//计数器2</span></span><br><span class="line">BOOL bFlag = FALSE;<span class="comment">//全局，常用这种方式用来在线程之间通信;工程上常用的方法</span></span><br><span class="line">CRITICAL_SECTION g_cs;</span><br><span class="line"></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT uId[<span class="number">2</span>];</span><br><span class="line">    HANDLE h[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">InitializeCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    h[<span class="number">0</span>] = (HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId[<span class="number">0</span>]);</span><br><span class="line">    h[<span class="number">1</span>] = (HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId[<span class="number">1</span>]);</span><br><span class="line">    bFlag = TRUE;<span class="comment">//创建完两个线程后，标量标志设为TRUE，表示可以执行了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程休息1000ms，让出CPU的使用权，让我们的辅助线程运行</span></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    bFlag = FALSE;<span class="comment">//不让辅助线程执行，主线程恢复执行</span></span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, h, TRUE, INFINITE);</span><br><span class="line">    <span class="comment">//关闭句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(h[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(h[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">DeleteCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_Cnt_1 = %d,g_Cnt_2 = %d\n&quot;</span>, g_Cnt_1, g_Cnt_2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的编程的重点：与时间有关的错误</span></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (bFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        ::<span class="built_in">EnterCriticalSection</span>(&amp;g_cs);</span><br><span class="line">        g_Cnt_1++;</span><br><span class="line">        g_Cnt_2++;</span><br><span class="line">        ::<span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;process.h&gt;</span><br><span class="line"></span><br><span class="line">int g_Cnt_1 = 0;//线程都共享进程空间中的资源，全局变量</span><br><span class="line">int g_Cnt_2 = 0;//计数器2</span><br><span class="line">BOOL bFlag = FALSE;//全局，常用这种方式用来在线程之间通信;工程上常用的方法</span><br><span class="line"></span><br><span class="line">UINT __stdcall ThreadFunc(LPVOID);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    UINT uId[2];</span><br><span class="line">    HANDLE h[2];</span><br><span class="line"></span><br><span class="line">    h[0] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId[0]);</span><br><span class="line">    h[1] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId[1]);</span><br><span class="line">    bFlag = TRUE;//创建完两个线程后，标量标志设为TRUE，表示可以执行了</span><br><span class="line"></span><br><span class="line">    //主线程休息1000ms，让出CPU的使用权，让我们的辅助线程运行</span><br><span class="line">    Sleep(1000);</span><br><span class="line"></span><br><span class="line">    bFlag = FALSE;//不让辅助线程执行，主线程恢复执行</span><br><span class="line"></span><br><span class="line">    ::WaitForMultipleObjects(2, h, TRUE, INFINITE);</span><br><span class="line">    //关闭句柄</span><br><span class="line">    CloseHandle(h[0]);</span><br><span class="line">    CloseHandle(h[1]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;g_Cnt_1 = %d,g_Cnt_2 = %d\n&quot;, g_Cnt_1, g_Cnt_2);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程的编程的重点：与时间有关的错误</span><br><span class="line">UINT __stdcall ThreadFunc(LPVOID lpParam)</span><br><span class="line">&#123;</span><br><span class="line">    while (bFlag)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="deletion">-       g_Cnt_1++;</span></span><br><span class="line"><span class="deletion">-       g_Cnt_2++;</span></span><br><span class="line"><span class="addition">+       ::InterlockedIncrement((long*)&amp;g_Cnt_1);</span></span><br><span class="line"><span class="addition">+       ::InterlockedIncrement((long*)&amp;g_Cnt_2);</span></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_Cnt_1 = <span class="number">0</span>;<span class="comment">//线程都共享进程空间中的资源，全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_Cnt_2 = <span class="number">0</span>;<span class="comment">//计数器2</span></span><br><span class="line">BOOL bFlag = FALSE;<span class="comment">//全局，常用这种方式用来在线程之间通信;工程上常用的方法</span></span><br><span class="line"></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT uId[<span class="number">2</span>];</span><br><span class="line">    HANDLE h[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    h[<span class="number">0</span>] = (HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId[<span class="number">0</span>]);</span><br><span class="line">    h[<span class="number">1</span>] = (HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId[<span class="number">1</span>]);</span><br><span class="line">    bFlag = TRUE;<span class="comment">//创建完两个线程后，标量标志设为TRUE，表示可以执行了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程休息1000ms，让出CPU的使用权，让我们的辅助线程运行</span></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    bFlag = FALSE;<span class="comment">//不让辅助线程执行，主线程恢复执行</span></span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, h, TRUE, INFINITE);</span><br><span class="line">    <span class="comment">//关闭句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(h[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(h[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_Cnt_1 = %d,g_Cnt_2 = %d\n&quot;</span>, g_Cnt_1, g_Cnt_2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的编程的重点：与时间有关的错误</span></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (bFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        ::<span class="built_in">InterlockedIncrement</span>((<span class="keyword">long</span>*)&amp;g_Cnt_1);</span><br><span class="line">        ::<span class="built_in">InterlockedIncrement</span>((<span class="keyword">long</span>*)&amp;g_Cnt_2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>&gt; 运行结果：</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">源程序</button></li><li class="tab"><button type="button" data-href="#test1-2">临界区锁</button></li><li class="tab"><button type="button" data-href="#test1-3">互锁函数</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211019102137723.png" alt="image-20211019102137723"></p><p>因为多线程乱序推进，切来切去，两个g_Cnt值不一样，结果不可预料</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211019102844270.png" alt="image-20211019102844270"></p><p>值一样；且比源程序的低</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211019103408828.png" alt="image-20211019103408828"></p><p>值一样；且比源程序的低</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>&gt; 分析：</p><ol><li>加锁，保证了逻辑上的准确性，但是会降低并发性（值变小了）</li><li>互锁函数量级比临界区函数要小（体现在互锁函数的值比临界区锁的大）</li><li>保证逻辑准确性和并发性，二者不可兼得，是种取舍</li></ol><h3 id="信号量同步-2">信号量同步</h3><p><strong>一、线程同步</strong></p><p>1&gt; 线程同步</p><p>多线程程序设计大多会涉及线程间相互通信。主线程在创建工作线程以后，工作线程之间还需要通过通信机制来协同工作。一种比较好的方法就是使用事件内核对象。</p><p>事件内核对象是一种用于多线程同步和他们之间的通信手段。</p><p>同步可以保证在一个时间内只有一个线程对某个共享资源有控制权。</p><p>2&gt; 汽车东西走向与南北走向协调的问题</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211019172241781.png" alt="image-20211019172241781"></p><p><strong>二、时间内核对象</strong></p><p>1&gt; 事件内核对象</p><p>事件内核对象是一种抽象的对象，它也有未受信和受信两种状态，可以使用WaitForSingleObject函数等待其变成受信状态。不同于其他内核对象的一些函数可以使实践对象在这两种状态之间转换。可以把时间对象看成是一个设置在Windows内部的一个标志。它的状态设置和测试工作由Windows来完成。</p><p>时间对象包含3个成员：</p><p>nUsageCount:使用计数</p><p>bManualReset：是否人工重置</p><p>bSignaled:是否受信</p><p>2&gt; 基本函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用CreateEvent函数创建事件对象：</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpEventAttributes,<span class="comment">//用来定义事件对象的安全属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bManualReset,                      <span class="comment">//指定是否需要手工重置事件对象为受信状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bInitialState,                     <span class="comment">//指定事件对象创建时的初始状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR lpName                          <span class="comment">//事件对象的名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;                          </span><br><span class="line"> </span><br><span class="line"><span class="comment">//根据lpName对象的名字查询，返回事件对象句柄：</span></span><br><span class="line"><span class="function">HANDLE <span class="title">OpenEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwDesiredAccess,    <span class="comment">//指定想要的访问权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bInheritHandle,      <span class="comment">//指定返回句柄是否被继承</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR lpName            <span class="comment">//要打开的事件对象的名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;                        </span><br><span class="line"> </span><br><span class="line"><span class="function">BOOL <span class="title">SetEvent</span><span class="params">(HANDLE hEvent)</span></span>;     <span class="comment">//将事件状态设置为受信状态</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReSetEvent</span><span class="params">(HANDLE hEvent)</span></span>;   <span class="comment">//将事件状态设置为未受信状态</span></span><br></pre></td></tr></table></figure><p><strong>三、实例</strong></p><blockquote><p>涉及：四个Event函数、WaitForSingleObject</p></blockquote><p>多线程同步，实现两个线程交互打印A、B</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE g_hEventEW,g_hEventNS;<span class="comment">//全局变量，两个线程回调函数都能看到</span></span><br><span class="line"><span class="comment">//EW：东西向</span></span><br><span class="line"><span class="comment">//NS：南北向</span></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ProcessA</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        WaitForSingleObject(g_hEventEW, INFINITE);<span class="comment">//等EW东西向的灯亮了才往下执行</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        SetEvent(g_hEventNS);<span class="comment">//使用完了</span></span><br><span class="line">        </span><br><span class="line">        Sleep(<span class="number">1000</span>);<span class="comment">//方便观察</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UINT __stdcall <span class="title">ProcessB</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        WaitForSingleObject(g_hEventNS, INFINITE);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SetEvent(g_hEventEW);</span><br><span class="line"></span><br><span class="line">        Sleep(<span class="number">1000</span>);<span class="comment">//方便观察</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE h[<span class="number">2</span>];</span><br><span class="line">    h[<span class="number">0</span>]=(HANDLE)_beginthreadex(<span class="literal">NULL</span>,<span class="number">0</span>,ProcessA,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    h[<span class="number">1</span>]=(HANDLE)_beginthreadex(<span class="literal">NULL</span>,<span class="number">0</span>,ProcessB,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//问题1：主线程如何调度A，B两个线程？</span></span><br><span class="line">g_hEventEW = CreateEvent(<span class="literal">NULL</span>, FALSE, TRUE, <span class="literal">NULL</span>);<span class="comment">//第三个参数TRUE，先启动，置为受信状态</span></span><br><span class="line">g_hEventNS = CreateEvent(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);<span class="comment">//第三个参数，这个就FALSE，未受信</span></span><br><span class="line"></span><br><span class="line">WaitForMultipleObjects(<span class="number">2</span>, h, TRUE, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//问题2：A、B如何交互打印</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&gt; 运行：<img src= "/img/loading.gif" data-lazy-src="/Typora_images/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/image-20211019171154459.png" alt="image-20211019171154459"></p><p>现象：A、B交替打印</p>]]></content>
      
      
      <categories>
          
          <category> Windows安全 </category>
          
          <category> 编程篇 </category>
          
          <category> win api </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIN32 API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly主题美化和魔改记录</title>
      <link href="/posts/2d6503ba.html"/>
      <url>/posts/2d6503ba.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>搭一个基本的博客其实很快，但最坑最耗时间的是美化，对于美的追求和渴望是永无止境的。</p><p>一开始建博客也只是想要有：带动态目录，代码块可复制、折叠展开的，能搜索文章内容方便找笔记，仅此而已😂。然后不知怎地就变成故事书了。</p><p>记录一下美化和魔改历程，一是防止玩崩版本升级找不到回家的路，二是给新建博客想美化的朋友一点参考。</p><h2 id="参考的博客">参考的博客</h2><p>通过友链查看了较多伙伴的博客，会点CSS、html、JS真的做的很漂亮，有空我也学一下逃:)</p><p>简约大气：</p><ul><li>Heo老师：<a href="https://blog.zhheo.com/">https://blog.zhheo.com/</a></li></ul><p>仿Heo老师的😂：</p><ul><li>realwds’s blog：<a href="https://blog.realwds.com">https://blog.realwds.com</a></li><li>MJ：<a href="https://blog.justlovesmile.top">https://blog.justlovesmile.top</a></li></ul><p>虽说店长博客里有很多教程，但真的样式多了，给我的感觉比较花：</p><ul><li>店长：<a href="https://akilar.top/">https://akilar.top/</a></li></ul><p>渐变色：</p><ul><li>小雨：<a href="https://ranas.cn/%EF%BC%88%E7%99%BD%E5%BA%95%E5%AD%97%EF%BC%8C%E6%95%B4%E4%BD%93%E9%A3%8E%E6%A0%BC%E5%BE%88%E8%88%92%E9%80%82cute%EF%BC%89">https://ranas.cn/（白底字，整体风格很舒适cute）</a></li><li>小嘉：<a href="https://blog.imzjw.cn">https://blog.imzjw.cn</a></li><li>Sianx：<a href="https://sianx.com">https://sianx.com</a></li></ul><p>橙色调：</p><ul><li>小N同学：<a href="https://www.nesxc.com/%EF%BC%88%E5%8A%A0%E6%B5%AE%E5%8A%A8%E5%8A%A8%E7%94%BB%E5%BE%88%E5%B7%B4%E9%80%82%EF%BC%89">https://www.nesxc.com/（加浮动动画很巴适）</a></li><li>贰猹的小窝：<a href="https://noionion.top/%EF%BC%88%E5%AD%97%E4%BD%93%E8%AE%A9%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%A2%E4%B8%A2%E8%B4%B9%E5%8A%B2%EF%BC%89">https://noionion.top/（字体让我有一丢丢费劲）</a></li></ul><p>风格、整体调色好：</p><ul><li>Hassan：<a href="https://hassanwong.top">https://hassanwong.top</a></li></ul><p>变化不大：</p><ul><li><p>小冰：<a href="https://zfe.one">https://zfe.one</a>（其实没怎么美化，但是大佬有很多插件😂）</p></li><li><p>Eurkon：<a href="https://blog.eurkon.com">https://blog.eurkon.com</a>（有访客统计、文章统计的教程）</p></li><li><p>MuJin：<a href="https://xiabor.com">https://xiabor.com</a></p></li></ul><p>不主观感受，希望上面的小伙伴看到不要打我…</p><h2 id="好文收藏一下">好文收藏一下</h2><p>在主页隐藏文章：<a href="https://youngwen.com/p/22099ef3.html">https://youngwen.com/p/22099ef3.html</a></p><h2 id="To-Do-List">To Do List</h2><p>文章数量多了之后加动态分类条</p><p>洪哥的<a href="https://blog.zhheo.com/p/bc61964d.html">Butterfly魔改：动态分类条，可以根据页面变化而改变的分类列表展示方式</a></p><p>博客文章统计+访问统计：</p><p><a href="https://blog.eurkon.com/categories/%E9%AD%94%E6%94%B9%E6%95%99%E7%A8%8B/">Eurkon博客</a></p><p>缩短文章链接、SEO优化：</p><p><a href="https://plushine.cn/54808.html#hexo-git-backup">https://plushine.cn/54808.html#hexo-git-backup</a></p><p>图床加速：</p><p><a href="https://plushine.cn/3726.html#%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E6%95%99%E7%A8%8B%EF%BC%8C%E5%89%8D%E5%BE%80%E8%BF%99%E9%87%8C%E6%9F%A5%E7%9C%8B">https://plushine.cn/3726.html#最新版本教程，前往这里查看</a></p><p>To do:</p><p>小雨的域名绑定：</p><p><a href="https://ranas.cn/2021/07/14/HexoAbout/">Hexo博客搭建的从无到有</a></p><p>灰鸿的SEO优化：</p><p><a href="https://space.greyh.cn/posts/7/#%E5%89%8D%E8%A8%80">hexo 博客的高级 SEO 优化</a></p><p>呆逼的网站访问速度优化：</p><p><a href="https://blog.keepdai.cn/youhua.html">网站访问速度优化</a></p><h2 id="主题源码修改">主题源码修改</h2><h3 id="版权信息美化">版权信息美化</h3><blockquote><p>参考：<a href="https://www.nesxc.com/post/hexocc.html">Nesxc 的 butterfly 版权美化教程</a></p></blockquote><p>修改了：</p><p><code>[root]\themes\butterfly\layout\includes\post\post-copyright.pug</code></p><p><code>[root]\themes\butterfly\source\css\_layout\post.styl</code></p><p>自定义了<code>copyright.css</code>文件于：</p><p><code>[root]\themes\butterfly\source\css</code></p><h3 id="版权文字改动">版权文字改动</h3><p><code>themes\butterfly\layout\includes\post\post-copyright.pug</code>修改了文字，添加了emoji表情</p><h3 id="今日诗词侧边栏小组件">今日诗词侧边栏小组件</h3><blockquote><p>参考：<a href="https://blog.zhheo.com/p/2ed9d8dd.html">洪哥的Butterfly美化：今日诗词侧边栏小组件，中国传统诗词文化</a></p></blockquote><p>新建了文件：</p><p><code>themes/butterfly/layout/includes/widget/card_poem.pug</code></p><p>page页面选择插入在公告后，post页面插在author后，顺便把公告注释掉了</p><p><code>themes/butterfly/layout/includes/widget/index.pug</code></p><p>主题配置中注入了洪哥的两个CSS（已下载到本地）</p><h3 id="标签上下标">标签上下标</h3><blockquote><p>参考：<a href="https://blog.eurkon.com/post/6687849c.html">Butterfly 标签云增加文章数上下标</a></p></blockquote><h3 id="站点统计加了emoji表情">站点统计加了emoji表情</h3><blockquote><p>参考：<a href="https://sianx.com/posts/c32b6e4c/#%E7%BD%91%E7%AB%99%E8%B5%84%E8%AE%AFemoji%E8%A1%A8%E6%83%85">https://sianx.com/posts/c32b6e4c/#网站资讯emoji表情</a></p></blockquote><p>修改了:<code>themes/butterfly/languages/zh-CN.yml</code></p><p>加了emoji和一些文字</p><h3 id="导航栏居中（去除了）">导航栏居中（去除了）</h3><blockquote><p>参考：<a href="https://sianx.com/posts/c32b6e4c/#%E5%AF%BC%E8%88%AA%E6%A0%8F">https://sianx.com/posts/c32b6e4c/#导航栏</a></p></blockquote><h3 id="动态分类条（去除了）">动态分类条（去除了）</h3><blockquote><p>参考：<a href="https://blog.zhheo.com/p/bc61964d.html">https://blog.zhheo.com/p/bc61964d.html</a></p></blockquote><p>只在子分类添加，因为首页与轮播在视觉上不合逻辑</p><h3 id="首页隐藏文章（去除了）">首页隐藏文章（去除了）</h3><blockquote><p>参考：<a href="https://blog.zhheo.com/p/451ff5e9.html">https://blog.zhheo.com/p/451ff5e9.html</a></p></blockquote><h2 id="非主题源码修改">非主题源码修改</h2><h3 id="鼠标样式，一图流（去除了）">鼠标样式，一图流（去除了）</h3><blockquote><p>参考：店长<a href="https://akilar.top/posts/ebf20e02/">Custom Beautify</a>中的<code>鼠标指针样式替换</code>和<code>透明度修改（含一图流方案）</code></p></blockquote><p>新增文件<code>custom.css</code>于</p><p>[Blogroot]\themes\butterfly\source\css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************鼠标*****************************************/</span></span><br><span class="line"><span class="comment">/* 全局默认鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/default.cur&#x27;</span>),auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停图片时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选择链接标签时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选中输入框时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/default.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停按钮时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停列表标签时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">i</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停页脚链接标签（例如页脚徽标）时的鼠标指针 */</span></span><br><span class="line"><span class="selector-id">#footer-wrap</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停页码时的鼠标指针 */</span></span><br><span class="line"><span class="selector-id">#pagination</span> <span class="selector-class">.page-number</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停菜单栏时的鼠标指针 */</span></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-class">.site-page</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在butterfly中的inject中引用了</p><hr><p>目前自定义CSS的全部代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************鼠标*****************************************/</span></span><br><span class="line"><span class="comment">/* 全局默认鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/default.cur&#x27;</span>),auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停图片时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选择链接标签时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选中输入框时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/default.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停按钮时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停列表标签时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">i</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停页脚链接标签（例如页脚徽标）时的鼠标指针 */</span></span><br><span class="line"><span class="selector-id">#footer-wrap</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停页码时的鼠标指针 */</span></span><br><span class="line"><span class="selector-id">#pagination</span> <span class="selector-class">.page-number</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停菜单栏时的鼠标指针 */</span></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-class">.site-page</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/cursor/pointer.cur&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************圆角*****************************************/</span></span><br><span class="line"><span class="comment">/* 修改图片圆角 */</span></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[src*=<span class="string">&quot;#img-radius&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">9px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 侧边栏圆角 */</span></span><br><span class="line"><span class="selector-id">#aside-content</span> <span class="selector-class">.card-widget</span> &#123;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 文章页圆角 */</span></span><br><span class="line"><span class="selector-class">.layout</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:first</span>-child<span class="selector-pseudo">:not</span>(<span class="selector-class">.recent-posts</span>) &#123;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 双栏卡片圆角 */</span></span><br><span class="line"><span class="selector-id">#recent-posts</span>&gt;<span class="selector-class">.recent-post-item</span> &#123;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* github按钮圆角 */</span></span><br><span class="line"><span class="selector-id">#card-info-btn</span>&#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden&#125;</span><br><span class="line"><span class="selector-id">#card-info-btn</span>:before&#123;</span><br><span class="line">  border-radius: <span class="number">18px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 右侧小按钮圆角 */</span></span><br><span class="line"><span class="selector-id">#rightside</span>&gt;<span class="selector-tag">div</span>&gt;<span class="selector-tag">button</span>,<span class="selector-id">#to_comment</span> &#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 翻页圆角 */</span></span><br><span class="line"><span class="selector-id">#pagination</span> <span class="selector-tag">a</span><span class="selector-class">.extend</span>,</span><br><span class="line"><span class="selector-id">#pagination</span> <span class="selector-class">.page-number</span>,</span><br><span class="line"><span class="selector-id">#pagination</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--font-color);</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">var</span>(--card-bg);</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">1.6rem</span>;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">1.6rem</span>;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">min-width</span>: <span class="number">1.6rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 目录圆角 */</span></span><br><span class="line"><span class="selector-id">#aside-content</span> <span class="selector-id">#card-toc</span> <span class="selector-class">.toc-content</span> <span class="selector-class">.toc-link</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文章标题居中 */</span></span><br><span class="line"><span class="selector-id">#page</span> <span class="selector-tag">h1</span><span class="selector-class">.page-title</span>,<span class="selector-id">#post</span>&gt;<span class="selector-id">#post-info</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导航栏置顶透明覆盖 */</span></span><br><span class="line"><span class="selector-id">#page-header</span><span class="selector-class">.not-top-img</span> <span class="selector-id">#nav</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line">    -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">6px</span> -<span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">133</span>,<span class="number">133</span>,<span class="number">133</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">6px</span> -<span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">133</span>,<span class="number">133</span>,<span class="number">133</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 导航栏非置顶透明覆盖 */</span></span><br><span class="line"><span class="selector-id">#page-header</span><span class="selector-class">.nav-fixed</span> <span class="selector-id">#nav</span> &#123;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">8</span>);</span><br><span class="line">    -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">6px</span> -<span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">133</span>,<span class="number">133</span>,<span class="number">133</span>,.<span class="number">6</span>);</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">6px</span> -<span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">133</span>,<span class="number">133</span>,<span class="number">133</span>,.<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*字体*/</span></span><br><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">&#x27;aqqxs&#x27;</span> ;  <span class="comment">/* 字体名自定义即可 */</span></span><br><span class="line">    <span class="attribute">src</span>:<span class="built_in">url</span>(<span class="string">&#x27;/fonts/ZhuZiAWan.woff2&#x27;</span>); <span class="comment">/* 字体文件路径 */</span></span><br><span class="line">    <span class="attribute">font-display</span> : swap;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-class">.article-title</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.article-meta-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">div</span><span class="selector-id">#bbtalk</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-id">#site-name</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.card-info-avatar</span><span class="selector-class">.is-center</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.card-widget</span><span class="selector-class">.card-tags</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.card-widget</span><span class="selector-class">.card-webinfo</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  element<span class="selector-class">.style</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.aplayer-music</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">div</span><span class="selector-id">#hopelight_plus_menu</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">div</span><span class="selector-id">#menus</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">div</span><span class="selector-id">#local-search-title</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">input</span><span class="selector-class">.local-search-box--input</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">div</span><span class="selector-id">#post-info</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.post-copyright</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.sticky_layout</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.search-dialog</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">main</span><span class="selector-id">#content-inner</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#footer-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;    <span class="comment">/* 手机侧边栏 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#sidebar</span> <span class="selector-id">#sidebar-menus</span><span class="selector-class">.open</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif;    <span class="comment">/* 页脚 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#search-button</span>&#123;</span><br><span class="line">        <span class="attribute">font-family</span>: <span class="string">&#x27;aqqxs&#x27;</span>, sans-serif; <span class="comment">/* 搜索 */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>圆角没适配好，首页图片和另一边奇奇怪怪的</p><hr><h3 id="页脚添加github徽标（去除了）">页脚添加github徽标（去除了）</h3><blockquote><p>参考：店长的<a href="https://akilar.top/posts/e87ad7f8/">博客添加github徽标方案-插件化写法</a></p></blockquote><h3 id="首页轮播文章（去除了）">首页轮播文章（去除了）</h3><blockquote><p>参考：店长的<a href="https://akilar.top/posts/8e1264d1/">基于 swiper 的首页置顶轮播图</a></p></blockquote><p>插件版</p><h3 id="基于-Butterfly-的外挂标签引入">基于 Butterfly 的外挂标签引入</h3><blockquote><p>参考：店长的基于 <a href="https://akilar.top/posts/615e2dec/">Butterfly 的外挂标签引入</a></p><p>外挂标签使用说法也是通篇文章</p></blockquote><p>插件安装版</p><h3 id="朋友圈3-0（去除了）">朋友圈3.0（去除了）</h3><blockquote><p>店长:<a href="https://akilar.top/posts/62f13a97/">hexo-filter-fcircle</a></p></blockquote><h3 id="添加浮动特效（去除了）">添加浮动特效（去除了）</h3><blockquote><p>店长：<a href="https://akilar.top/posts/abab51cf/">https://akilar.top/posts/abab51cf/</a></p></blockquote><p>插件化版本</p><p>butterfly主题配置中增加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#wowjs动画</span></span><br><span class="line"><span class="attr">wowjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#控制动画开关。true是打开，false是关闭</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">10</span> <span class="comment">#过滤器优先级</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment">#移动端是否启用，默认移动端禁用</span></span><br><span class="line">  <span class="attr">animateitem:</span></span><br><span class="line">    <span class="comment">#首页文章卡片</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">class:</span> <span class="string">recent-post-item</span> <span class="comment">#必填项，需要添加动画的元素的class</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">animate__zoomIn</span> <span class="comment">#必填项，需要添加的动画</span></span><br><span class="line">      <span class="attr">duration:</span> <span class="string">1s</span> <span class="comment">#选填项，动画持续时间，单位可以是ms也可以是s。例如3s，700ms。</span></span><br><span class="line">      <span class="attr">delay:</span> <span class="string">100ms</span> <span class="comment">#选填项，动画开始的延迟时间，单位可以是ms也可以是s。例如3s，700ms。</span></span><br><span class="line">      <span class="attr">offset:</span> <span class="number">100</span> <span class="comment">#选填项，开始动画的距离（相对浏览器底部）</span></span><br><span class="line">      <span class="attr">iteration:</span> <span class="number">1</span> <span class="comment">#选填项，动画重复的次数</span></span><br><span class="line">    <span class="comment">#侧栏卡片</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">class:</span> <span class="string">card-widget</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">animate__backInUp</span></span><br><span class="line">      <span class="attr">duration:</span> <span class="string">1s</span> <span class="comment">#选填项，动画持续时间，单位可以是ms也可以是s。例如3s，700ms。</span></span><br><span class="line">      <span class="attr">delay:</span> <span class="string">100ms</span> <span class="comment">#选填项，动画开始的延迟时间，单位可以是ms也可以是s。例如3s，700ms。</span></span><br><span class="line">      <span class="attr">offset:</span> <span class="number">100</span> <span class="comment">#选填项，开始动画的距离（相对浏览器底部）</span></span><br><span class="line">      <span class="attr">iteration:</span> <span class="number">1</span> <span class="comment">#选填项，动画重复的次数</span></span><br></pre></td></tr></table></figure><p>wowjs官方文档：<a href="https://animate.style/">https://animate.style/</a></p><h3 id="页面嵌入pdf（去除了）">页面嵌入pdf（去除了）</h3><blockquote><p>参考：<a href="https://www.freesion.com/article/21401006069/">https://www.freesion.com/article/21401006069/</a></p></blockquote><h3 id="文章永久固定连接">文章永久固定连接</h3><blockquote><p>参考：<a href="https://www.heson10.com/posts/31426.html">https://www.heson10.com/posts/31426.html</a></p></blockquote><h2 id="加速">加速</h2><h3 id="jsd-github图床加速（jsd已被墙）">jsd+github图床加速（jsd已被墙）</h3><blockquote><p>参考：<a href="https://www.heson10.com/posts/18256.html">jsDelivr CDN加速Github仓库图片做博客图床 - 黑石博客 - Hexo博客 (heson10.com)</a></p><p><a href="https://www.heson10.com/posts/57815.html#GitHub">Coding Studio实现hexo的云环境部署 - 黑石博客 - Hexo博客 (heson10.com)</a></p><p><a href="https://www.antmoe.com/posts/e33d1c55/">https://www.antmoe.com/posts/e33d1c55/</a></p><p><a href="https://www.jianshu.com/p/a36e9c64361d">https://www.jianshu.com/p/a36e9c64361d</a></p></blockquote><p>图片无损压缩网站：<a href="https://tinypng.com/">https://tinypng.com/</a></p><p>有损压缩软件：Imagine（已下载）</p><p>更多：</p><p><a href="https://www.zhihu.com/question/19779256">https://www.zhihu.com/question/19779256</a></p><p><a href="https://imagecompressor.com/">https://imagecompressor.com/</a></p><p><a href="https://ezgif.com/png-to-webp/ezgif-6-e16bc772437e.png">https://ezgif.com/png-to-webp/ezgif-6-e16bc772437e.png</a></p><hr><p>持续美化中…😂</p>]]></content>
      
      
      <categories>
          
          <category> 博客美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
            <tag> 博客美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo+阿里云解决Typora图床问题</title>
      <link href="/posts/e8553cf2.html"/>
      <url>/posts/e8553cf2.html</url>
      
        <content type="html"><![CDATA[<p>参考：</p><p><a href="https://www.cnblogs.com/gmengshuai/p/14139394.html">Typora+图床详解（小白都能学得会）</a></p><p><a href="https://www.cnblogs.com/qian-chang/p/13669613.html">史上最稳定的图床工具 - 阿里云 之 typora图床教程最终篇（转载）</a></p><p><a href="https://zhuanlan.zhihu.com/p/63557477">阿里云oss搭建图床以及使用PicGO上传图片到图床</a></p><p><a href="https://zhuanlan.zhihu.com/p/104152479">阿里云OSS PicGo 配置图床教程 超详细</a></p><p><a href="https://www.cnblogs.com/zenglintao/p/12876725.html">Typora上传当前所有图像</a></p><p>官网：</p><p><a href="https://github.com/Molunerfinn/PicGo/releases">PicGo-下载网站</a></p><p><a href="https://www.aliyun.com/">阿里云官网</a></p><p>注意：</p><p>上方购买的是存储容量，占大头的是流量</p><p>注意收费方式以及防盗链</p><p><a href="http://www.yuntue.com/post/9425.html">阿里云对象存储OSS怎么收费？用哪种计费方式更划算</a></p><p><a href="https://www.xixibobo.com/aliyun/ossliuliang/">阿里云OSS流量一个月多少钱？对象存储OSS流量收费标准</a></p><p><a href="https://www.mabiji.com/aliyun/ossjiage.html">阿里云对象存储OSS流量价格（按量计费/流量包收费标准</a></p><p><a href="https://blog.csdn.net/a631373000/article/details/105478778/">阿里云oss 收费标准细则，太鸡贼了，不要傻傻的以为只收你存储的钱</a></p><p><a href="https://www.cnblogs.com/guogangj/p/12123211.html">用了一年多之后才搞懂阿里云OSS收费细则</a></p><p><a href="https://www.zjh336.cn/?id=319">慎入！阿里云OSS对象储存 外网流出流量收费</a></p><p>设置白名单防盗链：</p><p>[阿里云OSS被盗链？上个月图床流量耗费50G+，请求次数10W+,什么鬼？](</p>]]></content>
      
      
      <categories>
          
          <category> 灵丹妙药 </category>
          
          <category> 图床 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> 阿里云 </tag>
            
            <tag> PicGo </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Windows api开发详解》-源码学习</title>
      <link href="/posts/7c96f25c.html"/>
      <url>/posts/7c96f25c.html</url>
      
        <content type="html"><![CDATA[<h2 id="文件系统">文件系统</h2><h3 id="磁盘和驱动器管理">磁盘和驱动器管理</h3><h4 id="遍历卷并获取属性">遍历卷并获取属性</h4><p>法一：使用GetLogicalDriveStrings获取系统中所有驱动器的根路径，并使用自定义的函数GetDirverInfo获取驱动器属性</p><p>原书P79，实例4-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetDirverInfo</span><span class="params">(LPSTR szDrive)</span></span>; <span class="comment">//自己定义的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CHAR szLogicalDriveStrings[BUFSIZE];</span><br><span class="line">    ZeroMemory(szLogicalDriveStrings, BUFSIZE);         <span class="comment">//ZeroMemory功能：将一块内存填充为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取逻辑驱动器卷标名</span></span><br><span class="line">    GetLogicalDriveStrings(BUFSIZE - <span class="number">1</span>, szLogicalDriveStrings);</span><br><span class="line">    PCHAR szDrive = (PCHAR)szLogicalDriveStrings;       <span class="comment">//字符指针，指向szLogicalDriveStrings</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环处理每个卷</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GetDirverInfo(szDrive))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nGet Volume Information Error: %lu&quot;</span>, GetLastError());</span><br><span class="line">        &#125;</span><br><span class="line">        szDrive += (lstrlen(szDrive) + <span class="number">1</span>); <span class="comment">//字符指针指向下一个驱动器根路径;lstrlen函数用于计算指定字符串的长度（不包含&#x27;\0）</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (*szDrive != <span class="string">&#x27;\x00&#x27;</span>);          <span class="comment">//转义符，\xhh表示二位十六进制;只剩下结束符&quot;0x00&quot;则退出</span></span><br><span class="line">                                           <span class="comment">/*mark1(代码完后会说明一些信息)*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************</span></span><br><span class="line"><span class="comment"> * BOOL GetDirverInfo(LPSTR szDrive);</span></span><br><span class="line"><span class="comment"> * 功能：获取驱动器的属性</span></span><br><span class="line"><span class="comment"> * 参数：LPSTR szDrive          长整型指针</span></span><br><span class="line"><span class="comment"> *      指明要获取属性的驱动器的根路径，如C：\</span></span><br><span class="line"><span class="comment"> * 返回值BOOL：表成功与否</span></span><br><span class="line"><span class="comment"> * ******************************************/</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetDirverInfo</span><span class="params">(LPSTR szDrive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;驱动器名 为 %s\n&quot;</span>, szDrive);</span><br><span class="line"></span><br><span class="line">    UINT uDriveType;                    <span class="comment">//驱动器类型;GetVolumeInformation第1个参数</span></span><br><span class="line">    uDriveType = GetDriveType(szDrive); <span class="comment">//获取驱动器类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;驱动器类型 为 &quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (uDriveType)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DRIVE_UNKNOWN:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The drive type cannot be determined.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DRIVE_NO_ROOT_DIR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The root path is invalid, for example, no volume is mounted at the path. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DRIVE_REMOVABLE:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The drive is a type that has removable media, for example, a floppy drive or removable hard disk.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DRIVE_FIXED: <span class="comment">//硬盘</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The drive is a type that cannot be removed, for example, a fixed hard drive.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DRIVE_REMOTE:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The drive is a remote (network) drive.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DRIVE_CDROM: <span class="comment">//光盘</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The drive is a CD-ROM drive.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DRIVE_RAMDISK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The drive is a RAM disk.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHAR szDirveName[MAX_PATH];           <span class="comment">//GetVolumeInformation第2个参数;驱动器名</span></span><br><span class="line">    DWORD dwVolumeSerialNumber;           <span class="comment">//GetVolumeInformation第4个参数;驱动器序列号</span></span><br><span class="line">    DWORD dwMaximumComponentLength;       <span class="comment">//GetVolumeInformation第5个参数;文件系统所支持的文件组成部分的最大值</span></span><br><span class="line">    DWORD dwFileSystemFlags;              <span class="comment">//GetVolumeInformation第6个参数;驱动器属性值</span></span><br><span class="line">    CHAR szFileSystemNameBuffer[BUFSIZE]; <span class="comment">//GetVolumeInformation第7个参数;文件系统类型</span></span><br><span class="line">    <span class="keyword">if</span> (!GetVolumeInformation(</span><br><span class="line">            szDrive,</span><br><span class="line">            szDirveName,</span><br><span class="line">            MAX_PATH, <span class="comment">//指明上一个参数的内存缓冲区大小</span></span><br><span class="line">            &amp;dwVolumeSerialNumber,</span><br><span class="line">            &amp;dwMaximumComponentLength,</span><br><span class="line">            &amp;dwFileSystemFlags,</span><br><span class="line">            szFileSystemNameBuffer,</span><br><span class="line">            BUFSIZE) <span class="comment">//指明上一个参数的内存缓冲区大小</span></span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lstrlen(szDirveName))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;驱动器名 为 %s\n&quot;</span>, szDirveName);                                      <span class="comment">//输出驱动器名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;驱动器序列号 为 %lu\n&quot;</span>, dwVolumeSerialNumber);                            <span class="comment">//输出驱动器序列号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件系统所支持的文件组成部分的最大值 为 %lu\n&quot;</span>, dwMaximumComponentLength);  <span class="comment">//输出文件系统所支持的文件组成部分的最大值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件系统类型 为 %s\n&quot;</span>, szFileSystemNameBuffer);                           <span class="comment">//输出文件系统类型</span></span><br><span class="line">    <span class="keyword">switch</span> (dwFileSystemFlags)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> FILE_SUPPORTS_REPARSE_POINTS:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file system does not support volume mount points.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逐个匹配dwDileSystemFlags，若相等，执行if里的语句</span></span><br><span class="line">    <span class="keyword">if</span> (dwFileSystemFlags &amp; FILE_SUPPORTS_REPARSE_POINTS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file system does not support volume mount points.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dwFileSystemFlags &amp; FILE_VOLUME_QUOTAS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file system supports disk quotas.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dwFileSystemFlags &amp; FILE_CASE_SENSITIVE_SEARCH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file system supports case-sensitive file names.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还有下面这些，根据需求来</span></span><br><span class="line">    <span class="comment">//FILE_CASE_PRESERVED_NAMES</span></span><br><span class="line">    <span class="comment">//FILE_CASE_SENSITIVE_SEARCH</span></span><br><span class="line">    <span class="comment">//FILE_FILE_COMPRESSION</span></span><br><span class="line">    <span class="comment">//FILE_NAMED_STREAMS</span></span><br><span class="line">    <span class="comment">//FILE_PERSISTENT_ACLS</span></span><br><span class="line">    <span class="comment">//FILE_READ_ONLY_VOLUME</span></span><br><span class="line">    <span class="comment">//FILE_SUPPORTS_ENCRYPTION</span></span><br><span class="line">    <span class="comment">//FILE_SUPPORTS_OBJECT_IDS</span></span><br><span class="line">    <span class="comment">//FILE_SUPPORTS_REPARSE_POINTS</span></span><br><span class="line">    <span class="comment">//FILE_SUPPORTS_SPARSE_FILES</span></span><br><span class="line">    <span class="comment">//FILE_UNICODE_ON_DISK</span></span><br><span class="line">    <span class="comment">//FILE_VOLUME_IS_COMPRESSED</span></span><br><span class="line">    <span class="comment">//FILE_VOLUME_QUOTAS</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码运行结果：![image-20210920164141290](/Typora_images/《windows api开发详解》-源码学习/image-20210920164141290.png)</p><p>mark1处：对于循环处理每个卷的代码块存在疑惑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环处理每个卷</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!GetDirverInfo(szDrive))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nGet Volume Information Error: %lu&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line">    szDrive += (lstrlen(szDrive) + <span class="number">1</span>); <span class="comment">//字符指针指向下一个驱动器根路径;lstrlen函数用于计算指定字符串的长度（不包含&#x27;\0）</span></span><br><span class="line">&#125; <span class="keyword">while</span> (*szDrive != <span class="string">&#x27;\x00&#x27;</span>);          <span class="comment">//转义符，\xhh表示二位十六进制;只剩下结束符&quot;0x00&quot;则退出</span></span><br></pre></td></tr></table></figure><p>问题：</p><p>​字符与字符指针的问题</p><p>解答：</p><ol><li>GetLogicalDriveStrings函数调用成功后，将在缓冲区中依次填入本机所具有的驱动器根路径字符串，如在笔者系统中有 3 个逻辑驱动器“C:\”、“D:\”、“E:\”。执行后在缓冲区中的结果如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x43</span> <span class="number">0x3a</span> <span class="number">0x5c</span> <span class="number">0x00</span> <span class="number">0x44</span> <span class="number">0x3a</span> <span class="number">0x5c</span> <span class="number">0x00</span> <span class="number">0x45</span> <span class="number">0x3a</span> <span class="number">0x5c</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="string">&#x27;C&#x27;</span>       <span class="string">&#x27;:&#x27;</span>    <span class="string">&#x27;\&#x27;    结束符  &#x27;</span>D<span class="number">&#x27;</span>     <span class="string">&#x27;:&#x27;</span>     <span class="string">&#x27;\&#x27;   结束符  &#x27;</span>E<span class="number">&#x27;</span>      <span class="string">&#x27;:&#x27;</span>     <span class="string">&#x27;\&#x27;   结束符 结束符  </span></span><br></pre></td></tr></table></figure><p>也就是连续放置了“C:\”、“D:\”“E:\”这3个字符串（会在每个字符串后加一个‘＼0’结束符，并在<strong>所有卷标字符串的最后再加一个结束符</strong>）</p><blockquote><p>在GetDirverInfo(szDrive)是将字符首地址传入，但实际上在使用这个指针时，每个驱动器根路径结尾都是’0x00’，不怕使用时出错</p></blockquote><ol start="2"><li>体会以下代码</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> p[<span class="number">1024</span>]=&#123;<span class="number">0x43</span>,<span class="number">0x3a</span>,<span class="number">0x5c</span>,<span class="number">0x00</span>,              <span class="comment">//  C:/</span></span><br><span class="line">                    <span class="number">0x44</span>,<span class="number">0x3a</span>,<span class="number">0x5c</span>,<span class="number">0x00</span>,            <span class="comment">//  D:/</span></span><br><span class="line">                    <span class="number">0x45</span>,<span class="number">0x3a</span>,<span class="number">0x5c</span>,<span class="number">0x00</span>,            <span class="comment">//  E:/</span></span><br><span class="line">                    <span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="built_in">strlen</span>(p);    <span class="comment">//长度为3（不含0结束符）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* b=p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,b);   <span class="comment">//注意这个printf的输出</span></span><br><span class="line"></span><br><span class="line">    b+=(a+<span class="number">1</span>);           <span class="comment">//4个一组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：![image-20210920162023002](/Typora_images/《windows api开发详解》-源码学习/image-20210920162023002.png)</p><hr><p>法二：使用FindFirstVolume、FindNextVolume和FindVolumeClose函数，遍历驱动器，获取驱动器名，并对每个所获得的驱动器使用自定义函数GetDirverInfo获取驱动器属性</p><p>原书P80，实例4-2</p><p>(GetDirverInfo函数是一样的)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE MAX_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetDirverInfo</span><span class="params">(LPSTR szDrive)</span></span>; <span class="comment">//自己定义的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    BOOL bFlag;</span><br><span class="line"></span><br><span class="line">    TCHAR buf[BUFSIZE];                         <span class="comment">//卷标信息</span></span><br><span class="line">    HANDLE hVol;                                <span class="comment">//卷句柄</span></span><br><span class="line">    hVol=FindFirstVolume(buf,BUFSIZE);</span><br><span class="line">    <span class="keyword">if</span>(hVol==INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(TEXT(<span class="string">&quot;No volumes found!\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetDirverInfo(buf);                     <span class="comment">//查找主机中后继的逻辑驱动器</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(FindNextVolume(hVol,buf,BUFSIZE));</span><br><span class="line"></span><br><span class="line">    bFlag=FindVolumeClose(hVol);                <span class="comment">//关闭FindFirstVolume打开的卷遍历句柄</span></span><br><span class="line">    <span class="keyword">return</span> (bFlag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************</span></span><br><span class="line"><span class="comment"> * BOOL GetDirverInfo(LPSTR szDrive);</span></span><br><span class="line"><span class="comment"> * 功能：获取驱动器的属性</span></span><br><span class="line"><span class="comment"> * 参数：LPSTR szDrive          长整型指针</span></span><br><span class="line"><span class="comment"> *      指明要获取属性的驱动器的根路径，如C：\</span></span><br><span class="line"><span class="comment"> * 返回值BOOL：表成功与否</span></span><br><span class="line"><span class="comment"> * ******************************************/</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetDirverInfo</span><span class="params">(LPSTR szDrive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;驱动器名 为 %s\n&quot;</span>, szDrive);</span><br><span class="line"></span><br><span class="line">    UINT uDriveType;                    <span class="comment">//驱动器类型;GetVolumeInformation第1个参数</span></span><br><span class="line">    uDriveType = GetDriveType(szDrive); <span class="comment">//获取驱动器类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;驱动器类型 为 &quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (uDriveType)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DRIVE_UNKNOWN:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The drive type cannot be determined.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DRIVE_NO_ROOT_DIR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The root path is invalid, for example, no volume is mounted at the path. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DRIVE_REMOVABLE:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The drive is a type that has removable media, for example, a floppy drive or removable hard disk.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DRIVE_FIXED: <span class="comment">//硬盘</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The drive is a type that cannot be removed, for example, a fixed hard drive.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DRIVE_REMOTE:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The drive is a remote (network) drive.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DRIVE_CDROM: <span class="comment">//光盘</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The drive is a CD-ROM drive.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DRIVE_RAMDISK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The drive is a RAM disk.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHAR szDirveName[MAX_PATH];           <span class="comment">//GetVolumeInformation第2个参数;驱动器名</span></span><br><span class="line">    DWORD dwVolumeSerialNumber;           <span class="comment">//GetVolumeInformation第4个参数;驱动器序列号</span></span><br><span class="line">    DWORD dwMaximumComponentLength;       <span class="comment">//GetVolumeInformation第5个参数;文件系统所支持的文件组成部分的最大值</span></span><br><span class="line">    DWORD dwFileSystemFlags;              <span class="comment">//GetVolumeInformation第6个参数;驱动器属性值</span></span><br><span class="line">    CHAR szFileSystemNameBuffer[BUFSIZE]; <span class="comment">//GetVolumeInformation第7个参数;文件系统类型</span></span><br><span class="line">    <span class="keyword">if</span> (!GetVolumeInformation(</span><br><span class="line">            szDrive,</span><br><span class="line">            szDirveName,</span><br><span class="line">            MAX_PATH, <span class="comment">//指明上一个参数的内存缓冲区大小</span></span><br><span class="line">            &amp;dwVolumeSerialNumber,</span><br><span class="line">            &amp;dwMaximumComponentLength,</span><br><span class="line">            &amp;dwFileSystemFlags,</span><br><span class="line">            szFileSystemNameBuffer,</span><br><span class="line">            BUFSIZE) <span class="comment">//指明上一个参数的内存缓冲区大小</span></span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lstrlen(szDirveName))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;驱动器名 为 %s\n&quot;</span>, szDirveName);                                      <span class="comment">//输出驱动器名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;驱动器序列号 为 %lu\n&quot;</span>, dwVolumeSerialNumber);                            <span class="comment">//输出驱动器序列号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件系统所支持的文件组成部分的最大值 为 %lu\n&quot;</span>, dwMaximumComponentLength);  <span class="comment">//输出文件系统所支持的文件组成部分的最大值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件系统类型 为 %s\n&quot;</span>, szFileSystemNameBuffer);                           <span class="comment">//输出文件系统类型</span></span><br><span class="line">    <span class="keyword">switch</span> (dwFileSystemFlags)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> FILE_SUPPORTS_REPARSE_POINTS:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file system does not support volume mount points.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逐个匹配dwDileSystemFlags，若相等，执行if里的语句</span></span><br><span class="line">    <span class="keyword">if</span> (dwFileSystemFlags &amp; FILE_SUPPORTS_REPARSE_POINTS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file system does not support volume mount points.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dwFileSystemFlags &amp; FILE_VOLUME_QUOTAS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file system supports disk quotas.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dwFileSystemFlags &amp; FILE_CASE_SENSITIVE_SEARCH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file system supports case-sensitive file names.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还有下面这些，根据需求来</span></span><br><span class="line">    <span class="comment">//FILE_CASE_PRESERVED_NAMES</span></span><br><span class="line">    <span class="comment">//FILE_CASE_SENSITIVE_SEARCH</span></span><br><span class="line">    <span class="comment">//FILE_FILE_COMPRESSION</span></span><br><span class="line">    <span class="comment">//FILE_NAMED_STREAMS</span></span><br><span class="line">    <span class="comment">//FILE_PERSISTENT_ACLS</span></span><br><span class="line">    <span class="comment">//FILE_READ_ONLY_VOLUME</span></span><br><span class="line">    <span class="comment">//FILE_SUPPORTS_ENCRYPTION</span></span><br><span class="line">    <span class="comment">//FILE_SUPPORTS_OBJECT_IDS</span></span><br><span class="line">    <span class="comment">//FILE_SUPPORTS_REPARSE_POINTS</span></span><br><span class="line">    <span class="comment">//FILE_SUPPORTS_SPARSE_FILES</span></span><br><span class="line">    <span class="comment">//FILE_UNICODE_ON_DISK</span></span><br><span class="line">    <span class="comment">//FILE_VOLUME_IS_COMPRESSED</span></span><br><span class="line">    <span class="comment">//FILE_VOLUME_QUOTAS</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>![image-20210928161235718](/Typora_images/《windows api开发详解》-源码学习/image-20210928161235718.png)![image-20210920170250155](/Typora_images/《windows api开发详解》-源码学习/image-20210920170250155.png)</p><p>可以看到终端输出是5个输出大块，打开磁盘管理器可以分别对应：![image-20210920165834658](/Typora_images/《windows api开发详解》-源码学习/image-20210920165834658.png)</p>]]></content>
      
      
      <categories>
          
          <category> Windows安全 </category>
          
          <category> 编程篇 </category>
          
          <category> win api </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIN32 API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《汇编语言-王爽-4th》实验代码</title>
      <link href="/posts/77a52927.html"/>
      <url>/posts/77a52927.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://highlightjs.org/static/demo/">highlight.js demo (highlightjs.org)</a></p><p>网页没把汇编代码高亮出来，疑是不支持16位的。后期再研究</p></blockquote><h2 id="P173实验7：Exp7-asm">P173实验7：Exp7.asm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class="line">    db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;</span><br><span class="line">    db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;</span><br><span class="line">    ;以上是表示21年的21个字符串</span><br><span class="line">    ;84byte</span><br><span class="line"></span><br><span class="line">    dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514</span><br><span class="line">    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000</span><br><span class="line">    ;以上是表示21年公司总收入的21个dword型数据，21×4=84byte</span><br><span class="line">    ;84byte</span><br><span class="line"></span><br><span class="line">    dw 3,7,9,13,28,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">    dw 11542,14430,15257,17800</span><br><span class="line">    ;以上是表示21年公司雇员人数的21个word数据，21×2byte=42byte</span><br><span class="line">    ;42byte</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">    db 21 dup(&#x27;year summ ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">      mov ax,data</span><br><span class="line">      mov ds,ax                 ;ds指向data</span><br><span class="line">      mov bx,0                  ;ds:[bx+idata]用来指向data段中的年份和收入</span><br><span class="line">      mov si,84+84              ;ds:[si]用来指向data段中的雇员数</span><br><span class="line"></span><br><span class="line">      mov ax,table</span><br><span class="line">      mov es,ax                 ;es指向table</span><br><span class="line">      mov bp,0                  ;es:[bp+idata]</span><br><span class="line"></span><br><span class="line">      mov cx,21</span><br><span class="line">to_table:</span><br><span class="line">      mov ax,[si]               ;复制雇员数量+准备除数（放内存单元）</span><br><span class="line">      mov es:[bp+0ah],ax        ;除数也可以放寄存器，div reg，然后再把商放table里</span><br><span class="line"></span><br><span class="line">      mov ax,[bx]               ;复制年份</span><br><span class="line">      mov dx,[bx+2]             ;[bx+idata]方式寻址,[bx+0]||[bx+2]</span><br><span class="line">      mov es:[bp],ax</span><br><span class="line">      mov es:[bp+2],dx</span><br><span class="line"></span><br><span class="line">      mov ax,[bx+84]            ;复制收入+准备被除数</span><br><span class="line">      mov dx,[bx+84+2]          ;84是从年份数据跳到收入数据，要+84个byte</span><br><span class="line">      mov es:[bp+5h],ax</span><br><span class="line">      mov es:[bp+5h+2],dx</span><br><span class="line"></span><br><span class="line">      div word ptr es:[bp+0ah]  ;商在AX，即人均收入</span><br><span class="line">      mov es:[bp+0dh],ax        ;放人均收入</span><br><span class="line">      </span><br><span class="line">      add bx,4                  ;data中，年份or收入都是4byte，故bx递增量是4</span><br><span class="line">      add si,2                  ;data中公司雇员相邻word类型，即2byte</span><br><span class="line">      add bp,10h                ;table中下一行</span><br><span class="line"></span><br><span class="line">      loop to_table</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="P187实验九：Exp9-asm">P187实验九：Exp9.asm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#x27;welcome to masm!&#x27;       ;字符串长度是16b==10h</span><br><span class="line">    db 02h                      ;黑底绿字属性字节0 000 0 010</span><br><span class="line">    db 24h                      ;绿底红字属性字节0 010 0 100</span><br><span class="line">    db 71h                      ;白底蓝字属性字节0 111 0 001</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">      mov ds,ax                 ;初始化ds指向data段</span><br><span class="line">      mov si,0                  ;后面通过递增si，用[si]逐位指遍data中的字符</span><br><span class="line"></span><br><span class="line">      mov ax,0b872h             ;显示器的第0页起始地址B8000H+第12行起始偏移6EOH+33列起始偏移40H=B87200==b872:0000</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,0                  ;后面通过di+2，指向下一列（一个字符占两个字节的存储空间，即一个字，高位字节是字符属性，低位字节是字符的ASCII码）</span><br><span class="line">      </span><br><span class="line">      mov cx,10h                ;16个字符串</span><br><span class="line"></span><br><span class="line">    s:                          ;循环16次，逐列复制字符</span><br><span class="line">                                ;eg现在是第一列，复制w绿色黑底到12行-&gt;复制w绿底红色到13行-&gt;复制w白底蓝色到14行</span><br><span class="line">                                ;现在是第二列，复制e绿色黑底到12行-&gt;复制e绿底红色到13行-&gt;复制e白底蓝色到14行……</span><br><span class="line">      </span><br><span class="line">      mov al,[si]               ;将字符复制到al</span><br><span class="line"></span><br><span class="line">      ;第12行的复制</span><br><span class="line">      mov ah,ds:[10h]           ;设置黑底绿色属性字节，复制到ah</span><br><span class="line">      mov es:[di],ax            ;复制到显示器缓冲区，（高位是字节属性，低位是字符ASCII码）</span><br><span class="line"></span><br><span class="line">      ;第13行的复制</span><br><span class="line">      mov ah,ds:[11h]           ;设置绿底红字属性字节</span><br><span class="line">      mov es:0a0h[di],ax        ;同一列，但是是13行</span><br><span class="line"></span><br><span class="line">      ;第14行的复制</span><br><span class="line">      mov ah,ds:[12h]           ;设置白底蓝字属性字节</span><br><span class="line">      mov es:140h[di],ax        ;同一列，但是是14行，两个160相加为140h</span><br><span class="line"></span><br><span class="line">      inc si                    ;si指向源头data中的下一个字符</span><br><span class="line">      add di,2                  ;di指向目的地的下一列</span><br><span class="line"></span><br><span class="line">      loop s</span><br><span class="line">      </span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="P206实验十">P206实验十</h2><h3 id="1-显示字符串Exp10-1-asm">1.显示字符串Exp10_1.asm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#x27;Welcome to masm!&#x27;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov dh,8      ;行号</span><br><span class="line">      mov dl,3      ;列号</span><br><span class="line">      mov cl,2      ;颜色</span><br><span class="line">      </span><br><span class="line">      mov ax,data</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,0      ;ds:[si]指向字符串</span><br><span class="line"></span><br><span class="line">      call show_str</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">show_str: </span><br><span class="line">      push ax           ;只压子程序中用到的寄存器</span><br><span class="line">      push cx           ;没必要那么虎，全压了</span><br><span class="line">      push dx</span><br><span class="line">      push si</span><br><span class="line"></span><br><span class="line">      mov ax,0b800h     ;段地址</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,0          ;用来放行和列偏移地址</span><br><span class="line">      mov di,0          ;指向显示器缓冲区下一字</span><br><span class="line"></span><br><span class="line">      ;算行偏移地址</span><br><span class="line">      xor ah,ah         ;ax高位清0</span><br><span class="line">      mov al,160        ;0a0h，160乘以行号，算行偏移地址</span><br><span class="line">      mul dh            ;行偏移地址结果在ax中</span><br><span class="line">      </span><br><span class="line">      mov bx,ax         ;结果送给bx</span><br><span class="line"></span><br><span class="line">      ;算列偏移地址</span><br><span class="line">      xor ah,ah         ;或者mov dh,0 然后add bx,dx来两句</span><br><span class="line">      mov al,2</span><br><span class="line">      mul dl            ;列偏移地址结果在ax中</span><br><span class="line">      </span><br><span class="line">      add bx,ax         ;现在bx是行+列偏移地址的和</span><br><span class="line">      </span><br><span class="line">      mov al,cl         ;下边要用cx来拷贝与判断，cl应放字符ASCII码，高位是字节属性</span><br><span class="line">      mov cl,0          ;而题目要求子程序参数（cl）=颜色，这里用al保存一下</span><br><span class="line">    s:</span><br><span class="line">      mov cl,ds:[si]    ;取字符串中的字符到cl中</span><br><span class="line">      mov ch,0          ;把高位字节属性清0.那么如果取的字符是0，jcxz就跳转退出子程序</span><br><span class="line">      jcxz ok           ;用到前面学的cx==0就退出子程序</span><br><span class="line">      mov ch,al         ;把字符属性弄回来</span><br><span class="line">                        ;法二，就直接把字拷贝到显示器缓冲区，拷贝完后边在单独写字节属性到缓冲区</span><br><span class="line"></span><br><span class="line">      mov es:[bx+di],cx ;拷贝</span><br><span class="line"></span><br><span class="line">      inc si            ;下一个字符拿来吧你！</span><br><span class="line">      add di,2          ;显示器缓冲区下一列（一个字）</span><br><span class="line"></span><br><span class="line">      jmp short s</span><br><span class="line">    ok:</span><br><span class="line">      pop si            ;ret前弹栈，与入栈顺序相反</span><br><span class="line">      pop dx</span><br><span class="line">      pop cx</span><br><span class="line">      pop ax</span><br><span class="line">      ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="2-解决除法溢出的问题Exp10-2-asm">2.解决除法溢出的问题Exp10_2.asm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">      db 16 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">      mov ax,stack</span><br><span class="line">      mov ss,ax</span><br><span class="line">      mov sp,16         ;初始化堆栈段ss和sp</span><br><span class="line"></span><br><span class="line">      mov ax,4240h      ;被除数低16位</span><br><span class="line">      mov dx,000fh      ;被除数高16位</span><br><span class="line">      mov cx,0ah        ;除数，16位</span><br><span class="line">      call divdw</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line"></span><br><span class="line">      ;功能：进行不会产生溢出的除法运算，被除数为dword型(32位），除数为word型（16位），结果为dword型（32位）</span><br><span class="line">      </span><br><span class="line">      ;参数  被除数 dx||ax  除数 cx</span><br><span class="line">      ;(ax)=dword型数据的低16位，(dx)=dword型数据的高16位  (cx)=除数</span><br><span class="line"></span><br><span class="line">      ;返回参数  商：dx||ax   余数 cx</span><br><span class="line">      ;(dx)=商的高16位，(ax)=商的低16位  (cx)=余数</span><br><span class="line"></span><br><span class="line">divdw:</span><br><span class="line">      mov bx,ax       ;保存被除数低16位</span><br><span class="line">      ;作H/N  H:被除数高16位 N：除数</span><br><span class="line">      mov ax,dx       </span><br><span class="line">      xor dx,dx       ;被除数准备：dx||ax，dx清0，把传进来的被除数的高16位dx放到ax中</span><br><span class="line">      div cx          ;H/N结果的商在AX中，余数在DX中</span><br><span class="line"></span><br><span class="line">      push ax         ;保存int(H/N)，即被除数高16位/除数的商</span><br><span class="line">      </span><br><span class="line">      mov ax,bx       ;恢复ax为传进来时的值，被除数的低16位</span><br><span class="line">      div cx          ;DX||AX  div  cx，即rem(H/N)||L /除数N</span><br><span class="line">                      ;商在AX（出口参数商低16位已在此），余数在DX</span><br><span class="line">      </span><br><span class="line">      mov cx,dx       ;出口参数，cx是余数</span><br><span class="line">      pop dx          ;dx是商的高16位</span><br><span class="line"></span><br><span class="line">      ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="3-数值显示Exp10-3-asm">3.数值显示Exp10_3.asm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 10 dup(0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,12606      ;word型数据，16位</span><br><span class="line">      </span><br><span class="line">      mov bx,data</span><br><span class="line">      mov ds,bx</span><br><span class="line">      mov si,0          ;ds:[si]指向data</span><br><span class="line"></span><br><span class="line">      call dtoc</span><br><span class="line"></span><br><span class="line">      mov dh,8          ;行号</span><br><span class="line">      mov dl,3          ;列号</span><br><span class="line">      mov cl,2          ;颜色</span><br><span class="line">      call show_str</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">;======================================================================</span><br><span class="line">      ;功能：将word型数据转变为表示十进制数的字符串，字符串以0为结尾符  </span><br><span class="line">            ;data中都已经是0了，把相应ASCII码放进去即可，不画蛇添足末尾手动添&#x27;0&#x27;了</span><br><span class="line">      ;入口参数：(ax)=word型数据  ds:si指向字符串首地址</span><br><span class="line">      ;返回：无</span><br><span class="line">      ;***************</span><br><span class="line">      ;这个dtoc以余数为0进行判断，会有问题。12066这种带0的数字，只能输出66</span><br><span class="line">      ;以商为0的版本才对，虽然在循环外要单独处理最高位</span><br><span class="line">      ;详见Design_one.asm</span><br><span class="line">      ;***************</span><br><span class="line">dtoc:</span><br><span class="line">      push bx           ;参数保护</span><br><span class="line">      push cx</span><br><span class="line">      push dx</span><br><span class="line">      push si</span><br><span class="line"></span><br><span class="line">      mov bx,0</span><br><span class="line">                        ;参数准备:被除数dx||ax  除数cx</span><br><span class="line">      xor dx,dx         ;高16位为dx,清零，低位为ax</span><br><span class="line">dec_to_ascii:</span><br><span class="line">      mov cx,10         ;除数准备，10</span><br><span class="line">      call divdw        ;子程序调用完返回   商：dx||ax   余数 cx</span><br><span class="line">                        ;实际上只用到ax,商dx一直为0。因为word型数据最大2^16-1=65535,/10后6553，ax就够了</span><br><span class="line">      jcxz ready        ;商为0，则除完了;正常写法是除到商为0，但是我用商为0再/10，得余数0，就不用在循环外单独处理最高位</span><br><span class="line">      add cx,30h        ;余数+30h变ASCII码</span><br><span class="line">      push cx           ;先存着先得的是最低位；实际上只有cl有数值，只用到cl，ch为0</span><br><span class="line">      inc bx            ;记录压了多少次</span><br><span class="line">      jmp short dec_to_ascii</span><br><span class="line">ready:</span><br><span class="line">      mov cx,bx         ;给循环次数</span><br><span class="line">put_in_data:            ;放data段中</span><br><span class="line">      pop bx</span><br><span class="line">      mov [si],bl</span><br><span class="line">      inc si</span><br><span class="line">      loop put_in_data</span><br><span class="line"> </span><br><span class="line">      pop si            ;参数恢复</span><br><span class="line">      pop dx</span><br><span class="line">      pop cx</span><br><span class="line">      pop bx</span><br><span class="line">      ret</span><br><span class="line">;===========================================================================================</span><br><span class="line">      ;功能：进行不会产生溢出的除法运算，被除数为dword型(32位），除数为word型（16位），结果为dword型（32位）</span><br><span class="line">      ;参数  被除数 dx||ax  除数 cx</span><br><span class="line">      ;(ax)=dword型数据的低16位，(dx)=dword型数据的高16位  (cx)=除数</span><br><span class="line">      ;返回参数  商：dx||ax   余数 cx</span><br><span class="line">      ;(dx)=商的高16位，(ax)=商的低16位  (cx)=余数</span><br><span class="line">divdw:</span><br><span class="line">      push bx           ;参数保护</span><br><span class="line"></span><br><span class="line">      mov bx,ax         ;保存被除数低16位</span><br><span class="line">      ;作H/N  H:被除数高16位 N：除数</span><br><span class="line">      mov ax,dx       </span><br><span class="line">      xor dx,dx         ;被除数准备：dx||ax，dx清0，把传进来的被除数的高16位dx放到ax中</span><br><span class="line">      div cx            ;H/N结果的商在AX中，余数在DX中</span><br><span class="line"></span><br><span class="line">      push ax           ;保存int(H/N)，即被除数高16位/除数的商</span><br><span class="line">      </span><br><span class="line">      mov ax,bx         ;恢复ax为传进来时的值，被除数的低16位</span><br><span class="line">      div cx            ;DX||AX  div  cx，即rem(H/N)||L /除数N</span><br><span class="line">                        ;商在AX（出口参数商低16位已在此），余数在DX</span><br><span class="line">      </span><br><span class="line">      mov cx,dx         ;出口参数，cx是余数</span><br><span class="line">      pop dx            ;dx是商的高16位</span><br><span class="line"></span><br><span class="line">      pop bx            ;参数恢复</span><br><span class="line">      ret</span><br><span class="line">;===========================================================================================</span><br><span class="line">      ;功能：在指定的位置，用指定的颜色，显示一个用0结束的字符串</span><br><span class="line">      ;入口参数  (dh)=行号 (dl)=列号 (cl)=颜色 ds:si指向字符串首地址</span><br><span class="line">      ;返回：无</span><br><span class="line">show_str: </span><br><span class="line">      push ax           ;只压子程序中用到的寄存器</span><br><span class="line">      push cx           ;没必要那么虎，全压了</span><br><span class="line">      push dx</span><br><span class="line">      push si</span><br><span class="line"></span><br><span class="line">      mov ax,0b800h     ;段地址</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,0          ;用来放行和列偏移地址</span><br><span class="line">      mov di,0          ;指向显示器缓冲区下一字</span><br><span class="line"></span><br><span class="line">      ;算行偏移地址</span><br><span class="line">      xor ah,ah         ;ax高位清0</span><br><span class="line">      mov al,160        ;0a0h，160乘以行号，算行偏移地址</span><br><span class="line">      mul dh            ;行偏移地址结果在ax中</span><br><span class="line">      </span><br><span class="line">      mov bx,ax         ;结果送给bx</span><br><span class="line"></span><br><span class="line">      ;算列偏移地址</span><br><span class="line">      xor ah,ah         ;或者mov dh,0 然后add bx,dx来两句</span><br><span class="line">      mov al,2</span><br><span class="line">      mul dl            ;列偏移地址结果在ax中</span><br><span class="line">      </span><br><span class="line">      add bx,ax         ;现在bx是行+列偏移地址的和</span><br><span class="line">      </span><br><span class="line">      mov al,cl         ;下边要用cx来拷贝与判断，cl应放字符ASCII码，高位是字节属性</span><br><span class="line">      mov cl,0          ;而题目要求子程序参数（cl）=颜色，这里用al保存一下</span><br><span class="line">    s:</span><br><span class="line">      mov cl,ds:[si]    ;取字符串中的字符到cl中</span><br><span class="line">      mov ch,0          ;把高位字节属性清0.那么如果取的字符是0，jcxz就跳转退出子程序</span><br><span class="line">      jcxz ok           ;用到前面学的cx==0就退出子程序</span><br><span class="line">      mov ch,al         ;把字符属性弄回来</span><br><span class="line">                        ;法二，就直接把字拷贝到显示器缓冲区，拷贝完后边在单独写字节属性到缓冲区</span><br><span class="line"></span><br><span class="line">      mov es:[bx+di],cx ;拷贝</span><br><span class="line"></span><br><span class="line">      inc si            ;下一个字符拿来吧你！</span><br><span class="line">      add di,2          ;显示器缓冲区下一列（一个字）</span><br><span class="line"></span><br><span class="line">      jmp short s</span><br><span class="line">    ok:</span><br><span class="line">      pop si            ;ret前弹栈，与入栈顺序相反</span><br><span class="line">      pop dx</span><br><span class="line">      pop cx</span><br><span class="line">      pop ax</span><br><span class="line">      ret</span><br><span class="line">;==========================================================================================</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="P211课程设计1Design-one-asm">P211课程设计1Design_one.asm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class="line">    db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;</span><br><span class="line">    db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;</span><br><span class="line">    ;以上是表示21年的21个字符串</span><br><span class="line">    ;84byte</span><br><span class="line"></span><br><span class="line">    dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514</span><br><span class="line">    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000</span><br><span class="line">    ;以上是表示21年公司总收入的21个dword型数据，21×4=84byte</span><br><span class="line">    ;84byte</span><br><span class="line"></span><br><span class="line">    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">    dw 11542,14430,15257,17800</span><br><span class="line">    ;以上是表示21年公司雇员人数的21个word数据，21×2byte=42byte</span><br><span class="line">    ;42byte</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">    db 21 dup(&#x27;year summ ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">f_data segment                  ;table中数据处理变ASCII码后放这里，然后通过show_str输出</span><br><span class="line">    db 8 dup(0)             ;最长7个ASCII码+最后一个是0；程序中也单独设为0，这里是(?)也行</span><br><span class="line">f_data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">      call to_table             ;将data中的数据处理放到table中      ;已测试没问题</span><br><span class="line">      call cls                  ;对DOS清屏                         ;已测试没问题</span><br><span class="line">      </span><br><span class="line">      mov ax,table              ;es:[bx]指向table段</span><br><span class="line">      mov es,ax                 ;bx控制行数,+10h</span><br><span class="line">      mov bx,0                  </span><br><span class="line"></span><br><span class="line">      mov ax,f_data</span><br><span class="line">      mov ds,ax                 ;ds:[si]指向f_data段</span><br><span class="line">      mov si,0                  ;ds:si始终不变，覆盖-&gt;输出-&gt;下一个数据覆盖-&gt;输出</span><br><span class="line">      </span><br><span class="line">      mov dh,4                  ;行号为1，下次循环前+1</span><br><span class="line">                                ;运行后下面会有3行覆盖我的输出，因为DOS最多就28行(0~27)，这里有21行</span><br><span class="line">                                ;dh选&lt;=4(第5行)恰好不被覆盖</span><br><span class="line">      mov cx,21                 ;一共21行</span><br><span class="line">    show_info:</span><br><span class="line">      push cx                   ;保存计数器，因为循环里边用到cl设置字节属性</span><br><span class="line"></span><br><span class="line">      ;处理显示年份数据</span><br><span class="line">      mov ax,es:[bx]            ;处理年份到f_data</span><br><span class="line">      mov [si],ax               ;字符串已经是ASCII码，直接拷贝</span><br><span class="line">      mov ax,es:[bx+2]</span><br><span class="line">      mov [si+2],ax</span><br><span class="line">      mov byte ptr [si+4],0     ;以0作为字符串结尾</span><br><span class="line"></span><br><span class="line">      mov dl,01                  ;设置为1列</span><br><span class="line">      mov cl,07                  ;黑底白字</span><br><span class="line">      call show_str             ;ds:[si]始终段首，前边用的是ds:[si+idata]进行寻址存放</span><br><span class="line">      </span><br><span class="line">      ;处理和显示收入数据</span><br><span class="line">      push dx                   ;为了保存dh，但push是字操作</span><br><span class="line">      </span><br><span class="line">      mov ax,es:[bx+5]          ;(ax)=收入的低16位</span><br><span class="line">      mov dx,es:[bx+7]          ;(dx)=收入的高16位</span><br><span class="line">      call ddtoc                ;处理成ASCII码放到ds:[si]</span><br><span class="line">      </span><br><span class="line">      pop dx                    ;恢复行号</span><br><span class="line">      mov dl,0bh    ;11                 ;设置为11列</span><br><span class="line">      mov cl,07                  ;黑底白字</span><br><span class="line">      call show_str</span><br><span class="line">      </span><br><span class="line">      ;显示公司总人数</span><br><span class="line">      push dx</span><br><span class="line">      </span><br><span class="line">      mov ax,es:[bx+10]         ;公司总人数就2byte</span><br><span class="line">      xor dx,dx                 ;高位补0</span><br><span class="line">      call ddtoc                ;处理成ASCII码放ds:[si]</span><br><span class="line"></span><br><span class="line">      pop dx</span><br><span class="line">      mov dl,18h    ;24                 ;设置为24列</span><br><span class="line">      mov cl,07</span><br><span class="line">      call show_str</span><br><span class="line"></span><br><span class="line">      ;显示人均收入</span><br><span class="line">      push dx</span><br><span class="line">      </span><br><span class="line">      mov ax,es:[bx+0dh]</span><br><span class="line">      xor dx,dx</span><br><span class="line">      call ddtoc</span><br><span class="line"></span><br><span class="line">      pop dx</span><br><span class="line">      mov dl,24h    ;36                 ;设置为36列</span><br><span class="line">      mov cl,07</span><br><span class="line">      call show_str</span><br><span class="line">      </span><br><span class="line">      add bx,10h                ;指向下一行</span><br><span class="line">      inc dh                    ;显示缓冲区行号+1，为下一行</span><br><span class="line"></span><br><span class="line">      pop cx                    ;恢复计数器</span><br><span class="line">      loop show_info</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">    ;名称：to_table </span><br><span class="line">    ;功能：将data中的数据处理放到table中</span><br><span class="line">    ;入口参数：无</span><br><span class="line">    ;返回：无</span><br><span class="line">to_table:</span><br><span class="line">      push ax</span><br><span class="line">      push bx</span><br><span class="line">      push bp</span><br><span class="line">      push cx</span><br><span class="line">      push ds</span><br><span class="line">      push es</span><br><span class="line">      push si</span><br><span class="line"></span><br><span class="line">      mov ax,data</span><br><span class="line">      mov ds,ax                 ;ds指向data</span><br><span class="line">      mov bx,0                  ;ds:[bx+idata]用来指向data段中的年份和收入</span><br><span class="line">      mov si,84+84              ;ds:[si]用来指向data段中的雇员数</span><br><span class="line"></span><br><span class="line">      mov ax,table</span><br><span class="line">      mov es,ax                 ;es指向table</span><br><span class="line">      mov bp,0                  ;es:[bp+idata]</span><br><span class="line"></span><br><span class="line">      mov cx,21</span><br><span class="line">    t_t_s:</span><br><span class="line">      mov ax,[si]               ;复制雇员数量+准备除数（放内存单元）</span><br><span class="line">      mov es:[bp+0ah],ax        ;除数也可以放寄存器，div reg，然后再把商放table里</span><br><span class="line"></span><br><span class="line">      mov ax,[bx]               ;复制年份</span><br><span class="line">      mov dx,[bx+2]             ;[bx+idata]方式寻址,[bx+0]||[bx+2]</span><br><span class="line">      mov es:[bp],ax</span><br><span class="line">      mov es:[bp+2],dx</span><br><span class="line"></span><br><span class="line">      mov ax,[bx+84]            ;复制收入+准备被除数</span><br><span class="line">      mov dx,[bx+84+2]          ;84是从年份数据跳到收入数据，要+84个byte</span><br><span class="line">      mov es:[bp+5h],ax</span><br><span class="line">      mov es:[bp+5h+2],dx</span><br><span class="line"></span><br><span class="line">      div word ptr es:[bp+0ah]  ;商在AX，即人均收入</span><br><span class="line">      mov es:[bp+0dh],ax        ;放人均收入</span><br><span class="line">      </span><br><span class="line">      add bx,4                  ;data中，年份or收入都是4byte，故bx递增量是4</span><br><span class="line">      add si,2                  ;data中公司雇员相邻word类型，即2byte</span><br><span class="line">      add bp,10h                ;table中下一行</span><br><span class="line"></span><br><span class="line">      loop t_t_s</span><br><span class="line">      </span><br><span class="line">      pop si</span><br><span class="line">      pop es</span><br><span class="line">      pop ds</span><br><span class="line">      pop cx</span><br><span class="line">      pop bp</span><br><span class="line">      pop bx</span><br><span class="line">      pop ax</span><br><span class="line"></span><br><span class="line">      ret</span><br><span class="line">;-------------------------------------------------------------</span><br><span class="line">    ;名称：cls</span><br><span class="line">    ;功能：DOS窗口清屏，对80×25彩色字符模式显示缓冲区进行清屏</span><br><span class="line">    ;原理：把内存地址结构B8000H~BFFFFH全写入 ASCII码NULL || 黑底黑字</span><br><span class="line">    ;入口参数：无</span><br><span class="line">    ;返回参数：无</span><br><span class="line">cls:  </span><br><span class="line">        push ax</span><br><span class="line">        push bx</span><br><span class="line">        push cx</span><br><span class="line">        push es</span><br><span class="line"></span><br><span class="line">        mov ax,0b800h          ;显存地址b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov al,0              ;低位设为NULL，ASCII码为0</span><br><span class="line">        mov ah,0              ;字符属性设置为黑底黑字，0 000 0 000</span><br><span class="line"></span><br><span class="line">        mov cx,80*25          ;25行，每行80个字符，循环80*25次</span><br><span class="line">    cls_s:</span><br><span class="line">        mov es:[bx],ax</span><br><span class="line">        add bx,2</span><br><span class="line">        loop cls_s</span><br><span class="line"></span><br><span class="line">        pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line"></span><br><span class="line">        ret</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">    ;名称：show_str</span><br><span class="line">    ;功能：在指定的位置，用指定的颜色，显示一个用0结束的字符串</span><br><span class="line">    ;入口参数  (dh)=行号 (dl)=列号 (cl)=颜色 ds:si指向字符串首地址,字符串要以0结尾</span><br><span class="line">    ;返回：无</span><br><span class="line">show_str: </span><br><span class="line">      push ax           ;只压子程序中用到的寄存器</span><br><span class="line">      push bx</span><br><span class="line">      push cx           ;没必要那么虎，全压了</span><br><span class="line">      push di</span><br><span class="line">      push dx</span><br><span class="line">      push es</span><br><span class="line">      push si</span><br><span class="line"></span><br><span class="line">      mov ax,0b800h     ;段地址</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,0          ;用来放行和列偏移地址</span><br><span class="line">      mov di,0          ;指向显示器缓冲区下一字</span><br><span class="line"></span><br><span class="line">      ;算行偏移地址</span><br><span class="line">      xor ah,ah         ;ax高位清0</span><br><span class="line">      mov al,160        ;0a0h，160乘以行号，算行偏移地址</span><br><span class="line">      mul dh            ;行偏移地址结果在ax中</span><br><span class="line">      </span><br><span class="line">      mov bx,ax         ;结果送给bx</span><br><span class="line"></span><br><span class="line">      ;算列偏移地址</span><br><span class="line">      xor ah,ah         ;或者mov dh,0 然后add bx,dx来两句</span><br><span class="line">      mov al,2</span><br><span class="line">      mul dl            ;列偏移地址结果在ax中</span><br><span class="line">      </span><br><span class="line">      add bx,ax         ;现在bx是行+列偏移地址的和</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      mov al,cl         ;下边要用cx来拷贝与判断，cl应放字符ASCII码，高位是字节属性</span><br><span class="line">      mov cl,0          ;而题目要求子程序参数（cl）=颜色，这里用al保存一下</span><br><span class="line">    s_s_s:</span><br><span class="line">      mov cl,ds:[si]    ;取字符串中的字符到cl中</span><br><span class="line">      mov ch,0          ;把高位字节属性清0.那么如果取的字符是0，jcxz就跳转退出子程序</span><br><span class="line">      jcxz ok           ;用到前面学的cx==0就退出子程序</span><br><span class="line">      mov ch,al         ;把字符属性弄回来</span><br><span class="line">                        ;法二，就直接把字拷贝到显示器缓冲区，拷贝完后边在单独写字节属性到缓冲区</span><br><span class="line"></span><br><span class="line">      mov es:[bx+di],cx ;拷贝</span><br><span class="line"></span><br><span class="line">      inc si            ;下一个字符拿来吧你！</span><br><span class="line">      add di,2          ;显示器缓冲区下一列（一个字）</span><br><span class="line"></span><br><span class="line">      jmp short s_s_s</span><br><span class="line">    ok:</span><br><span class="line">      pop si            ;ret前弹栈，与入栈顺序相反</span><br><span class="line">      pop es</span><br><span class="line">      pop dx</span><br><span class="line">      pop di</span><br><span class="line">      pop cx</span><br><span class="line">      pop bx</span><br><span class="line">      pop ax</span><br><span class="line"></span><br><span class="line">      ret</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">    ;名称：ddtoc     </span><br><span class="line">    ;功能：将dword型数据转变为表示十进制数的字符串，字符串以0为结尾符，写入ds:[si]</span><br><span class="line">    ;入口参数：dx||ax       ds:[si]指向字符串串的首地址</span><br><span class="line">    ;(dx)=dword型数据的高16位 (ax)=dword型数据的低16位</span><br><span class="line">    ;返回：无</span><br><span class="line">ddtoc:</span><br><span class="line">        push bx           ;参数保护</span><br><span class="line">        push cx</span><br><span class="line">        push di</span><br><span class="line">        push si</span><br><span class="line"></span><br><span class="line">        mov bx,0          ;bx初始化为0，记录多少位</span><br><span class="line">        mov si,0          ;ds:[si]放结果用</span><br><span class="line">        mov di,0          ;存cx用</span><br><span class="line">    dec_to_ascii:</span><br><span class="line">        mov cx,10         ;除数准备，10</span><br><span class="line">        call divdw        ;子程序调用完返回   商：dx||ax   余数 cx</span><br><span class="line">        </span><br><span class="line">        push dx           ;保护一下结果</span><br><span class="line">        push ax       </span><br><span class="line">        mov di,cx</span><br><span class="line"></span><br><span class="line">        add ax,dx         ;(dx)+(ax)整个商的和</span><br><span class="line">        mov cx,ax </span><br><span class="line"></span><br><span class="line">        pop ax</span><br><span class="line">        pop dx</span><br><span class="line">        jcxz before_ready        ;商为0，表明除完了  否则顺序执行</span><br><span class="line"></span><br><span class="line">        mov cx,di </span><br><span class="line">        add cx,30h        ;余数+30h变ASCII 码</span><br><span class="line">        push cx           ;先存着，÷10余数0~9，实际上只有cl有数值，只用到cl，ch为0</span><br><span class="line">        </span><br><span class="line">        inc bx            ;记录压了多少次</span><br><span class="line">        </span><br><span class="line">        jmp short dec_to_ascii</span><br><span class="line">    before_ready: </span><br><span class="line">        ;最高位也要处理</span><br><span class="line">        mov cx,di</span><br><span class="line">        add cx,30h</span><br><span class="line">        push cx</span><br><span class="line">        inc bx</span><br><span class="line"></span><br><span class="line">        mov cx,bx         ;给循环次数</span><br><span class="line">    put_in_data:          ;放data段中</span><br><span class="line">        pop bx</span><br><span class="line">        mov [si],bl</span><br><span class="line">        inc si</span><br><span class="line">        loop put_in_data</span><br><span class="line"></span><br><span class="line">        mov byte ptr [si],0;字符串0结尾</span><br><span class="line">    </span><br><span class="line">        pop si            ;参数恢复</span><br><span class="line">        pop di</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">    ;名称：divdw</span><br><span class="line">    ;功能：进行不会产生溢出的除法运算，被除数为dword型(32位），除数为word型（16位），结果为dword型（32位）</span><br><span class="line">    ;参数  被除数 dx||ax  除数 cx</span><br><span class="line">    ;(ax)=dword型数据的低16位，(dx)=dword型数据的高16位  (cx)=除数</span><br><span class="line">    ;返回参数  商：dx||ax   余数 cx</span><br><span class="line">    ;(dx)=商的高16位，(ax)=商的低16位  (cx)=余数</span><br><span class="line">divdw:</span><br><span class="line">      push bx           ;参数保护</span><br><span class="line"></span><br><span class="line">      mov bx,ax         ;保存被除数低16位</span><br><span class="line">      ;作H/N  H:被除数高16位 N：除数</span><br><span class="line">      mov ax,dx       </span><br><span class="line">      xor dx,dx         ;被除数准备：dx||ax，dx清0，把传进来的被除数的高16位dx放到ax中</span><br><span class="line">      div cx            ;H/N结果的商在AX中，余数在DX中</span><br><span class="line"></span><br><span class="line">      push ax           ;保存int(H/N)，即被除数高16位/除数的商</span><br><span class="line">      </span><br><span class="line">      mov ax,bx         ;恢复ax为传进来时的值，被除数的低16位</span><br><span class="line">      div cx            ;DX||AX  div  cx，即rem(H/N)||L /除数N</span><br><span class="line">                        ;商在AX（出口参数商低16位已在此），余数在DX</span><br><span class="line">      </span><br><span class="line">      mov cx,dx         ;出口参数，cx是余数</span><br><span class="line">      pop dx            ;dx是商的高16位</span><br><span class="line"></span><br><span class="line">      pop bx            ;参数恢复</span><br><span class="line">      </span><br><span class="line">      ret</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="P234实验11：Exp11-asm">P234实验11：Exp11.asm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">    db &quot;Beginner&#x27;s All-purpose Symbolic Instruction Code.&quot;,0</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">begin:</span><br><span class="line">      mov ax,datasg</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,0</span><br><span class="line">      call letterc</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">letterc:</span><br><span class="line">    s:</span><br><span class="line">      mov ch,0</span><br><span class="line">      mov cl,[si]</span><br><span class="line">      jcxz finish           ;是否是0，是0就退出啦</span><br><span class="line">      cmp cl,61h            ;小写a的ASCII码为61h</span><br><span class="line">      jna  s0               ;不高于61h</span><br><span class="line">      cmp cl,&#x27;z&#x27;            ;这样也行，不去算ASCII码</span><br><span class="line">      jnb s0                 ;不低于&#x27;z&#x27;</span><br><span class="line">      sub cl,20h            ;减20h变大写字母</span><br><span class="line">      mov [si],cl</span><br><span class="line">    s0:</span><br><span class="line">      inc si</span><br><span class="line">      jmp short s</span><br><span class="line">    finish:  </span><br><span class="line">      ret</span><br><span class="line">codesg ends</span><br><span class="line">end begin</span><br></pre></td></tr></table></figure><h2 id="P251实验12：Exp12-asm">P251实验12：Exp12.asm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">      ;do0安装程序</span><br><span class="line">      mov ax,cs</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,offset do0                 ;ds:[si]指向do0程序源地址</span><br><span class="line"></span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,200h                       ;指向do0程序存放的目的地址</span><br><span class="line"></span><br><span class="line">      mov cx,offset do0end-offset do0   ;do0程序长度</span><br><span class="line">      cld                               ;clean df正向传输</span><br><span class="line">      rep movsb</span><br><span class="line"></span><br><span class="line">      ;设置中断向量表中0号中断的地址</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov word ptr es:[0*4],200h        ;低位是偏移地址IP</span><br><span class="line">      mov word ptr es:[0*4+2],0         ;高位是段地址CS</span><br><span class="line">      </span><br><span class="line">      ;测试程序 16位/8位结果商放AL，AL8位最大255，放不下1000h</span><br><span class="line">      mov ax,1000h</span><br><span class="line">      mov bh,1</span><br><span class="line">      div bh</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line"></span><br><span class="line">    do0:</span><br><span class="line">      jmp short do0start                ;0:200处，且这条指令占两字节</span><br><span class="line">      db &quot;divide error!&quot;                     ;∴字符串偏移地址为202h</span><br><span class="line">    do0start:</span><br><span class="line">      mov ax,cs</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,202h                       ;ds:[si]指向字符串</span><br><span class="line"></span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax                         ;es:[di]指向显存缓冲区</span><br><span class="line">      mov di,12*160+36*2                ;12行36列开始显示   行号(0~24)列号(0~79)</span><br><span class="line"></span><br><span class="line">      mov cx,13                          ;字符串长度</span><br><span class="line">    s:</span><br><span class="line">      mov al,[si]</span><br><span class="line">      mov es:[di],al</span><br><span class="line">      mov ah,2h                          ;黑底绿字</span><br><span class="line">      mov es:[di+1],ah</span><br><span class="line"></span><br><span class="line">      inc si                            ;字符串下一个字符</span><br><span class="line">      add di,2                          ;显存空间下一个字</span><br><span class="line">      loop s</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">    do0end:</span><br><span class="line">      nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="P258检测点13-1：jcd13-1-asm">P258检测点13.1：jcd13_1.asm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#x27;conversation&#x27;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">      ;----------安装程序-----------</span><br><span class="line">      mov ax,cs</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,offset lp          ;ds:[di]指向7ch中断程序</span><br><span class="line"></span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,200h               ;es:[di]指向目的地址</span><br><span class="line"></span><br><span class="line">      mov cx,offset lpend-lp</span><br><span class="line">      cld</span><br><span class="line">      rep movsb</span><br><span class="line">      </span><br><span class="line">      ;--------修改中断向量表中-----</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov word ptr es:[7ch*4],200h</span><br><span class="line">      mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">      ;---------主程序-----------</span><br><span class="line">      mov ax,data</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,0                  ;ds:[si]指向data中的字符串</span><br><span class="line"></span><br><span class="line">      mov ax,0b800h             ;es:[di]指向显示器缓冲区</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,12*160</span><br><span class="line">    </span><br><span class="line">    s:cmp byte ptr [si],0</span><br><span class="line">      je ok</span><br><span class="line">      mov al,[si]</span><br><span class="line">      mov ah,2                 ;黑底绿字</span><br><span class="line">      mov es:[di],ax</span><br><span class="line">      inc si                    ;下一个字符</span><br><span class="line">      add di,2</span><br><span class="line">      mov bx,offset s-offset ok</span><br><span class="line">      int 7ch</span><br><span class="line">   ok:</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line"></span><br><span class="line">      ;---------7ch中断程序-------</span><br><span class="line">   lp:push bp</span><br><span class="line">      mov bp,sp</span><br><span class="line">      add [bp+2],bx</span><br><span class="line">   lpret:                        ;这个标号其实没啥用，只是让程序逻辑更清晰</span><br><span class="line">      pop bp</span><br><span class="line">      iret</span><br><span class="line">   lpend:</span><br><span class="line">      nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="P262实验十三">P262实验十三</h2><h3 id="1-Exp13-1-asm">(1)Exp13_1.asm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#x27;welcome to masm!&#x27;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">      ;----------安装程序-----------</span><br><span class="line">      mov ax,cs</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,offset begin          ;ds:[di]指向7ch中断程序</span><br><span class="line"></span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,200h               ;es:[di]指向目的地址</span><br><span class="line"></span><br><span class="line">      mov cx,offset lpend-offset begin</span><br><span class="line">      cld</span><br><span class="line">      rep movsb</span><br><span class="line">      </span><br><span class="line">      ;--------修改中断向量表中-----</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov word ptr es:[7ch*4],200h</span><br><span class="line">      mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">      ;---------主程序-----------</span><br><span class="line">      mov dh,10                 ;11行</span><br><span class="line">      mov dl,10                 ;11列</span><br><span class="line">      mov cl,2                  ;黑底绿字</span><br><span class="line"></span><br><span class="line">      mov ax,data</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,0                  ;ds:[si]指向data中的字符串</span><br><span class="line"></span><br><span class="line">      int 7ch</span><br><span class="line">   </span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line"></span><br><span class="line">      ;---------7ch中断程序-------</span><br><span class="line">      ;功能：显示一个用0结束的字符串</span><br><span class="line">      ;参数：(dh)=行号(dl)=列号(cl)=颜色，ds:si指向字符串首地址</span><br><span class="line">   begin:</span><br><span class="line">      push bx           ;参数保护</span><br><span class="line">      push cx</span><br><span class="line">      push dx</span><br><span class="line">      push si</span><br><span class="line"></span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,0          ;用来放行和列偏移地址</span><br><span class="line">      mov di,0          ;指向显示器缓冲区下一字</span><br><span class="line"></span><br><span class="line">      ;算行偏移地址</span><br><span class="line">      xor ah,ah         ;ax高位清0</span><br><span class="line">      mov al,160        ;0a0h，160乘以行号，算行偏移地址</span><br><span class="line">      mul dh            ;行偏移地址结果在ax中</span><br><span class="line">      </span><br><span class="line">      mov bx,ax         ;结果送给bx</span><br><span class="line"></span><br><span class="line">      ;算列偏移地址</span><br><span class="line">      xor ah,ah         ;或者mov dh,0 然后add bx,dx来两句</span><br><span class="line">      mov al,2</span><br><span class="line">      mul dl            ;列偏移地址结果在ax中</span><br><span class="line">      </span><br><span class="line">      add bx,ax         ;现在bx是行+列偏移地址的和</span><br><span class="line">      </span><br><span class="line">      mov al,cl         ;下边要用cx来拷贝与判断，cl应放字符ASCII码，高位是字节属性</span><br><span class="line">      mov cl,0          ;而题目要求子程序参数（cl）=颜色，这里用al保存一下</span><br><span class="line">    s:</span><br><span class="line">      mov cl,ds:[si]    ;取字符串中的字符到cl中</span><br><span class="line">      mov ch,0          ;把高位字节属性清0.那么如果取的字符是0，jcxz就跳转退出子程序</span><br><span class="line">      jcxz last           ;用到前面学的cx==0就退出子程序</span><br><span class="line">      mov ch,al         ;把字符属性弄回来</span><br><span class="line">                        ;法二，就直接把字拷贝到显示器缓冲区，拷贝完后边在单独写字节属性到缓冲区</span><br><span class="line"></span><br><span class="line">      mov es:[bx+di],cx ;拷贝</span><br><span class="line"></span><br><span class="line">      inc si            ;下一个字符拿来吧你！</span><br><span class="line">      add di,2          ;显示器缓冲区下一列（一个字）</span><br><span class="line"></span><br><span class="line">      jmp short s</span><br><span class="line">      </span><br><span class="line">    last:  </span><br><span class="line">      pop si            ;参数恢复</span><br><span class="line">      pop dx</span><br><span class="line">      pop cx</span><br><span class="line">      pop bx</span><br><span class="line"></span><br><span class="line">      iret</span><br><span class="line">   lpend:</span><br><span class="line">      nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="2-Exp13-2-asm">(2)Exp13_2.asm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">      ;----------安装程序-----------</span><br><span class="line">      mov ax,cs</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,offset lp          ;ds:[di]指向7ch中断程序</span><br><span class="line"></span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,200h               ;es:[di]指向目的地址</span><br><span class="line"></span><br><span class="line">      mov cx,offset lpend-offset lp</span><br><span class="line">      cld</span><br><span class="line">      rep movsb</span><br><span class="line">      </span><br><span class="line">      ;--------修改中断向量表-----</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov word ptr es:[7ch*4],200h</span><br><span class="line">      mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">      ;---------主程序-----------</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,160*12</span><br><span class="line">      mov bx,offset s-offset se</span><br><span class="line">      mov cx,80</span><br><span class="line">    s:</span><br><span class="line">      mov byte ptr es:[di],&#x27;!&#x27;      ;B800:0780处本身就是20 07 20 07...字节属性是07h，黑底白字</span><br><span class="line">      add di,2</span><br><span class="line">      </span><br><span class="line">      int 7ch</span><br><span class="line">   se:nop</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line"></span><br><span class="line">      ;---------7ch中断程序-------</span><br><span class="line">      ;功能：完成loop指令的功能</span><br><span class="line">      ;参数：(cx)=循环次数，(bx)=位移</span><br><span class="line">   lp:</span><br><span class="line">      push bp</span><br><span class="line">      mov bp,sp</span><br><span class="line">      dec cx</span><br><span class="line">      jcxz lpret</span><br><span class="line">      add [bp+2],bx</span><br><span class="line">  lpret:</span><br><span class="line">      pop bp</span><br><span class="line">      iret</span><br><span class="line">   lpend:</span><br><span class="line">      nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="3-Exp13-3-asm">(3)Exp13_3.asm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    s1: db &#x27;Good,better,best,&#x27;,&#x27;$&#x27;</span><br><span class="line">    s2: db &#x27;Never let it rest,&#x27;,&#x27;$&#x27;</span><br><span class="line">    s3: db &#x27;Till good is better,&#x27;,&#x27;$&#x27;</span><br><span class="line">    s4: db &#x27;And better,best.&#x27;,&#x27;$&#x27;</span><br><span class="line">    s : dw offset s1,offset s2,offset s3,offset s4</span><br><span class="line">   row: db 2,4,6,8</span><br><span class="line"></span><br><span class="line">   start:</span><br><span class="line">         mov ax,cs</span><br><span class="line">         mov ds,ax</span><br><span class="line">         mov bx,offset s</span><br><span class="line">         mov si,offset row</span><br><span class="line">         mov cx,4</span><br><span class="line">      ok:mov bh,0</span><br><span class="line">         mov dh,[si]</span><br><span class="line">         mov dl,0</span><br><span class="line">         mov ah,2</span><br><span class="line">         int 10h</span><br><span class="line"></span><br><span class="line">         mov dx,[bx]</span><br><span class="line">         mov ah,9</span><br><span class="line">         int 21h</span><br><span class="line">         inc si</span><br><span class="line">         add bx,2</span><br><span class="line">         loop ok</span><br><span class="line"></span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="P271实验14Exp14-asm">P271实验14Exp14.asm</h2><h3 id="1）输出法一：使用21号中断例程9号子程序显示-前的字符串">(1）输出法一：使用21号中断例程9号子程序显示$前的字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">          db &#x27;yy/MM/dd hh:mm:ss&#x27;,&#x27;$&#x27;  ; 用于存放从CMOS RAM中读取的时间ASCII</span><br><span class="line">   index: db 9,8,7,4,2,0            ; 用于存放CMOS RAM中对应的日期存储单元地址</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">   start: mov ax,data</span><br><span class="line">          mov ds,ax</span><br><span class="line">          mov si,0              ;ds:[si]指向存放的数据段</span><br><span class="line">          mov di,offset index   ;ds:[di]指向索引号</span><br><span class="line"> </span><br><span class="line">          mov cx,6              ;循环6次，读6个数据</span><br><span class="line">       s: push cx               ;循环里边shl左移用到cl作为次数</span><br><span class="line"></span><br><span class="line">          mov al,[di]</span><br><span class="line">          out 70h,al            ;向地址端口70h写入要访问的单元的地址</span><br><span class="line">          in al,71h             ;将CMOS RAM中的存储的信息读入al中</span><br><span class="line"></span><br><span class="line">          mov ah,al</span><br><span class="line">          mov cl,4</span><br><span class="line">          shr ah,cl             ;al中高4位BCD码写入ah</span><br><span class="line">          and al,00001111B      ;al高4位清0，留低4位的BCD码</span><br><span class="line"></span><br><span class="line">          add ah,30h            ;+30h变ASCII码</span><br><span class="line">          add al,30h            </span><br><span class="line"></span><br><span class="line">          mov [si],ah           ;存到data段中</span><br><span class="line">          mov [si+1],al</span><br><span class="line"></span><br><span class="line">          inc di                ;取下一个索引号</span><br><span class="line">          add si,3              </span><br><span class="line"></span><br><span class="line">          pop cx              ;恢复计数器cx</span><br><span class="line">          loop s             ; 循环的作用就是将得到的数据保存在time数据段中</span><br><span class="line">;--------显示输出部分-------------</span><br><span class="line">          mov ah,2              ;置光标</span><br><span class="line">          mov bh,0</span><br><span class="line">          mov dh,5              ;行号</span><br><span class="line">          mov dl,12             ;列号</span><br><span class="line">          int 10h</span><br><span class="line"></span><br><span class="line">          mov dx,0</span><br><span class="line">          mov ah,9</span><br><span class="line">          int 21h</span><br><span class="line"></span><br><span class="line">    comp: mov ax,4c00h</span><br><span class="line">          int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="2）输出法二：手动往0b80h-xxxx处写">(2）输出法二：手动往0b80h:xxxx处写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">          db &#x27;yy/MM/dd hh:mm:ss&#x27;,0  ; 用于存放从CMOS RAM中读取的时间ASCII</span><br><span class="line">   index: db 9,8,7,4,2,0            ; 用于存放CMOS RAM中对应的日期存储单元地址</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">   start: mov ax,data</span><br><span class="line">          mov ds,ax</span><br><span class="line">          mov si,0              ;ds:[si]指向存放的数据段</span><br><span class="line">          mov di,offset index   ;ds:[di]指向索引号</span><br><span class="line"> </span><br><span class="line">          mov cx,6              ;循环6次，读6个数据</span><br><span class="line">       s: push cx               ;循环里边shl左移用到cl作为次数</span><br><span class="line"></span><br><span class="line">          mov al,[di]</span><br><span class="line">          out 70h,al            ;向地址端口70h写入要访问的单元的地址</span><br><span class="line">          in al,71h             ;将CMOS RAM中的存储的信息读入al中</span><br><span class="line"></span><br><span class="line">          mov ah,al</span><br><span class="line">          mov cl,4</span><br><span class="line">          shr ah,cl             ;al中高4位BCD码写入ah</span><br><span class="line">          and al,00001111B      ;al高4位清0，留低4位的BCD码</span><br><span class="line"></span><br><span class="line">          add ah,30h            ;+30h变ASCII码</span><br><span class="line">          add al,30h            </span><br><span class="line"></span><br><span class="line">          mov [si],ah           ;存到data段中</span><br><span class="line">          mov [si+1],al</span><br><span class="line"></span><br><span class="line">          inc di                ;取下一个索引号</span><br><span class="line">          add si,3              </span><br><span class="line"></span><br><span class="line">          pop cx              ;恢复计数器cx</span><br><span class="line">          loop s             ; 循环的作用就是将得到的数据保存在time数据段中</span><br><span class="line">;--------显示输出部分-------------</span><br><span class="line">          mov ax,0B800H</span><br><span class="line">          mov es,ax</span><br><span class="line">          mov bx,160*12+31*2 ; 显示时间的位置，在12行，31列处开始</span><br><span class="line"></span><br><span class="line">          mov di,0</span><br><span class="line">    show: mov cl,[di]</span><br><span class="line">          cmp cl,0                      ;是否到结尾</span><br><span class="line">          je comp</span><br><span class="line">          mov ch,2                      ;字节属性2</span><br><span class="line">          mov es:[bx],cx</span><br><span class="line"></span><br><span class="line">          inc di                        ;下一个字符</span><br><span class="line">          add bx,2                      ;显示缓冲区下一个字</span><br><span class="line">          jmp short show</span><br><span class="line"></span><br><span class="line">    comp: mov ax,4c00h</span><br><span class="line">          int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="P285实验15Exp15-asm">P285实验15Exp15.asm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">      mov ax,stack          ;堆栈段初始化ss:sp</span><br><span class="line">      mov ss,ax</span><br><span class="line">      mov sp,128</span><br><span class="line"></span><br><span class="line">      push cs               ;可以使用栈，这样赋值</span><br><span class="line">      pop ds                ;设置ds指向cs段</span><br><span class="line">      mov si,offset int9    ;ds:[si]指向自己写的中断例程int 9地址</span><br><span class="line"></span><br><span class="line">      mov ax,0              ;es:[di]指向0:204处，即新int 9中断例程的安装地址</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,204h           </span><br><span class="line"></span><br><span class="line">      mov cx,offset int9end-offset int9     ;传输长度</span><br><span class="line">      cld                   ;正向传输</span><br><span class="line">      rep movsb</span><br><span class="line"></span><br><span class="line">      push es:[9*4]         ;将原int 9中断例程的入口地址保存在0:200处</span><br><span class="line">      pop es:[200h]</span><br><span class="line">      push es:[9*4+2]</span><br><span class="line">      pop es:[202h]</span><br><span class="line"></span><br><span class="line">      cli                           ;修改中断向量表为新的入口地址</span><br><span class="line">      mov word ptr es:[9*4],204h</span><br><span class="line">      mov word ptr es:[9*4+2],0</span><br><span class="line">      sti</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line"></span><br><span class="line">int9: push ax</span><br><span class="line">      push bx</span><br><span class="line">      push cx</span><br><span class="line">      push es</span><br><span class="line"></span><br><span class="line">      in al,60h                 </span><br><span class="line"></span><br><span class="line">      pushf</span><br><span class="line">      call dword ptr cs:[200h]       ;调用原int 9中断例程</span><br><span class="line"></span><br><span class="line">      cmp al,1eh+80h                ;A键的断码=通码1e+80h</span><br><span class="line">      jne int9ret                   ;不是A键松开则正常转移</span><br><span class="line"></span><br><span class="line">      mov ax,0b800h                 ;把显示缓冲区所有字节属性+1，更改颜色</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,0</span><br><span class="line">      mov cx,2000                   ;80列*25行共2000个字符</span><br><span class="line">    s:mov byte ptr es:[bx],&#x27;A&#x27;</span><br><span class="line">      add bx,2</span><br><span class="line">      loop s</span><br><span class="line"></span><br><span class="line">int9ret:</span><br><span class="line">      pop es</span><br><span class="line">      pop cx</span><br><span class="line">      pop bx</span><br><span class="line">      pop ax</span><br><span class="line">      iret</span><br><span class="line">int9end:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows安全 </category>
          
          <category> 基础篇 </category>
          
          <category> asm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> asm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《windows程序设计5th（珍藏版）》-前四章笔记-小甲鱼</title>
      <link href="/posts/6a024e36.html"/>
      <url>/posts/6a024e36.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1>扫盲</h1><h2 id="匈牙利标记法">匈牙利标记法</h2><p>​许多Windows程序员使用“匈牙利标记法”作为变量命名约定，为了纪念具有传奇色彩的微软程序员Charles Simonyi</p><p>意义：</p><ul><li>帮助程序写作者及早发现并避免程序中的错误。由于变量名既描述了变量的作用，又描述了其数据型态，就比较容易避免产生数据型态不合的错误。</li></ul><p>“匈牙利标记法”：</p><ul><li><p>变量名以<strong>表明该变量数据类型的小写字母</strong>开头</p><blockquote><p>例如</p><p>WinMain函数的四个参数中：</p><p>在 hInstance 和 hPrevInstance 中的 h 前缀表示“句柄（Handle）”；</p><p>szCmdLine 中的 sz 代表“以0结尾的字符串（StringZero）”；</p><p>在 iCmdShow 中的 i 前缀表示“整型（Integer）”</p></blockquote></li><li><p>命名结构变量时，使用<strong>结构名（或结构名称的缩写）的小写形式</strong>作为变量名称的前缀或整个变量名</p><blockquote><p>例如</p><p>msg 变量是 MSG 型态的结构；</p><p>wndclass 是 WNDCLASSEX 型态的一个结构；</p><p>ps 是一个 PAINTSTRUCT 结构</p><p>rect 是一个 RECT 结构。</p></blockquote></li><li><p>常量和宏定义全部以大写字母进行撰写，中间可根据意义的连续性用下划线连接，前缀表明<strong>该常量所属的一般类别</strong></p><blockquote><p>例如</p><p>CS_HREDRAW      DT_VCENTER        SND_FILENAME<br>CS_VREDRAW       IDC_ARROW        WM_CREATE<br>CW_USEDEFAULT   IDI_APPLICATION   WM_DESTROY<br>DT_CENTER         MB_ICONERROR    WM_PAINT<br>DT_SINGLELINE     SND_ASYNC         WS_OVERLAPPEDWINDOW</p></blockquote></li></ul><p>变量名前缀：</p><table><thead><tr><th><strong>前缀</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>c</td><td>char 或 WCHAR 或 TCHAR</td></tr><tr><td>by</td><td>BYTE （无符号字符）</td></tr><tr><td>n</td><td>short（短整型）</td></tr><tr><td>i</td><td>int（整型）</td></tr><tr><td>x, y</td><td>int，表示 x 坐标和 y 坐标</td></tr><tr><td>cx, cy</td><td>int，表示 x 或 y 的长度，c 表示“count”（计数）</td></tr><tr><td>B 或 f</td><td>BOOL（int）；f 表示“flag”</td></tr><tr><td>w</td><td>WORD（无符号短整型）</td></tr><tr><td>l</td><td>LONG（长整型）</td></tr><tr><td>dw</td><td>DWORD（无符号长整型）</td></tr><tr><td>fn</td><td>函数</td></tr><tr><td>s</td><td>字符串</td></tr><tr><td>sz</td><td>以零结束的字符串（String Terminated with a Zero)</td></tr><tr><td>h</td><td>句柄</td></tr><tr><td>p</td><td>指针</td></tr></tbody></table><ul><li>前缀lpfn：指向函数的长指针（long pointer to a function)</li><li>lpsz：指向以零结束的字符串的长指针（long pointer to a string terminated with a zero）</li><li>前缀cb：字节数（count of byte)</li><li>h句柄<ul><li>hbr：画刷的句柄（handle to a brush）</li></ul></li></ul><p>大写前缀：</p><table><thead><tr><th><strong>前缀</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>CS</td><td>类风格选项（ClassStyle）</td></tr><tr><td>CW</td><td>创建窗口选项（CreateWindow）</td></tr><tr><td>DT</td><td>文本绘制选项（DrawText）</td></tr><tr><td>IDI</td><td>图标的 ID 号（IDIcon）（ID for a icon）</td></tr><tr><td>IDC</td><td>光标的 ID 号（IDCursor）</td></tr><tr><td>MB</td><td>消息框选项（MessageBox）</td></tr><tr><td>SND</td><td>声音选项（Sound）</td></tr><tr><td>WM</td><td>窗口消息（WindowsMessage）</td></tr><tr><td>WS</td><td>窗口风格（WindowStyles）</td></tr></tbody></table><blockquote><p>MORE:</p><p>​<a href="https://baike.baidu.com/item/%E5%8C%88%E7%89%99%E5%88%A9%E6%A0%87%E8%AE%B0%E6%B3%95/3640316?fr=aladdin">匈牙利标记法-百度百科</a></p><p>​<a href="https://blog.csdn.net/jlran/article/details/52700095">匈牙利标记法</a></p></blockquote><h2 id="句柄">句柄</h2><p>​数值上是一个32位无符号整型值（32位系统下）；逻辑上，相当于指针的指针；形象理解上，是Windows中各个对象的一个唯一的、固定不变的ID；作用上，Windows使用句柄来标识诸如窗口、位图、画笔等对象，并通过句柄找到这些对象。</p><blockquote><p>​因为Windows的虚拟内存管理机制，内存管理器经常地在内存中移动各种对象，以此来满足各种应用程序的内存需要，对象被移动了，即在内存中的位置会经常变化的，那如何找到这个在内存中不固定的对象？<br>​为了解决这个问题，Windows操作系统为各应用程序腾出一些内存储地址，用来专门登记各应用对象在内存中的地址变化，而这个地址(内存管理器在移动对象在内存中的位置后，把对象新的地址告知这个句柄地址来保存。这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。这个地址是在对象装载(Load)时由系统分配给的，当系统卸载时(Unload)又释放给系统。</p><p>​句柄类似索引表中的索引号</p><p>​句柄地址(稳定)→记载着对象在内存中的地址————→对象在内存中的地址(不稳定)→实际对象</p></blockquote><p>​句柄事实上是一个数，一个索引值，一个让操作系统可以找到这个实例的索引值。事实上系统内部有建立一个索引表，维护着所有实例的索引号对应的内存地址，但这个索引表操作系统是不可能告诉我们的。</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/《windows程序设计》-前四章笔记-小甲鱼/161823248912685.png" alt="img"  /><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E3%80%8Awindows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B-%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B0%8F%E7%94%B2%E9%B1%BC/161823541109391.png" alt="img"></p><p><strong>handle，知道怎么用更重要！</strong></p><blockquote><p>参考网址：</p><p>​<a href="https://fishc.com.cn/forum.php?mod=viewthread&amp;tid=47365">第004讲：【扫盲】句柄与指针（转）-鱼C论坛</a></p><p>比喻角度理解：</p><p>​<a href="https://www.cnblogs.com/zpcdbky/p/4652151.html">图解说明——究竟什么是Windows句柄</a></p><p>代码角度理解：</p><p>​<a href="https://blog.csdn.net/wenzhou1219/article/details/17659485">深入了解Windows句柄到底是什么</a></p><p>​<a href="https://blog.csdn.net/newjerryj/article/details/4383701">句柄和指针的区别</a></p><p>​<a href="https://www.cnblogs.com/yellowyu/archive/2009/06/07/1497910.html">关于什么是句柄(经典)</a></p><p>其他：</p><p>​<a href="https://baike.baidu.com/item/%E5%8F%A5%E6%9F%84/3527587?fr=aladdin">句柄-百度百科</a></p><p>​<a href="https://www.zhihu.com/question/27656256">句柄是什么</a></p></blockquote><h2 id="客户区和非客户区">客户区和非客户区</h2><img src= "/img/loading.gif" data-lazy-src="/Typora_images/《windows程序设计》-前四章笔记-小甲鱼/image-20210801202843768.png" alt="image-20210801202843768" style="zoom: 67%;" /><p>​如何自绘窗口：创建一个无边框无标题栏的窗口，相当于去除了窗口的非客户区，然后我们在客户区里自己进行绘制，这样想把窗口画成什么样都行。这是基本的思路，但实现起来还是有很多难点需要克服。</p><h1>窗口与消息</h1><h2 id="Windows窗口诞生过程">Windows窗口诞生过程</h2><p>​定义窗口类结构（<a href="http://bbs.fishc.com/thread-47123-1-1.html">WNDCLASS</a>） -&gt; 注册窗口类（RegisterClass） -&gt; 创建窗口（<a href="http://bbs.fishc.com/thread-47139-1-1.html">CreateWindow</a>） -&gt; 显示窗口（<a href="http://bbs.fishc.com/thread-47206-1-1.html">ShowWindow</a>） -&gt; 更新窗口（<a href="http://bbs.fishc.com/thread-47210-1-1.html">UpdateWindow</a>） -&gt; 消息循环（<a href="http://bbs.fishc.com/thread-47252-1-1.html">GetMessage</a> -&gt; <a href="http://bbs.fishc.com/thread-47258-1-1.html">TranslateMessage</a> -&gt;<a href="http://bbs.fishc.com/thread-47260-1-1.html">DispatchMessage</a>）</p><p>​备注：在调用完 CreateWindow 函数之后，应用程序实例已经在内存中创建成功，并返回窗口句柄。</p><h2 id="系统如何销毁一个窗口">系统如何销毁一个窗口</h2><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E3%80%8Awindows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B-%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B0%8F%E7%94%B2%E9%B1%BC/2126419gzgt9d5rayedvrv.png" alt="img"></p><p>​问：如果在程序关闭的时候需要提示用户是否真的关闭应用程序，我们应该响应哪个消息呢？</p><p>​答：WM_CLOSE消息</p><p>​如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">  <span class="keyword">if</span>(MessaBox(hwnd, TEXT(<span class="string">&quot;请问是否真的要关闭我？&quot;</span>), TEXT(<span class="string">&quot;请确认&quot;</span>), MB_YESNO)==IDYES)</span><br><span class="line">       DestroyWindow(hwnd);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="经典模板代码">经典模板代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span> <span class="params">(HWND, UINT, WPARAM, LPARAM)</span> </span>;</span><br><span class="line">                        <span class="comment">//函数参数声明了类型，没指出形参而已</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span> <span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">                    PSTR szCmdLine, <span class="keyword">int</span> iCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">static</span> TCHAR szAppName[] = TEXT (<span class="string">&quot;HelloWin&quot;</span>) ;</span><br><span class="line">     HWND         hwnd ;    <span class="comment">//窗口句柄</span></span><br><span class="line">     MSG          msg ;     <span class="comment">//消息结构</span></span><br><span class="line">     WNDCLASS     wndclass ;<span class="comment">//窗口类结构</span></span><br><span class="line"><span class="comment">/*------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   定义窗口类结构（WNDCLASS）</span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------*/</span></span><br><span class="line">     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;                 <span class="comment">//指定窗口类型，各种“类风格”，可以使用按位或操作符组合起来</span></span><br><span class="line">     wndclass.lpfnWndProc   = WndProc ;                                 <span class="comment">//指定窗口过程（必须是回调函数）</span></span><br><span class="line">     wndclass.cbClsExtra    = <span class="number">0</span> ;                                       <span class="comment">//预留的额外空间，一般为 0</span></span><br><span class="line">     wndclass.cbWndExtra    = <span class="number">0</span> ;                                       <span class="comment">//预留的额外空间，一般为 0</span></span><br><span class="line">     wndclass.hInstance     = hInstance ;                               <span class="comment">//应用程序的实例句柄</span></span><br><span class="line">     wndclass.hIcon         = LoadIcon (<span class="literal">NULL</span>, IDI_APPLICATION) ;        <span class="comment">//为所有基于该窗口类的窗口设定一个图标</span></span><br><span class="line">     wndclass.hCursor       = LoadCursor (<span class="literal">NULL</span>, IDC_ARROW) ;            <span class="comment">//为所有基于该窗口类的窗口设定一个鼠标指针</span></span><br><span class="line">     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;   <span class="comment">//指定窗口背景色</span></span><br><span class="line">     wndclass.lpszMenuName  = <span class="literal">NULL</span> ;                                    <span class="comment">//指定窗口菜单</span></span><br><span class="line">     wndclass.lpszClassName = szAppName ;                               <span class="comment">//指定窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   注册窗口类（RegisterClass）</span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------*/</span></span><br><span class="line">     <span class="keyword">if</span> (!RegisterClass (&amp;wndclass))</span><br><span class="line">     &#123;</span><br><span class="line">          MessageBox (<span class="literal">NULL</span>, TEXT (<span class="string">&quot;This program requires Windows NT!&quot;</span>), </span><br><span class="line">                      szAppName, MB_ICONERROR) ;                        <span class="comment">//注册失败则弹窗提示ERROR</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">/*------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   创建窗口（CreateWindow)</span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------*/</span></span><br><span class="line">     hwnd = CreateWindow (szAppName,                  <span class="comment">// 窗口类名称</span></span><br><span class="line">                          TEXT (<span class="string">&quot;The Hello Program&quot;</span>), <span class="comment">// 窗口标题</span></span><br><span class="line">                          WS_OVERLAPPEDWINDOW,        <span class="comment">// 窗口风格，或称窗口格式</span></span><br><span class="line">                          CW_USEDEFAULT,              <span class="comment">// 初始x坐标</span></span><br><span class="line">                          CW_USEDEFAULT,              <span class="comment">// 初始y坐标</span></span><br><span class="line">                          CW_USEDEFAULT,              <span class="comment">// 初始x方向尺寸</span></span><br><span class="line">                          CW_USEDEFAULT,              <span class="comment">// 初始y方向尺寸</span></span><br><span class="line">                          <span class="literal">NULL</span>,                       <span class="comment">// 父窗口句柄</span></span><br><span class="line">                          <span class="literal">NULL</span>,                       <span class="comment">// 窗口菜单句柄</span></span><br><span class="line">                          hInstance,                  <span class="comment">// 程序实例句柄</span></span><br><span class="line">                          <span class="literal">NULL</span>) ;                     <span class="comment">// 创建参数</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">/*------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   显示窗口（ShowWindow）-&gt;更新窗口（UpdateWindow）</span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------*/</span></span><br><span class="line">     ShowWindow (hwnd, iCmdShow) ;</span><br><span class="line">     UpdateWindow (hwnd) ;</span><br><span class="line">     </span><br><span class="line"><span class="comment">/*------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   消息循环（GetMessage-&gt;TranslateMessage-&gt;DispatchMessage)</span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (GetMessage (&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">          TranslateMessage (&amp;msg) ;</span><br><span class="line">          DispatchMessage (&amp;msg) ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> msg.wParam ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   窗口过程</span></span><br><span class="line"><span class="comment">  ------------------------------------------------------------*/</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span> <span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;                           <span class="comment">//WndProc这四个函数参数是MSG消息结构中的前四位成员</span></span><br><span class="line">     HDC         hdc ;      <span class="comment">//设备环境句柄</span></span><br><span class="line">     PAINTSTRUCT ps ;       <span class="comment">//绘制结构</span></span><br><span class="line">     RECT        rect ;     <span class="comment">//矩阵结构</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">switch</span> (message)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">          PlaySound (TEXT (<span class="string">&quot;hellowin.wav&quot;</span>), <span class="literal">NULL</span>, SND_FILENAME | SND_ASYNC) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">          hdc = BeginPaint (hwnd, &amp;ps) ;</span><br><span class="line">          </span><br><span class="line">          GetClientRect (hwnd, &amp;rect) ;</span><br><span class="line">          </span><br><span class="line">          DrawText (hdc, TEXT (<span class="string">&quot;Hello, Windows 98!&quot;</span>), <span class="number">-1</span>, &amp;rect,</span><br><span class="line">                    DT_SINGLELINE | DT_CENTER | DT_VCENTER) ;</span><br><span class="line">          </span><br><span class="line">          EndPaint (hwnd, &amp;ps) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">          PostQuitMessage (<span class="number">0</span>) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> DefWindowProc (hwnd, message, wParam, lParam) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息">消息</h3><p>消息，说到底它就是一个整数值，一个 Windows 约定俗成的整数值，通过查找相关的宏定义（<a href="http://bbs.fishc.com/thread-47244-1-1.html">Windows 常用消息及含义</a>），使得我们了解这些整数值分别代表什么含义。</p><h4 id="消息机制-2">消息机制</h4><p>Windows 是一个事件驱动，基于消息的操作系统。</p><p>用户的任何操作都被看作一个事件，操作系统会自动将该事件转换为相应的消息并投入该应用程序的消息队列等待处理</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/《windows程序设计》-前四章笔记-小甲鱼/171005auhg2n8gpc76xgwu.jpg" alt="img" style="zoom:80%;" /><p>消息队列分为</p><p>队列消息</p><ul><li><p>队列消息是指那些由 Windows 放入消息队列的消息，主要由用户的输入产生，例如按键点击、鼠标移动、窗口重绘、还有定时器消息等。这些消息都是要经过消息循环，通过 GetMessage 检索消息，到 DisapatchMessage 将消息投递到窗口过程中处理。</p></li><li><p>FIFO的形式，先进先处理</p></li><li><p>WM_PAINT，WM_TIMER 和 WM_QUIT 这三个消息属于特例，操作系统会把它们时刻放在消息队列的最后，只有当消息队列里的其他消息都执行完了才会去执行它们。</p></li></ul><p>非队列消息</p><ul><li><p>队列消息以外的其他所有消息我们称之为非队列消息，他们通常是由调用特定的 Windows 函数引起的。</p></li><li><p>非队列化消息会<strong>被直接发到</strong>窗口过程(不用排队)，也就是绕过了系统的消息队列和线程的消息队列。</p></li></ul><blockquote><p>例如，当调用CreateWindow时，操作系统将建立窗口并给窗口过程发送一个WM_CREATE的消息。当调用ShowWindow时，操作系统给窗口过程发送WM_SIZE和WM_SHOWWINDOW消息。而当调用UpdateWindow时，操作系统给窗口过程发送WM_PAINT消息。注意，这些消息都是绕过消息队列直接发给窗口过程的。</p></blockquote><h4 id="消息循环">消息循环</h4><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E3%80%8Awindows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B-%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B0%8F%E7%94%B2%E9%B1%BC/1720273xgxrdg8gygdltm8.jpg" alt="img"></p><p>应用程序的消息机制主要由消息循环来处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetMessage 函数从应用程序的队列里取出一个消息,</p><ul><li>如果这个消息是 WM_QUIT（程序退出消息）就返回 0，结束 while 循环。（应用程序被关闭的时候，系统会发送一条 WM_QUIT 消息给消息队列。）</li><li>如果不是退出消息，那么就执行 TranslateMessage 翻译消息，这个操作主要是对一些消息进行转换，例如把键盘的虚拟键消息转换为字符消息</li></ul><p>接着调用 DispatchMessage 将消息分派给相应的窗口过程。</p><blockquote><p>注意：他不是直接通过 DispatchMessage 调用我们的窗口过程 WndProc，这里其实 DispatchMessage 是带着消息<strong>去找操作系统，然后再由操作系统带着MSG结构前四个成员值作为参数去调用</strong> WndProc 窗口过程。（因此才叫 CALLBACK 回调）</p><p>看起来有点纠结哈，不过这就是消息机制的一个真实面目，操作系统为了绝对的控制权，时时刻刻都监控着应用程序的运行。</p></blockquote><h3 id="窗口过程-2">窗口过程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span> <span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;                           <span class="comment">//WndProc这四个函数参数是msg结构变量中的前四位成员</span></span><br><span class="line">     HDC         hdc ;      <span class="comment">//设备环境句柄</span></span><br><span class="line">     PAINTSTRUCT ps ;       <span class="comment">//绘制结构</span></span><br><span class="line">     RECT        rect ;     <span class="comment">//矩阵结构</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">switch</span> (message)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">          PlaySound (TEXT (<span class="string">&quot;hellowin.wav&quot;</span>), <span class="literal">NULL</span>, SND_FILENAME | SND_ASYNC) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">          hdc = BeginPaint (hwnd, &amp;ps) ;</span><br><span class="line">          </span><br><span class="line">          GetClientRect (hwnd, &amp;rect) ;</span><br><span class="line">          </span><br><span class="line">          DrawText (hdc, TEXT (<span class="string">&quot;Hello, Windows 98!&quot;</span>), <span class="number">-1</span>, &amp;rect,</span><br><span class="line">                    DT_SINGLELINE | DT_CENTER | DT_VCENTER) ;</span><br><span class="line">          </span><br><span class="line">          EndPaint (hwnd, &amp;ps) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">          PostQuitMessage (<span class="number">0</span>) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> DefWindowProc (hwnd, message, wParam, lParam) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在窗口过程中，我们对感兴趣的消息进行监控并部署相应的代码<code>switch和case语句</code>，对不感兴趣的消息我们都扔给DefWindowProc，让操作系统以默认的方式来处理消息。</p><p>窗口过程对客户区和非客户区产生的消息都响应，但一般非客户区产生的消息留给 DefWindowProc 函数来默认处理，窗口过程比较需要关心客户区的绘制。</p><h4 id="调用问题">调用问题</h4><p>Windows 编程中有句名言：**Don’t call me, I will call you.**讲的就是谁调用谁的道理。</p><p>用户对窗口所有的操作都会触发相应的事件，而 Windows 把所有的事件转换为对应的消息，所有对窗口过程的调用都是以消息的形式触发，<em>我们写的大部分代码都是致力于对各种消息的处理和响应</em>。</p><p>消息机制就是 Windows 的核心机制，那消息机制有多重要呢？这么说吧，以前C语言调用我们自己的函数，我们直接通过函数名调用即可，对吧？但是在 Windows 编程的做法可不是这样了。我们要调用自己写的函数，会选择通过发送消息给 Windows，然后由 Windows 再来通过消息间接调用我们的函数。初学 Windows 编程的童鞋可能觉得这样很没效率，但这样做恰恰是为了保证你的程序的高效实现，这就是 Windows 编程的游戏规则！</p><h3 id="其它问题">其它问题</h3><ol><li><p>如果把 ShowWindow 和 UpdateWindow 函数去掉，应用程序可以正常响应消息吗？</p><p>答：可以，因为在调用完 CreateWindow 函数的时候窗口就已经创建出来了，只是存在内存中，还没有生成窗口界面而已。这时候属于该应用程序的消息队列也已经生成，因此应用程序可以正常响应消息。简单的说，这时候应用程序的灵已经存在了</p></li><li><p>请问第一个 WM_PAINT 消息是哪个 ShowWindow 还是 UpdateWindow 函数发送的？</p><p>答：调用 ShowWindow 会把定制好的窗口框架显示出来，此时并不发送 WM_PAINT 消息，是 UpdateWindow 函数发送第一个 WM_PAINT 消息，让窗口过程响应 WM_PAINT 消息来作出具体的绘画部署。</p></li><li><p>如果把 WM_DESTROY 消息处理中的 PostQuitMessage(0) 去掉，应用程序有什么变化？</p><p>答：应用程序不能直接通过“关闭”按钮关闭应用程序，在 WIN8 下的任务管理器会看到我们的应用程序从“应用”转入“后台进程”，明显程序并没有再内存中被销毁，只是界面不见了而已。</p></li><li><p>使用合适的断点调试程序，并填写以下表格：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>调用函数名</strong></td><td><strong>产生的消息</strong></td></tr><tr><td>RegisterClass</td><td></td></tr><tr><td>CreateWindow</td><td></td></tr><tr><td>ShowWindow</td><td></td></tr><tr><td>UpdateWindow</td><td></td></tr></tbody></table><p>答：</p><table><thead><tr><th><strong>调用函数名</strong></th><th><strong>产生的消息</strong></th></tr></thead><tbody><tr><td>RegisterClass</td><td>没有消息</td></tr><tr><td>CreateWindow</td><td>WM_GETMINMAXINFO <br />WM_NCCREATE <br />WM_NCCALCSIZE <br />WM_CREATE</td></tr><tr><td>ShowWindow</td><td>WM_SHOWWINDOW <br />WM_WINDOWPOSCHANGING <br />WM_ACTIVATEAPP <br />WM_NCACTIVATE <br />WM_GETICON <br />WM_ACTIVATE <br />WM_IME_SETCONTEXT <br />WM_IME_NOTIFY <br />WM_SETFOCUS <br />WM_NCPAINT <br />WM_ERASEBKGND <br />WM_WINDOWPOSCHANGED <br />WM_SIZE WM_MOVE</td></tr><tr><td>UpdateWindow</td><td>WM_PAINT</td></tr></tbody></table></li><li><p>WinMain 函数的返回值 msg.wParam 是个什么东西？</p><p>答：镜头回到消息循环退出的那一瞬：GetMessage 函数从消息队列里拿到WM_QUIT 消息，返回 0 退出消息循环。此时，msg 变量存放的还是 WM_QUIT 消息，因此 msg.wParam 是WM_QUIT 消息结构的 wParam 成员。对于视频演示中的例子，该值是由此前我们调用 PostQuitMessage 函数所使用的参数决定。</p></li><li><p>窗口过程里边都有返回值，这个返回值是返回到哪里？</p><p>答：Windows 将窗口过程的返回值原封不动作为 DispatchMessage 函数的返回值返回，尽管这个返回值的含义依赖于被响应的消息，但通常被忽略。</p></li><li><p>请自行搜索材料，并总结什么是“抢占式多任务处理”？</p><p>答：抢占式多任务处理（Preemption）是计算机操作系统中，一种实现多任务处理（multi task）的方式，相对于协作式多任务处理而言。协作式环境下，下一个进程被调度的前提是当前进程主动放弃时间片；抢占式环境下，操作系统完全决定进程调度方案，操作系统可以剥夺耗时长的进程的时间片，提供给其它进程。<br>Windows NT是抢占式多任务环境，这就意味着当一个程序完成一项非常耗时的工作时，Windows允许用户将控制权切换到其他程序上。<br>这本是一件非常棒的设计，但这种抢占式多任务模式未必总是会按照你期望的方式去工作。例如，假如你的程序处理某条特定消息需要花费1~2分钟的时间，的确，在这期间，用户可以切换到其他程序，但是此时用户无法对你的程序做任何操作，这时候用户就会开始抱怨了，马勒戈壁，这程序怎么卡得更妈蛋一样……举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">                        ;<span class="comment">//处理WM_LBUTTONUP这条消息花费时间太长，就无法响应用户对这个窗口的其他操作，因为要处理完一条消息后才能处理下一条消息</span></span><br><span class="line">                MessageBox(hwnd, TEXT(<span class="string">&quot;哎呀，我丫的被按了一下~&quot;</span>), TEXT(<span class="string">&quot;好舒服~&quot;</span>), MB_OK);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是一个极端的例子，但一定要注意，不要在处理某条消息上耗费太大的时间，这样的用户体验会很差！</p></li></ol><h1>文本输出</h1><h2 id="GDI">GDI</h2><p>​Windows有三大核心部件，它们分别是内核（kernel）、用户（user）和GDI。</p><p>我们所调用的大部分API函数都是封装在这三个子系统中。</p><ul><li>内核kernel（在16位的KRNL386.exe及32位的KEREL32.DLL中实现）负责操作系统的那些传统工作，包括内存管理、文件输入/输出及任务管理等</li><li>用户user（在16位的GDI.exe及32位的User32.DLL中实现）主要负责所有的窗口管理，也就是用户界面</li><li>GDI（在16位的GDI.exe.及32位的GDI32.DLL中实现）就是图形设备接口，负责在屏幕或打印机上绘制文本和图形。</li></ul><p>​想要绘制客户区的前提条件是获得设备环境句柄，可以把设备环境句柄认为是应用程序使用GDI函数的“通行证”。有了它，我们才可以随心所欲地绘制你的客户区。</p><h2 id="设备环境-Device-Context">设备环境(Device Context)</h2><p>​设备环境（Device Context，简称DC）也叫设备上下文或设备描述表，是GDI内部维护的一个数据结构，它与特定的显示设备或打印设备相关联。这个数据结构里边存放在着一些属性，决定着需要打印的文本的颜色、文本的背景色、以及对本对齐的基准点等等。</p><p>​<strong>程序在处理同一条消息的过程中，获取句柄和释放句柄必须成对使用！</strong></p><h3 id="获得设备环境句柄的两种方式">获得设备环境句柄的两种方式</h3><p>方式一：在处理WM_PAINT消息时使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM__PAINT:</span><br><span class="line">hdc=BeginPaint(hwnd, &amp;ps);</span><br><span class="line">[使用GDI函数]</span><br><span class="line">EndPaint(hwnd, &amp;ps);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>方法二：适用于任何时候</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hdc=GetDC(hwnd);</span><br><span class="line">[使用GDI函数]</span><br><span class="line">ReleaseDC(hwnd, hdc);</span><br></pre></td></tr></table></figure><h2 id="TextOut及文本相关概念">TextOut及文本相关概念</h2><p>​TextOut函数是显示文本最重要的GDI函数</p><p>​DrawText 函数功能虽然强大，但无法指定想要输出的位置。</p><p>而 TextOut 函数可以，TextOut与DrawText相比较起来要简单的多，且可以指定字符串的具体位置。</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextOut(hdc, <span class="number">400</span>, <span class="number">300</span>, TEXT(<span class="string">&quot;I love FishC.com!&quot;</span>), <span class="number">17</span>);</span><br></pre></td></tr></table></figure><p>效果：</p><p>​<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mrow><mi>x</mi><mtext>方向</mtext><mn>30</mn><msup><mn>0</mn><mn>2</mn></msup><mo>+</mo><mi>y</mi><mtext>方向</mtext><mn>40</mn><msup><mn>0</mn><mn>2</mn></msup></mrow></msqrt><mo>=</mo><mtext>斜边</mtext><mn>500</mn></mrow><annotation encoding="application/x-tex">\sqrt{x方向300^2 +y方向400^2}=斜边500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.2822em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9578em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord mathnormal">x</span><span class="mord cjk_fallback">方向</span><span class="mord">30</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">方向</span><span class="mord">40</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.9178em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2822em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">斜边</span><span class="mord">500</span></span></span></span></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E3%80%8Awindows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B-%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B0%8F%E7%94%B2%E9%B1%BC/image-20210803200925565.png" alt="image-20210803200925565"></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E3%80%8Awindows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B-%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B0%8F%E7%94%B2%E9%B1%BC/image-20210803201154589.png" alt="image-20210803201154589"></p><p>​<strong>要注意的一点是 TextOut 函数对齐的基准点取决于当前的文本对齐模式。</strong></p><p>​文本对齐模式默认是TA_LEFT, TA_TOP 和 TA_NOUPDATECP</p><blockquote><p>通过下断点调试以下代码可以得到默认文本对齐模式的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;……UINT uAlign;……<span class="keyword">case</span> WM_PAINT:           uAlign = GetTextAlign(hdc);……</span><br></pre></td></tr></table></figure><p>uAlign是0</p><p>因为对齐模式的定义是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/* Text Alignment Options */</span><span class="meta">#<span class="meta-keyword">define</span> TA_NOUPDATECP                0#<span class="meta-keyword">define</span> TA_UPDATECP                      1#<span class="meta-keyword">define</span> TA_LEFT                                 0#<span class="meta-keyword">define</span> TA_RIGHT                              2#<span class="meta-keyword">define</span> TA_CENTER                           6#<span class="meta-keyword">define</span> TA_TOP                                 0#<span class="meta-keyword">define</span> TA_BOTTOM                         8#<span class="meta-keyword">define</span> TA_BASELINE                       24#<span class="meta-keyword">if</span> (WINVER &gt;= 0x0400)#<span class="meta-keyword">define</span> TA_RTLREADING                256#<span class="meta-keyword">define</span> TA_MASK       (TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING)#<span class="meta-keyword">else</span>#<span class="meta-keyword">define</span> TA_MASK       (TA_BASELINE+TA_CENTER+TA_UPDATECP)#<span class="meta-keyword">endif</span>#<span class="meta-keyword">define</span> VTA_BASELINE TA_BASELINE#<span class="meta-keyword">define</span> VTA_LEFT            TA_BOTTOM#<span class="meta-keyword">define</span> VTA_RIGHT         TA_TOP#<span class="meta-keyword">define</span> VTA_CENTER      TA_CENTER#<span class="meta-keyword">define</span> VTA_BOTTOM    TA_RIGHT#<span class="meta-keyword">define</span> VTA_TOP             TA_LEFT</span></span><br></pre></td></tr></table></figure><p>TA_LEFT, TA_TOP 和 TA_NOUPDATECP 都是 0，因此 TA_LEFT | TA_TOP | TA_NCUPDATECP 当然也为 0</p></blockquote><hr><p>问：下列代码输出的文本如何显示？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:    hdc = BeginPaint(hwnd, &amp;ps);    SetTextAlign(hdc, GetTextAlign(hdc) | TA_RIGHT);<span class="comment">//TA_RIGHT设置基准点在限定矩阵的右边上    TextOut(hdc, 0, 0, TEXT(&quot;I love FishC.com!&quot;), 17);    EndPaint(hwnd, &amp;ps);</span></span><br></pre></td></tr></table></figure><p>错误认为：<img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E3%80%8Awindows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B-%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B0%8F%E7%94%B2%E9%B1%BC/115447t9z2nnxzxz200d7s.png" alt="img"></p><p>实际上：<img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E3%80%8Awindows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B-%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B0%8F%E7%94%B2%E9%B1%BC/115448dna5daaxncjn4no5.png" alt="img"></p><p>原因：</p><p>​TA_RIGHT是设置基准点在限定矩阵的右边上，限定矩形是指能将正文字符串的所有字符单元限定于其中的矩形，而不是窗口的内边框。</p><p>​TextOut中的x，y坐标应该是限定矩形的基准点的坐标位置，将文字对齐方式设为TA-RIGHT,且原来文本对齐模式默认是TA_TOP等,这样将基准点定位在限定矩形的右上角，又坐标为 0 , 0，这样整个矩形就在客户区之外，自然看不到文字了</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E3%80%8Awindows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B-%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B0%8F%E7%94%B2%E9%B1%BC/004413v0e9refyp7p23bpy.png" alt="img"></p><p>‘字符框’：一串字符构成的字符串形成的一个矩形“长条”</p><p>“锚点”：SetTextAlign第二个参数，指定的就是这个‘字符框’的锚点</p><p>​<strong>如果想要把一个有大小（起码不止一个点）的物体放到一个位置上，仅仅指定这个位置是不够的，还需要一个锚点，也就是物体本身上的参照点。目的位置和锚点共同确定了放置情况的唯一性。</strong></p><blockquote><p>好文：</p><p>​<a href="https://blog.csdn.net/weixin_37818081/article/details/89036506">Windows API SetTextAlign之我所见</a></p></blockquote><p>练一下：使用TextOut函数居中显示“I love <a href="http://FishC.com">FishC.com</a>!”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:                hdc = BeginPaint(hwnd, &amp;ps);                GetClientRect(hwnd, &amp;rect);                SetTextAlign(hdc, GetTextAlign(hdc) | TA_CENTER);<span class="comment">//矩阵本身的锚点设置为中心                TextOut(hdc, (rect.right-rect.left)/2, (rect.bottom-rect.top)/2, TEXT(&quot;I love FishC.com!&quot;), 17);//x取中间，y取中间，指定为客户区中心点                EndPaint(hwnd, &amp;ps);                return 0;</span></span><br></pre></td></tr></table></figure><p>那么就是这样放了：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E3%80%8Awindows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B-%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B0%8F%E7%94%B2%E9%B1%BC/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzgxODA4MQ==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><h2 id="安全地使用字符串">安全地使用字符串</h2><p>​微软由于过去对字符串处理函数的缓冲区保护非常薄弱，所以常常会有缓冲区溢出的问题出现，以至于后来有很长一段时间，缓冲区溢出攻击成为Hacker的主流手段。</p><p>​因此，我们提倡使用安全的字符串处理函数代替：</p><table><thead><tr><th><strong>旧的字符串处理函数</strong></th><th><strong>新的字符串处理函数</strong></th></tr></thead><tbody><tr><td><a href="http://bbs.fishc.com/thread-49698-1-1.html">lstrlen</a></td><td><a href="http://bbs.fishc.com/thread-49704-1-1.html">StringCchLength</a></td></tr><tr><td><a href="http://bbs.fishc.com/thread-49691-1-1.html">wprintf</a></td><td><a href="http://bbs.fishc.com/thread-49693-1-1.html">StringCchPrintf</a></td></tr><tr><td><a href="http://bbs.fishc.com/thread-49708-1-1.html">lstrcat</a></td><td><a href="http://bbs.fishc.com/thread-49707-1-1.html">StringCchCat</a></td></tr><tr><td><a href="http://bbs.fishc.com/thread-49714-1-1.html">lstrcpy</a></td><td><a href="http://bbs.fishc.com/thread-49713-1-1.html">StringCchCopy</a></td></tr></tbody></table><p>​注：使用安全字符串处理函数，需要头文件 strsafe.h</p><p>​安全字符串函数相比原来的字符串函数安全在于，在调用的时候<strong>需要提供缓冲区大小的参数</strong>来限定缓冲区的最大范围，避免程序员的前期设计疏忽而导致缓冲区溢出攻击。</p><hr><p>​没有’\0’结尾，lstrlen会一直往后找直到有’\0’为止</p><p>例题：发现并改错</p><p>​以下代码，我本希望将字符串打印到窗口正中间，但却跟着打印出一些乱码（如下图），请问是什么原因导致呢？顺便麻烦帮忙修改一下。</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E3%80%8Awindows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B-%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B0%8F%E7%94%B2%E9%B1%BC/165827vdmk94p1x1d3z1q9.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>&#123;        HDC hdc;        PAINTSTRUCT ps;        RECT rect;        TCHAR buffer[<span class="number">17</span>] = TEXT(<span class="string">&quot;I love FishC.com!&quot;</span>);        <span class="keyword">switch</span> (message)        &#123;        <span class="keyword">case</span> WM_PAINT:                hdc = BeginPaint(hwnd, &amp;ps);                GetClientRect(hwnd, &amp;rect);                                SetTextAlign(hdc, GetTextAlign(hdc) | TA_CENTER);                TextOut(hdc, (rect.right - rect.left) / <span class="number">2</span>, (rect.bottom - rect.top) / <span class="number">2</span>, buffer, lstrlen(buffer));                                EndPaint(hwnd, &amp;ps);                <span class="keyword">return</span> <span class="number">0</span>;        <span class="keyword">case</span> WM_DESTROY:                PostQuitMessage(<span class="number">0</span>);                <span class="keyword">return</span> <span class="number">0</span>;        &#125;        <span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);&#125;</span><br></pre></td></tr></table></figure><p>​问题出现在声明 buffer 变量的时候粗心了，由于“I love <a href="http://FishC.com">FishC.com</a>!”总共有17个字符，那么 TCHAR buffer[17] = TEXT(“I love <a href="http://FishC.com">FishC.com</a>!”); 的话，buffer 变量就不包含空字符（‘\0’），而 lstrlen 是依据空字符来计算字符串的长度，因此 lstrlen 会计算出错误的结果。</p><p>更正后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">……<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;strsafe.h&quot;</span>……LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123;        HDC hdc;        PAINTSTRUCT ps;        RECT rect;        size_t iTarget;        TCHAR buffer[] = TEXT(<span class="meta-string">&quot;I love FishC.com!&quot;</span>);        switch (message)        &#123;        case WM_PAINT:                hdc = BeginPaint(hwnd, &amp;ps);                GetClientRect(hwnd, &amp;rect);                                StringCchLength(buffer, 1024, &amp;iTarget);<span class="comment">//传入iTarget，函数调用后iTarget为传入的字符串的字符个数，不包括&#x27;\0&#x27;                SetTextAlign(hdc, GetTextAlign(hdc) | TA_CENTER);                TextOut(hdc, (rect.right - rect.left) / 2, (rect.bottom - rect.top) / 2, buffer, iTarget);                                EndPaint(hwnd, &amp;ps);                return 0;        case WM_DESTROY:                PostQuitMessage(0);                return 0;        &#125;        return DefWindowProc(hwnd, message, wParam, lParam);&#125;</span></span></span><br></pre></td></tr></table></figure><hr><p>例：以下代码打印什么内容？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCHAR szBuffer[<span class="number">128</span>];        <span class="keyword">size_t</span> iTarget;        ……        <span class="keyword">case</span> WM_PAINT:                hdc = BeginPaint(hwnd, &amp;ps);                StringCchPrintf(szBuffer, <span class="number">13</span>, TEXT(<span class="string">&quot;%s&quot;</span>), TEXT(<span class="string">&quot;I love FishC.com!&quot;</span>));<span class="comment">//I love FishC.com!是17个字符                StringCchLength(szBuffer, 13, &amp;iTarget);                TextOut(hdc, 10, 10, szBuffer, iTarget);                EndPaint(hwnd, &amp;ps);                return 0;</span></span><br></pre></td></tr></table></figure><p>答：</p><p>​会打印字符串的前 12 个字符：I love FishC?</p><p>​由于 StringCchPrintf(szBuffer, 13, TEXT(“%s”), TEXT(“I love <a href="http://FishC.com">FishC.com</a>!”)); 限定了缓冲区的长度为 13，因此会将字符串的前 12 个字符加 1 个 ‘\0’ 写入到缓冲区中（为了确保不会发生越界访问）</p><p>例子：但即使用了安全字符串函数也可能…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCHAR szBuffer[<span class="number">17</span>];        <span class="keyword">size_t</span> iTarget;        ……        <span class="keyword">case</span> WM_PAINT:                hdc = BeginPaint(hwnd, &amp;ps);                StringCchPrintf(szBuffer, <span class="number">128</span>, TEXT(<span class="string">&quot;%s&quot;</span>), TEXT(<span class="string">&quot;I love FishC.com!&quot;</span>));                StringCchLength(szBuffer, <span class="number">128</span>, &amp;iTarget);                TextOut(hdc, <span class="number">10</span>, <span class="number">10</span>, szBuffer, iTarget);                EndPaint(hwnd, &amp;ps);                <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>答：虽然使用了安全字符串函数，但由于程序猿写代码时打瞌睡了，因此还是造成了程序崩溃。</p><p>​该程序崩溃的原因是 szBuffer 字符串声明的长度不够（17），StringCchPrintf 函数刚好往 szBuffer 写入 17 字符，因此 szBuffer 并没有足够的空间写入字符串结束符 ‘\0’，导致 TextOut 函数读取到没有结束符的 szBuffer 字符串而崩溃。</p><p>（有联系的题）</p><p>例：按要求写代码：使用安全字符串函数 StringCchCat 将两个字符串（“no zuo no die” 和 “why you try”）合并在第一个字符串中。要求检测结果，如果合并成功，则将字符串打印到窗口客户区的中间位置，如果合并失败，则弹出&quot;合并失败&quot;的消息框。</p><p>答:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">……<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;strsafe.h&quot;</span>……LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123;        HDC hdc;        PAINTSTRUCT ps;        RECT rect;            size_t iTarget;        HRESULT hr;            TCHAR buffer1[128] = TEXT(<span class="meta-string">&quot;no zuo no die &quot;</span>);        TCHAR buffer2[128] = TEXT(<span class="meta-string">&quot;why you try&quot;</span>);        switch (message)        &#123;        case WM_PAINT:                hdc = BeginPaint(hwnd, &amp;ps);                GetClientRect(hwnd, &amp;rect);                                hr = StringCchCat(buffer1, 256, buffer2);<span class="comment">//SStringCchCat返回一个HRESULT，而不是拼接好的字符串指针，建议使用SUCCEEDEN和FAILED宏来测试这个函数的返回值                if (SUCCEEDED(hr))                &#123;                        StringCchLength(buffer1, 1024, &amp;iTarget);//第三个参数指向字符串的字符个数                                            SetTextAlign(hdc, GetTextAlign(hdc) | TA_CENTER);//更加常用的情况，SetTextAlign放TextOut前一句吧                        TextOut(hdc, (rect.right - rect.left) / 2, (rect.bottom - rect.top) / 2, buffer1, iTarget);                &#125;                else                &#123;                        MessageBox(hwnd, TEXT(&quot;抱歉，合并失败！&quot;), TEXT(&quot;警告&quot;), MB_OK | MB_ICONWARNING);                &#125;                EndPaint(hwnd, &amp;ps);                return 0;        case WM_DESTROY:                PostQuitMessage(0);                return 0;        &#125;        return DefWindowProc(hwnd, message, wParam, lParam);&#125;</span></span></span><br></pre></td></tr></table></figure><p>几点问题：（改一下）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCHAR buffer1[<span class="number">128</span>] = TEXT(<span class="string">&quot;no zuo no die &quot;</span>);<span class="comment">//算上&#x27;\0&#x27;是15个字符        TCHAR buffer2[128] = TEXT(&quot;why you try&quot;);//算上&#x27;\0&#x27;是12个字符                hr = StringCchCat(buffer1, 256, buffer2);StringCchLength(buffer1, 1024, &amp;iTarget);</span></span><br></pre></td></tr></table></figure><p>mark以后有时间再研究buffer1[]、StringCchCat中的缓冲区大小对于结果的影响：</p><p>TCHAR buffer1[这里肯定要&gt;=14+11+一个’\0’即26]，即便hr = StringCchCat(buffer1, 256, buffer2);这里的缓冲区大小＞26，和上边程序猿打瞌睡的结果一样，因为buffer1没有足够空间放拼接后的字符串，会导致拼接失败？？</p><hr><p>其他问题：</p><ol><li><p>StringCchPrintf 和 StringCbPrintf函数之间的区别：</p><p>答：区别在于第二个参数。StringCchPrintf 是按<strong>字符</strong>计算字符串的长度，StringCbPrintf 是按<strong>字节</strong>计算字符串的长度。</p></li><li><p>size_t 是什么类型？</p><p>答：在 C/C++ 中，设计 size_t 就是为了适应多平台，size_t 的引入增强了程序在不同平台上的可移植性。</p><p>size_t 是针对系统定制的一种数据类型，一般是整型，因为 C/C++ 标准只定义最低的位数，而不是必需的固定位数。而且在内存里，对数的高位对齐存储还是低位对齐存储各系统都不一样。为了提高代码的可移植性，就有必要定义这样的数据类型。</p><p>一般这种类型都会定义到它具体占几位内存等。当然，有些是编译器或系统已经给定义好的。经测试发现，在 32 位系统中 size_t 是 4 字节的，而在 64 位系统中，size_t 是 8 字节的，这样利用该类型可以增强程序的可移植性。</p></li></ol><h2 id="不要试图猜测文本的尺寸">不要试图猜测文本的尺寸</h2><p>​我们一般在响应 WM_CREATE 消息时设置字体等初始化信息（WM_CREATE消息是窗口过程收到的第一条消息。当应用程序再WinMain中调用CreateWindow时，Windows将传送一条WM_CREATE消息给窗口过程），注意这些变量应该设置为 static 类型，因为我们会在今后的不同消息中使用它们。</p><h1>API档案及扩展内容</h1><h2 id="MessageBox">MessageBox</h2><h2 id="WinMain">WinMain</h2><p>函数原型：</p><p><em>注释：<em>In</em> 说明该参数是输入的。</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(  _In_ HINSTANCE hInstance,     <span class="comment">//指定应用程序当前实例的句柄  _In_ HINSTANCE hPrevInstance, //指定一个应用程序的前一个实例的句柄  _In_ LPSTR     lpCmdLine,     //该应用程序的命令行  _In_ int       nCmdShow       //控制窗口如何显示，参数从表中选);</span></span></span></span><br></pre></td></tr></table></figure><p>返回值：</p><p>\1. 如果程序执行成功，并且它收到一个 <a href="http://bbs.fishc.com/thread-73784-1-1.html">WM_QUIT</a> 消息时，它应该返回包含在该消息的 wParam 参数的值。如果程序在进入消息循环之前终止，它应该返回 0</p><p>备注：</p><p>\2. 你的 WinMain 应初始化应用程序，显示其主窗口，然后进入一个消息循环循环，应用程序执行代码。当接收到一个 <a href="http://bbs.fishc.com/thread-73784-1-1.html">WM_QUIT</a> 消息时，终止消息循环。在这一点上，你的 WinMain 函数应该返回并退出应用程序，返回在 <a href="http://bbs.fishc.com/thread-73784-1-1.html">WM_QUIT</a> 消息的 wParam 参数的值。收到 <a href="http://bbs.fishc.com/thread-73784-1-1.html">WM_QUIT</a> 消息是调用 <a href="http://bbs.fishc.com/thread-47805-1-1.html">PostQuitMessage</a> 函数的结果， wParam 参数的值是 <a href="http://bbs.fishc.com/thread-47805-1-1.html">PostQuitMessage</a> 函数的 nExitCode 参数的值。有关详细信息，请查看<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644928(v=vs.85).aspx#creating_loop">创建一个消息循环</a>。</p><blockquote><p><a href="https://fishc.com.cn/forum.php?mod=viewthread&amp;tid=73544&amp;highlight=winmain">WinMain-鱼C论坛</a></p></blockquote><h2 id="PostQuitMessage">PostQuitMessage</h2><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">PostQuitMessage</span><span class="params">(  _In_  <span class="keyword">int</span> nExitCode)</span></span>;</span><br></pre></td></tr></table></figure><p>备注：</p><p>\1. PostQuitMessage 函数的功能是发送一个 WM_QUIT 消息给线程的消息队列并立即返回。</p><p>\2. 当线程从消息队列里取得 WM_QUIT 消息时，应当退出消息循环并将返回系统，返回给系统的退出值必须是消息 WM_QUIT 的 wParam 参数（<strong>所以 WinMain 函数的返回值是 msg.wParam</strong>）。</p><blockquote><p>PostQuitMessage<br><a href="https://fishc.com.cn/thread-47805-1-1.html">https://fishc.com.cn/thread-47805-1-1.html</a><br>(出处: 鱼C论坛)</p></blockquote><h2 id="RECT结构">RECT结构</h2><p>​RECT 结构定义了一个矩形的左上角和右下角的坐标。</p><p>结构原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RECT</span> &#123;</span>  LONG left;  LONG top;  LONG right;  LONG bottom;&#125; RECT, *PRECT;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>成员</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>left</td><td>指定矩形左上角的 x 坐标</td></tr><tr><td>top</td><td>指定矩形左上角的 y 坐标</td></tr><tr><td>right</td><td>指定矩形右下角的 x 坐标</td></tr><tr><td>bottom</td><td>指定矩形右下角的 y 坐标</td></tr></tbody></table><p>RECT 结构定义了一个矩形的左上角和右下角的坐标，以此来定位一个矩形的位置以及范围，如下，只需知道 A 点和 D 点的坐标，即可求出 B 点和 C 点的坐标以及整个矩形的面积等数据。</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/%E3%80%8Awindows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B-%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B0%8F%E7%94%B2%E9%B1%BC/184335ttz4ene3qj3ttuiz.png" alt="img"></p><h2 id="lstrlen">lstrlen</h2><p>​函数用于计算指定字符串的长度（不包含’\0），该函数返回指定字符串的字符数。</p><p><strong>注意：实际编程中不要再使用该函数，请使用 <a href="http://bbs.fishc.com/thread-49704-1-1.html">StringCchLength</a> 或 StringCbLength 代替。</strong></p><p>API函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">lstrlen</span><span class="params">(  _In_  LPCTSTR lpString)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpString</td><td>指向以’\0’为终止符的字符串</td></tr></tbody></table><p><strong>返回值：</strong></p><p>\1. 该函数返回指定字符串的字符数；</p><p>\2. 如果是空字符串，则返回 0。</p><p>​lstrlen 函数假定 lpString 参数是以’\0’结尾的字符串，但如果事实上传入的参数不按套路（没以’\0’结尾）出牌，你传进去的字符串即便被搜索完了，lstrlen仍然会一直往后算，直到找到恰好有’\0’，这会存在安全隐患，被艺高人胆大的黑客用精心构造的数据造成缓冲区溢出，最终导致程序无法按照期望正常运行。</p><p>​错误的使用 lstrlen 函数将可能会危害到应用程序的安全。</p><h2 id="StringCchcat">StringCchcat</h2><p>函数功能：</p><p>​StringCchCat 函数的功能是将一个字符串拼接到另一个字符串。</p><p>​StringCchCat 函数要求提供目标缓冲区的长度，以确保写入数据不会超出缓冲区的末尾。</p><p>微软推荐使用该函数替代以下函数：</p><ul><li>strcat, wcscat, _tcsat</li><li>lstrcat</li><li>StrCat</li><li>StrCatBuff</li></ul><p>API函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchCat</span><span class="params">(  _Inout_  LPTSTR pszDest,  _In_     <span class="keyword">size_t</span> cchDest,  _In_     LPCTSTR pszSrc)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>pszDest</td><td>1. 目标缓冲区，同时包含第一个字符串 <br />2. 该缓冲区必须大于或等于 pszDest + pszSrc + 1（两个字符串的字符总和+‘\0’）</td></tr><tr><td>cchDest</td><td>1. 目标缓冲区的大小（字符个数）<br /> 2. 该值必须大于或等于 pszDest + pszSrc + 1（两个字符串的字符总和+‘\0’） <br />3. 这个数不能超过 STRSAFE_MAX_CCH</td></tr><tr><td>pszSrc</td><td>第二个字符串</td></tr></tbody></table><p>返回值：</p><p>这个函数返回一个 HRESULT，而不是拼接好的字符串指针。我们强烈建议您使用 <a href="http://bbs.fishc.com/thread-49703-1-2.html">SUCCEEDED</a> 和 <a href="http://bbs.fishc.com/thread-49703-1-2.html">FAILED</a> 宏来测试这个函数的返回值。</p><p>返回值可以是以下任意一个值：</p><table><thead><tr><th><strong>返回代码</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>S_OK</td><td>字符串正常拼接</td></tr><tr><td>STRSAFE_E_INVALID_PARAMETER</td><td>1. cchDest 参数的值为 0 <br />2. cchDest 参数的值大于 STRSAFE_MAX_CCH <br />3. 目标缓冲区空间已满</td></tr><tr><td>STRSAFE_E_INSUFFICIENT_BUFFER</td><td>1. 因缓冲区空间不足导致失败 <br />2. 结果被截断，当仍然包含’\0’结尾 <br />3. 如果截断操作可以被接受，则不一定被看作是失败</td></tr></tbody></table><h2 id="SUCCEEDED和FAILED宏">SUCCEEDED和FAILED宏</h2><p>宏功能：</p><p>​SUCCEEDED 宏表示测试成功，FAILED 宏表示测试失败。</p><p>宏原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SUCCEEDED</span><span class="params">(   HRESULT hr)</span></span>;……<span class="function">BOOL <span class="title">FAILED</span><span class="params">(   HRESULT hr)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hr</td><td>1. 状态码 <br />2. 该值可以是 HRESULT 或 SCODE 类型 <br />3. 非负数表示成功 <br />4. 负数表示失败</td></tr></tbody></table><p><strong>返回值：</strong></p><p>\1. 如果 hr 的值大于等于 0，则结果为 TRUE；</p><p>\2. 如果 hr 的值小于 0，则结果为 FALSE。</p><h2 id="StringCchLength">StringCchLength</h2><p>​StringCchLength 函数用于确定字符串是否超过了规定的长度，以字符为计算单位。</p><p>微软推荐使用该函数替代以下函数：</p><ul><li>strlen, wcslen, _tcslen</li></ul><p>API函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchLength</span><span class="params">(  _In_   LPCTSTR psz,  _In_   <span class="keyword">size_t</span> cchMax,  _Out_  <span class="keyword">size_t</span> *pcch)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>psz</td><td>指向待检查的字符串</td></tr><tr><td>cchMax</td><td>1. psz 参数里最大允许的字符数量，包括’\0’ <br />2. 这个数不能超过 STRSAFE_MAX_CCH</td></tr><tr><td>pcch</td><td>1. psz 参数指向字符串的字符个数，不包括’\0’ <br />2. 这个值只有在 psz 指针不为 NULL，且函数成功时有效</td></tr></tbody></table><p><strong>返回值：</strong></p><p>​这个函数返回一个 HRESULT，而不是指定字符串的字符个数。我们强烈建议您使用 <a href="http://bbs.fishc.com/thread-49703-1-1.html">SUCCEEDED</a> 和 <a href="http://bbs.fishc.com/thread-49703-1-1.html">FAILED</a> 宏来测试这个函数的返回值。</p><p>返回值可以是以下任意一个值：</p><table><thead><tr><th><strong>返回代码</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>S_OK</td><td>psz 指向的字符串不为空，且字符串的长度（包括’\0’）小于等于 cchMax</td></tr><tr><td>STRSAFE_E_INVALID_PARAMETER</td><td>1. psz 指向空字符串 <br />2. cchMax 的值大于STRSAFE_MAX_CCH <br />3. psz 指向的字符串的字符个数超过 cchMax</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Windows安全 </category>
          
          <category> 编程篇 </category>
          
          <category> win api </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIN32 API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件偏移地址计算</title>
      <link href="/posts/538d27d6.html"/>
      <url>/posts/538d27d6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>准备删除，待搬运到文章“PE格式”中</p></blockquote><p>知识点：</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703224901946.png" alt="image-20210703224901946" style="zoom:50%;" /><p>红框：位于磁盘中的PE文件（未运行）</p><p>PE文件由一个一个区块组成</p><p><code>文件偏移地址（FOA/ROffest/RAW offset）</code>：相对于文件开头的偏移</p><p>紫框：运行PE文件，操作系统将磁盘中的PE文件加载到内存后</p><p><code>映像基址（Image Base Address）</code>：PE文件装入内存时的基地址</p><blockquote><p>因为有很多进程同时使用内存，运行一个PE文件，操作系统负责在内存中挑选一块空地将PE文件加载进来执行，这块空地的地址加载后你就晓得了，上图中映像基址为0x400000</p></blockquote><p><code>虚拟地址（Virtual Address，VA/VOffest）</code>：PE文件加载进内存后，指令在<strong>虚拟内存</strong>中的<strong>绝对地址</strong></p><blockquote><p>进程看到的是虚拟内存，而不是真实的物理地址，这点不重要</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703225854916.png" alt="image-20210703225854916" style="zoom: 50%;" /></blockquote><p>相对虚拟地址（Relative Virtual Address,RVA）：虚拟内存地址相对于映像基址的<code>偏移量</code></p><hr><p>它们之间的关系：</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703205118380.png" alt="image-20210703205118380" style="zoom: 50%;" /><hr><p>再回到这张图：</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703230308114.png" alt="image-20210703230308114" style="zoom:67%;" /><p>你会发现<strong>PE文件</strong>和<strong>加载到内存后的PE文件</strong>，NULL大小不一样，why？</p><ol><li>在磁盘上的时候，PE文件中的数据是按照磁盘数据标准存放，以0x200字节为基本单位进行组织。当一个数据节（section）不足 0x200 字节时，不足的地方将被 0x00 填充；当一个数据节超过 0x200字节时，下一个 0x200 块将分配给这个节使用。因此 PE 数据节的大小永远是 0x200 的整数倍。</li><li>当代码装入内存后，将按照内存数据标准存放，并以 0x1000 字节为基本单位进行组织。类似的，不足将被补全，若超出将分配下一个 0x1000 为其所用。因此，内存中的节总是0x1000 的整数倍。</li></ol><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703230636614.png" alt="image-20210703230636614" style="zoom:67%;" /><p>因为两者组织的基本单位不同，所以才会有<code>节偏移</code>这个概念</p><blockquote><p>0x200和0x1000不需要记</p></blockquote><p>那么如果我们已知一条指令的地址VA，映像基址也知道了</p><blockquote><p>这是从（紫框）内存中得到数据，然后计算，找出PE文件的位置</p><p>（因为在实际应用中，比如将PE文件载入OD，看到的都是虚拟地址，如果想寻一条指令/数据在PE文件中的位置，就需要进行计算）</p></blockquote><p>我们可以算出这条指令的RVA，但是有了RVA，在红框的PE文件中还差一个东东</p><p>因为<img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703230308114.png" alt="image-20210703230308114" style="zoom: 50%;" /></p><p>右边的NULL比左边的NULL长了，我们要减去这段差异</p><p>如何计算？</p><p>上图红线，这是一条指令，它是位于<code>节(.text)</code>区块，我们可以通过使用这个区块的VA（0x401000）-映像基址0x40000算出它的RVA即0x1000，就是下图这一段</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703231457623.png" alt="image-20210703231457623" style="zoom:67%;" /><p>那么再看<code>节(.text)</code>在PE文件中的文件偏移地址（红笔）</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703231558074.png" alt="image-20210703231558074" style="zoom:67%;" /><p>那么紫色的数值-红色的数值，我们就算出了左右两个NULL的差异，即<code>节偏移</code></p><p>好，用指令的RVA-这个节偏移，就是这个指令在PE文件中的文件偏移地址了</p><hr><p>做题思路：</p><p>1、计算要求指令/数据的RVA</p><p>2、判断这个指令所在的区块，计算该区块的节偏移</p><p>3、用1中的RVA-2中的节偏移，即可算出该指令/数据的文件偏移地址</p><hr><p>题：求虚拟内存地址VA为<strong>0x401500</strong>指令的文件偏移地址</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703205328131.png" alt="image-20210703205328131" style="zoom:67%;" /><p>答：</p><p>由上图可知<code>Image Base映像基址</code>为0x400000</p><p>则：题目所求指令的<code>相对虚拟地址RVA</code>=虚拟内存地址VA-Image Base映像基址=<strong>0x401500</strong>-0x400000=0x1500</p><p>另外，由上图（右边内存）右边各块的起始虚拟内存地址VA，对比题目的虚拟内存地址VA<code>0x401500</code>，知道要计算的指令是位于<code>节(.text)</code>这一区块中</p><p>从图（右边内存）中可得<code>节(.text)</code>这一区块的起始虚拟内存地址VA为0x401000，再减去Image Base映像基址可以算出相对虚拟地址RVA=0x1000</p><p>从图（左边PE文件）中可得<code>节(.text)</code>这一区块的起始<code>文件偏移地址FOA</code>=0x600</p><p>则可以算出：<code>节(.text)</code>的节偏移=RVA-FOA=0x1000-0x600=0x400</p><p>那么这条指令的文件偏移地址=这条指令的RVA-<code>节(.text)</code>偏移=0x1500-0x400=0x1100</p><p>变种1：</p><p>给这个图让你算节偏移</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703232108875.png" alt="image-20210703232108875" style="zoom: 80%;" /><p>上图中<strong>起始偏移地址</strong>是在内存中的VA，起始文件偏移是在PE文件中（未运行在磁盘中）的FOA</p><p>思路：算出要求的指令/数据的RVA后，对比上图中各区段的起始偏移地址，判断位于哪一个区段，然后计算该区段的<code>节偏移</code></p><p>变种2：</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703232331929.png" alt="image-20210703232331929" style="zoom:67%;" /><p>思路：会有干扰，因为你不知道哪个对哪个</p><p>破题：VOffest是虚拟内存地址VA，ROffset是文件偏移地址</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/PE文件偏移地址计算/image-20210703232413094.png" alt="image-20210703232413094" style="zoom:67%;" /><p>参考：</p><p>课本P263~265</p><p>《0day安全软件漏洞分析技术》P8~10</p><p>《加密与解密4》P406</p><p><a href="https://blog.csdn.net/zzy1448331580/article/details/83038481">PE文件的内存映射</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows安全 </category>
          
          <category> 系统篇 </category>
          
          <category> PE格式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全期末复习</title>
      <link href="/posts/977072af.html"/>
      <url>/posts/977072af.html</url>
      
        <content type="html"><![CDATA[<h2 id="自测">自测</h2><p>软件面临的安全威胁：3个</p><p>软件漏洞成因：5点</p><p>软件漏洞分类：3个标准</p><p>漏洞的特点：</p><p>软件漏洞、软件错误、软件缺陷、软件BUG区别</p><p>栈溢出攻击：2种</p><p>堆溢出攻击：2种</p><p>有空：代码分析题</p><p>Windows安全漏洞保护分析：/GS、DEP、ASLR、SafeSEH</p><p>OWASP：前三个</p><p>注入点选择</p><p>Web漏洞防御基本措施</p><p>XSS漏洞哪三种：</p><p>内建安全模型</p><p>等保工作流程</p><p>威胁建模</p><p>软件安全编码中的代码检测有哪些类型</p><p>开发语言JAVA的安全机制</p><p>模糊测试、渗透测试概念，过程，常用工具</p><h2 id="第一章">第一章</h2><h3 id="信息安全三大属性CIA-P9">信息安全三大属性CIA-P9</h3><ul><li>保密性（Confidentiality）[ˌkɑːnfɪˌdenʃiˈæləti]：<ul><li>确保<code>信息资源</code>仅被<code>合法实体</code>(如用户、进程等)访问，使信息不泄露给未授权的实体(反)</li><li>保护数据的存在性</li></ul></li><li>完整性（Integrity）：信息资源只能由授权方式or以授权的方式修改，在存储或传输过程中不被未授权、未预期或无意篡改、销毁，或在<code>篡改后能够被迅速发现</code>。</li><li>可用性（Availability）：信息资源可被合法实体访问<strong>并按要求的特性使用</strong></li></ul><p>其他属性：可认证性、授权、可审计性、抗抵赖性、可控性、可存活性</p><h3 id="实现的机制or方法P9">实现的机制or方法P9</h3><p>保密性：<code>对信息加密</code>or对信息<code>划分密级</code>并为访问者<code>分配访问权限</code>，系统根据用户的身份权限控制对不同密级信息的访问</p><blockquote><p>关键词：加密、划分密级分配访问权限</p></blockquote><p>完整性：预防和检测</p><ul><li>（预防机制通过<code>阻止</code>任何未经授权的方法来<code>改写</code>数据的企图，以确保数据的完整性）</li><li>（检测机制并<code>不试图阻止</code>完整性的破坏，而是通过<code>分析</code>用户或系统的行为，或是数据本身来发现数据的完整性是否遭受破坏）</li></ul><blockquote><p>关键词：预防是阻止、检测是分析</p></blockquote><p>可用性：备份与灾难恢复、应急响应、系统容侵等许多安全措施</p><h3 id="软件面临的安全威胁-目录1-2-P6">软件面临的安全威胁-目录1.2-P6</h3><p>三类：</p><p>软件自身的安全（软件漏洞）</p><ul><li>软件生命周期中与安全相关的<strong>设计错误</strong>、<strong>编码缺陷</strong>及<strong>运行故障</strong>等；</li></ul><p>恶意代码</p><ul><li>在未被授权的情况下，以破坏软硬件设备、窃取用户信息、干扰用户正常使用、扰乱用户心理为目的而编制的<u>软件</u>或<u>代码片段</u></li></ul><p>软件侵权</p><ul><li>侵犯他人软件的合法权益</li></ul><hr><p>拓展：软件侵权具体有哪些行为P8</p><ul><li>未经软件著作权人许可,发表、登记、修改或翻译其软件。</li><li>将他人软件作为自己的软件发表或者登记，在他人软件上署名或者更改他人软件上的署名。</li><li>未经合作者许可，将与他人合作开发的软件作为自己单独完成的软件发表或者登记。</li><li>复制或者部分复制著作权人的软件。</li><li>向公众发行、出租或通过信息网络传播著作权人的软件。</li><li>故意避开或者破坏著作权人为保护其软件著作权而采取的技术措施。</li><li>故意删除或者改变软件权利管理电子信息。</li><li>转让或者许可他人行使著作权人的软件著作权。</li></ul><p>课后习题：</p><p>确保软件安全基本思路？软件安全设计的技术主要有哪些方面？</p><h2 id="第二章">第二章</h2><h3 id="软件漏洞具体指什么P25">软件漏洞具体指什么P25</h3><p>本书的定义：软件系统或产品在设计、实现、配置和运行等过程中，由操作实体<strong>有意</strong>或<strong>无意</strong>产生的缺陷、瑕疵或错误，它们以不同形式存在于信息系统的各个层次和环节之中，且随着信息系统的变化而改变。漏洞一旦被恶意主体所利用，就会造成对信息系统的安全损害，从而影响构建于信息系统之上正常服务的运行,危害信息系统及信息的安全属性。</p><p>各种定义的共性：</p><ul><li>漏洞是信息系统自身具有的弱点或者缺陷。</li><li>漏洞存在环境通常是特定的。</li><li>漏洞具有可利用性，若攻击者利用了这些漏洞，将会给信息系统安全带来严重威胁和经济损失。</li></ul><h3 id="软件漏洞成因P26">软件漏洞成因P26</h3><ol><li><p>计算机系统结构决定了漏洞的必然存性。现今计算机基于冯诺依曼体系，在内存中，代码、数据和指令等任何信息都是以0、1串的形式表示。</p><p>关键词：数据等于指令，指令也等于数据，EIP指向的是指令，也有指向数据区的寄存器，如果把EIP修改，指向了数据区，那么数据会被当成指令来执行。这一点可以被攻击者利用，精心构造畸形数据，</p><p>处理流程可以被改变，CPU经常在各个场地来回跳转，调用函数，会先保存当前地址，然后跳转到目标地址，如果返回地址被篡改，那么CPU的处理流程就被控制了</p></li><li><p>软件趋向大型化，第三方扩展增多</p></li><li><p>新技术、新应用之初即缺乏安全性考虑</p></li><li><p>软件使用场景更具威胁</p></li><li><p>对软件安全开发重视不够，软件开发者缺乏安全知识</p></li></ol><h3 id="软件漏洞分类P30-分析题，结合代码">软件漏洞分类P30 分析题，结合代码</h3><p>分类标准：</p><p>（1）基于漏洞成因</p><ul><li><p>内存破坏</p></li><li><p>逻辑错误</p></li><li><p>输入验证</p></li><li><p>设计错误</p></li><li><p>配置错误</p></li></ul><p>（2）漏洞利用位置</p><ul><li>本地漏洞</li><li>远程漏洞</li></ul><p>（3）威胁类型</p><ul><li>获取控制</li><li>获取信息</li><li>拒绝服务</li></ul><hr><p>扩展：</p><p>漏洞特点：</p><ol><li>持久性与时效性</li><li>广泛性与具体性</li><li>可利用性与隐蔽性</li></ol><hr><p>课后习题：</p><p>辨析：软件漏洞、软件错误、软件缺陷、软件Bug</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/软件安全期末复习/image-20210703104920037.png" alt="image-20210703104920037" style="zoom:67%;" /><h2 id="第三章">第三章</h2><h3 id="什么是缓冲区溢出？什么是栈溢出？P44">什么是缓冲区溢出？什么是栈溢出？P44</h3><p>缓冲区溢出漏洞是在向缓冲区写入数据时，由于没有做边界检查，导致写入（缓冲区的数据）超过预先分配的边界，从而使溢出数据在合法数据上而引起系统异常的一种现象。</p><p>栈溢出是缓冲区溢出漏洞中的一种。栈在计算机中是一种先进后出的数据结构。栈帧是操作系统为进程的每个函数划分的一个空间，由于没有做边界检查，导入写入栈帧的数据超过预先分配的边界，从而使溢出数据会覆盖到其他栈帧的合法数据上，从而引起系统异常。</p><hr><p>扩：</p><p>堆与栈的区别：</p><ul><li>栈先进后出，堆先进先出</li><li>栈由高地址向低地址方向增长空间，堆由低地址向高地址方向增长空间</li></ul><p>栈溢出攻击：P53</p><ol><li><p>JMP ESP</p><p>修改返回地址ESP，跳转到自行制定的Shellcode地址</p></li><li><p>SEH覆盖方法</p><p>Windows下的异常处理机制。</p><p>SHE结构在栈中，攻击者利用栈溢出漏洞，设计特定的溢出数据，将SEH中异常函数的入口地址覆盖为跳转到Shellcode的有关地址。那么程序发生异常后，Windows异常处理机制执行的不是预设的异常处理函数，而是Shellcode</p></li></ol><p>堆溢出攻击P57：</p><ol><li>DWORD Shoot</li><li>Heap Spray</li></ol><p>Windows安全漏洞保护分析P63</p><ul><li>栈溢出检测选项/GS</li></ul><img src= "/img/loading.gif" data-lazy-src="/Typora_images/软件安全期末复习/image-20210702154854068.png" alt="image-20210702154854068" style="zoom:67%;" /><img src= "/img/loading.gif" data-lazy-src="/Typora_images/软件安全期末复习/image-20210702154906412.png" alt="image-20210702154906412" style="zoom:67%;" /><ul><li>数据执行保护DEP</li></ul><p>NX，no eXecute</p><p>使可写内存不可执行or可执行内存不可写</p><p>即可写或可执行，但不允许同时发生</p><ul><li>地址空间布局随机化ASLR（Address Space Layout Randomization）</li></ul><p>通过对堆、栈和共享映射等线性区域布局的随机化，增加攻击者预测目的的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止漏洞利用的目的。</p><ul><li>安全结构化异常处理SafeSEH</li></ul><p>SafeSEH 的实现原理较为简单，就是编译器在链接生成二进制IMACE时，把所有合法的异常处理函数的地址解析出来制成<strong>一张安全的SEH表</strong>，保存在程序的IMAGE 数据块里面，当程序调用异常处理函数时会将函数地址与安全SEH表中的地址<strong>进行匹配</strong>，检查调用的异常处理函数是否位于该表中。如果 IMACE不支持SafeSEH,则表的地址为0。<br>安全结构化异常处理(Safe Structured Exception Handling，SafeSEH）保护机制的作用是防止覆盖和使用存储栈上的SEH结构。如果使用/SafeSEH链接器选项编译和链接一个程序，那么对应二进制的头部将包含一个由所有合法异常处理程序组成的表，当调用异常处理程序时会检查这张表，以确保所需的处理程序在这张表中。这项检查工作是作为ntdll. dll中的RtlDispatchException例程的一部分来完成的,它会执行以下测试。</p><h2 id="第四章">第四章</h2><h3 id="一次Web访问过程以及可能存在的漏洞P76">一次Web访问过程以及可能存在的漏洞P76</h3><p>①域名解析：浏览器会依次查询浏览器的 DNS 缓存、系统缓存、路由器缓存，如果没有找到，则一直查询到根域名服务器缓存，找到域名所对应的 IP 地址。</p><p>②TCP 连接：通过 IP 地址找到 IP 对应的服务器后，要求建立 TCP 连接。</p><p>③HTTP 连接：TCP连接成功后，浏览器开始向这个服务器发送一个 HTTP请求。服务器接收到请求后开始进行处理，处理结束，返回一个响应包。</p><p>④浏览器接收和处理：浏览器接收到来自服务器的响应后，开始解析和渲染接收到的内容并呈现给用户。</p><p>⑤TCP 断开连接：最后客户端断开与服务器的 TCP 连接。</p><h3 id="注入的可利用性P81">注入的可利用性P81</h3><p>SQL注入漏洞是指：攻击者能够利用现有Web应用程序，将恶意的数据插入SQL查询中，提交到后台数据库引擎执行非授权操作</p><p>利用方式：</p><ol><li>注入点选择<ul><li>表单提交</li><li>URL参数提交</li><li>Cookie参数提交</li><li>HTTP请求头部的一些可修改的值，如Referer、User_Agent等</li><li>一些边缘输入点，如.mp3文件的一些文件信息等</li></ul></li><li>数字型和字符型注入P81有空研究闭合字符串？</li><li>通过Web端对数据库注入和直接访问数据库注入<ol><li>通过Web应用程序的用户对数据库进行连接并进行SQL注入攻击</li><li>直接访问数据库进行注入攻击</li></ol></li></ol><h3 id="有关防御P84">有关防御P84</h3><p>Web应用开发人员要在<code>编码</code>和<code>测试</code>两个方面进行防御</p><p>代码层漏洞防护：</p><ol><li><p>基本措施</p><p>对所有可能来自用户输入的数据进行严格检查，对数据库配置使用最小权限原则</p><p>具体措施：</p><ol><li>采用强类型语言，如JAVA、C#等，它们几乎可以完全忽略<code>数字型注入</code></li><li>尽可能避免使用拼接的动态SQL语句，所有的查询语句都使用数据库提供的参数化查询接口。<br>参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中</li><li>在服务器端<code>验证</code>用户输入的值和类型是否符合程序的预期要求，验证balabal书上一堆</li><li>在服务器端对用户输入进行<code>过滤</code></li><li>避免网站显示SQL错误信息，防止攻击者利用这些信息进行一些判断</li><li>加固应用程序服务器和数据库，利用最低权限账户与数据库连接</li></ol><p>在Web开发中遵循安全规范</p></li></ol><p>测试方面</p><p>​在Web应用程序开发过程的所有阶段实施代码的安全检查，在开发和部署Web应用的前后，利用专业的漏洞扫描工具如SQLMap、Pangolin对网站进行安全性测试，对检测出的SQL注入漏洞进行修补</p><hr><p>Web安全十大漏洞：注入（Injection）、跨站脚本（Cross Site Scripting，XSS）、跨站请求伪造（Cross Site Request Forgery，CSRF）</p><p>失效的身份认证与会话管理（Broken Authentication Session Management）</p><p>不安全的直接对象引用（Insecure Direct Object Reference）</p><p>错误的安全配置（Security Misconfiguration）</p><p>未验证的重定向和转发（Unvalidated Redirects and Forwards）</p><hr><h2 id="第五章">第五章</h2><h3 id="了解五六种软件开发模型P114">了解五六种软件开发模型P114</h3><ol><li><p>瀑布模型</p></li><li><p>快速原型模型</p></li><li><p>增量模型</p></li><li><p>螺旋模型</p></li><li><p>喷泉模型</p></li><li><p>Rational统一过程</p></li><li><p>极限编程和敏捷开发</p></li><li><p>微软过程</p></li><li><p>智能模型</p></li><li><p>过程开发模型/混合模型</p><p>PPT</p></li></ol><p>安全开发模型P117</p><ol><li>SDL</li><li>敏捷SDL</li><li>McGraw内建安全BSI模型</li><li>McGraw BSI成熟度模型BSIMM</li><li>NIST软件安全开发模型</li><li>OWASP软件安全开发模型</li></ol><h3 id="软件安全开发模型里的内建开发模型P123">软件安全开发模型里的内建开发模型P123</h3><img src= "/img/loading.gif" data-lazy-src="/Typora_images/软件安全期末复习/image-20210702204816510.png" alt="image-20210702204816510" style="zoom:67%;" /><p>补充</p><h2 id="第六章">第六章</h2><h3 id="等保工作流程P146">等保工作流程P146</h3><p>一是<code>定级</code>。网络运营者根据《信息安全技术 网络安全等级保护定级指南》(GA/T1389—2017）拟定网络的安全保护等级，组织召开专家评审会，对初步定级结果的合理性进行评审,出具专家评审意见，将初步定级结果上报行业主管部门进行审核。</p><p>二是<code>备案</code>。网络运营者将网络定级材料向公安机关备案，公安机关对定级准确、符合要求的网络发放备案证明。</p><p>三是<code>等级测评</code>。网络运营者选择符合国家规定条件的测评机构,对第三级以上网络（含国家关键信息基础设施)每年开展等级测评,查找发现问题隐患,提出整改意见。</p><p>四是<code>安全建设整改</code>。网络运营者根据网络的安全保护等级，按照国家标准开展安全建设整改。</p><p>五是<code>监督检查</code>。公安机关每年对网络运营者开展<strong>网络安全等级保护工作的情况</strong>和<strong>网络的安全状况</strong>实施<strong>执法检查</strong>。</p><h2 id="第七章">第七章</h2><h3 id="软件设计与软件安全设计区别与联系P161">软件设计与软件安全设计区别与联系P161</h3><p>简单地说，软件安全设计就是将软件的<code>安全需求</code>转化为软件的<code>功能结构</code>的过程。</p><p>软件设计过程通常包括架构设计、接口设计、构件设计、数据模型设计等工作</p><p>安全设计也要不仅考虑系统架构及相关的安全问题，同时还要考虑如何将安全需求嵌入到软件的功能结构中，与功能结构相融合并且成为一个有机的整体，为高质量地实现软件的业务目标提供安全保障。</p><p>软件安全设计的主要工作包括软件架构安全性设计，软件架构安全性分析以及软件安全功能设计。</p><h3 id="威胁建模，为什么要使用威胁建模？流程">威胁建模，为什么要使用威胁建模？流程</h3><p>定义：通过抽象的概念模型对影响软件系统的威胁进行系统的识别和评价</p><ol><li><p>可以系统性地分析系统架构、软件体系和程序部署</p></li><li><p>分析网络和信息系统可能面临的潜在威胁，确认有哪些攻击面，之后提出有针对性的安全防范措施</p></li><li><p>相对于其它方式比如渗透测试，是有效解决网络安全对抗的良策。</p></li><li><p>有着重要的价值：包括早期发现安全缺陷，理解安全需求，设计和交付更安全的产品，解决其他技术无法解决的问题等作用</p></li></ol><p>流程：8个步骤P180</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/软件安全期末复习/image-20210702210754700.png" alt="image-20210702210754700" style="zoom:67%;" /><h2 id="第八章">第八章</h2><h3 id="软件安全编码中的代码检测有哪些类型">软件安全编码中的代码检测有哪些类型</h3><ul><li>代码静态检测<ul><li>代码静态检测是指，不在计算机上实际执行所检测的程序，而是采用人工审查或类似动态分析的方法,通常借助相关的静态分析工具完成程序源代码的分析与检测。</li></ul></li><li>代码动态检测。<ul><li>代码动态检测是指，实际运行代码时进行检测的方法。通常依靠系统编译程序和动态检查工具实现检测，但完成后可能仍会存在与安全相关的、在编译阶段发现不了的、运行阶段又很难定位的错误。</li></ul></li></ul><p>工业界目前普遍采用的代码动态分析是进行模糊（ Fuzzy)测试和渗透测试。</p><h3 id="开发语言安全性里JAVA、C-语言的安全机制">开发语言安全性里JAVA、C#语言的安全机制</h3><p>JAVA:</p><p>P199</p><p>沙箱</p><p>C#:</p><p>C#语言拥有内建到语言中的许多安全机制，包括</p><p>类型安全元素、</p><p>代码访问安全和</p><p>基于角色的安全，</p><p>这些安全机制都包括在.NET框架中，因而属于类型安全语言范畴</p><h2 id="第九章">第九章</h2><h3 id="什么是软件安全测试P214">什么是软件安全测试P214</h3><p>软件安全测试是从攻击者的角度出发发现漏洞并修复，保证软件不被恶意攻击者破坏。</p><p>方法：</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/软件安全期末复习/image-20210702212304194.png" alt="image-20210702212304194" style="zoom:67%;" /><p>基本框架：</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/软件安全期末复习/image-20210702212349252.png" alt="image-20210702212349252" style="zoom:67%;" /><h3 id="模糊测试的方法P229">模糊测试的方法P229</h3><img src= "/img/loading.gif" data-lazy-src="/Typora_images/软件安全期末复习/image-20210702212531888.png" alt="image-20210702212531888" style="zoom:67%;" /><h3 id="模糊测试过程P228">模糊测试过程P228</h3><img src= "/img/loading.gif" data-lazy-src="/Typora_images/软件安全期末复习/image-20210702212548688.png" alt="image-20210702212548688" style="zoom:67%;" /><h3 id="渗透测试的方法P232">渗透测试的方法P232</h3><img src= "/img/loading.gif" data-lazy-src="/Typora_images/软件安全期末复习/image-20210702212704474.png" alt="image-20210702212704474" style="zoom:67%;" /><h3 id="漏洞扫描、渗透测试P235">漏洞扫描、渗透测试P235</h3><h2 id="第十章">第十章</h2><h3 id="软件部署时，数据安全保护要注意什么？">软件部署时，数据安全保护要注意什么？</h3><ol><li>软件自身的安全配置与运行安全</li><li>软件运行环境的安全配置与运行安全</li></ol><h3 id="有哪些模式、形式">有哪些模式、形式</h3><p>模式P242</p><ol><li>单机软件</li><li>基于中间件平台</li><li>基于代理</li></ol><p>形式？</p><h2 id="第十一章">第十一章</h2><h3 id="虚拟内存、地址计算">虚拟内存、地址计算</h3><h3 id="PE文件">PE文件</h3><h3 id="软件逆向分析的一般流程">软件逆向分析的一般流程</h3><img src= "/img/loading.gif" data-lazy-src="/Typora_images/软件安全期末复习/image-20210702213552355.png" alt="image-20210702213552355" style="zoom:67%;" /><h2 id="第十二章">第十二章</h2><h3 id="什么是蠕虫病毒、木马病毒？以及关系">什么是蠕虫病毒、木马病毒？以及关系</h3><h2 id="第十三章">第十三章</h2><h3 id="开源软件涉及的主要权益">开源软件涉及的主要权益</h3><h2 id="第十四章">第十四章</h2><h3 id="软件保护技术中的软件水印技术">软件保护技术中的软件水印技术</h3><h3 id="软件保护的目标">软件保护的目标</h3>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-无领导小组讨论</title>
      <link href="/posts/5c714fe8.html"/>
      <url>/posts/5c714fe8.html</url>
      
        <content type="html"><![CDATA[<h1>无领导小组讨论</h1><h2 id="定义">定义</h2><ul><li>由一组应试者（一般6~10人左右）组成一个临时工作小组，在规定的时间里（20/30mins不等）对于给定的问题进行讨论，并做出决策。</li><li>由于小组是临时拼凑，且不指定具体角色，每人地位平等，受测者自行安排组织，故称“无领导小组”。</li></ul><h2 id="意义">意义</h2><ul><li>面试官通过观察小组的讨论过程，来观测考生的组织协调能力、口头表达能力、辩论的说服能力等各方面的能力和素质是否达到拟任岗位的要求，以及自信程度、进取心、<a href="https://baike.baidu.com/item/%E6%83%85%E7%BB%AA%E7%A8%B3%E5%AE%9A%E6%80%A7/22117103">情绪稳定性</a>、反应灵活性等个性特点是否符合拟任岗位的团体气氛，由此来综合评价考生之间的差别，是集体面试中筛选面试者的一种高效率方式。</li></ul><h2 id="主要考察的能力">主要考察的能力</h2><h3 id="表达能力">表达能力</h3><ul><li><strong>敢说-能说-会说</strong>。敢说就是首先你要抛开自己内向的一面，要敢于在面试中表达自己表现自己，不然凶多吉少。能说指的是你要能表达出自己的想法，并运用修饰的连贯清晰，让别人能听懂你的想法。会说(最难也是最重要的)指的是你要能结合面试公司的背景文化，有逻辑有框架的表达出你对这个讨论的观点。</li></ul><h3 id="合作能力">合作能力</h3><ul><li>指的是无领导小组讨论中团结队友并完成课题的能力。无领导小组讨论成员之间是合作关系，不是敌对关系。这是合作讨论，不是辩论赛。切记不要去和他人吵架甚至是贬低他人，这类做法无异于自动退出面试</li></ul><h3 id="团队意识">团队意识</h3><ul><li>指的是作为一个团队要做到有很强的目标性，同时要结果导向。也就是看:你们能不能为了一个目标(讨论课题)，作为一个团队去讨论合作，并在有限的时间拿出一个你们讨论出最好的方案。这里要再次强调讨论成员之间是合作关系。讨论时要做到有很强的目标性—围绕解决课题;同时还要有结果导向—要以尽快讨论出尽可能好的方案，不要天马星空的乱说，把时间浪费掉。</li></ul><h2 id="应对无领导小组讨论">应对无领导小组讨论</h2><h3 id="给定问题分类">给定问题分类</h3><ul><li>开放式。例如，您认为什么样的领导才是个好领导?</li><li>两难式：例如：您认为能力和合作精神哪个更重要?</li><li>排序选择：例如：飞机坠毁即将焚烧，15种求生工具只能选择5种</li><li>资源争夺：例如：公司只有500万奖金，不同部门应如何分配？</li><li>实际操作：针对存在的问题设计一个实际操作方案。例如：京东产培生群面中曾有过这样一个问题：假如你是一个打车软件运营部门的高管，面对政府监管你该怎么解决？</li></ul><h3 id="角色类">角色类</h3><ul><li>Leader领导者<ul><li>短时间里建立他人对你的认可和同意你的领导</li><li>把握讨论节奏</li><li>提出逻辑可行的讨论框架</li><li>出现争论时控场</li></ul></li><li>Time-Keeper时间记录者<ul><li>记录并提醒时间</li><li>把握讨论进度和节奏</li></ul></li><li>记录者<ul><li>记录内容，分类清晰有条理，字迹工整</li><li>记录同时仍没忽略贡献自己的观点</li><li>总结整理方案时及时准确给出相关信息</li></ul></li><li>破冰者<ul><li>第一个发言，打破讨论僵局的人</li></ul></li><li>参与者/讨论者<ul><li>表达自己观点、贡献想法的讨论参与者</li></ul></li></ul><h2 id="注意问题">注意问题</h2><h3 id="基本类">基本类</h3><ul><li><p>着装礼仪</p></li><li><p>听题审题读题</p></li><li><p>发言礼仪（倾听不打断）、用词等之类</p></li><li><p>技巧类（个人见解）</p></li></ul><h3 id="问题、发言">问题、发言</h3><ul><li><p>如果对面试题先前有相应知识储备，占了优势，争取精彩发言，不要怂；如果面试题对自己来说比较陌生，可以听他人的见解，思考独到见解，或者做详实的补充说明；如果自己的想法基本都被他人发言了，可以做总结补充发言，切勿全程讨论不说话不发言</p></li><li><p>表达观点时要有理有据，清晰有逻辑</p></li><li><p>精华亮点发言&gt;多次废话无效发言</p></li><li><p>讨论过程</p><ul><li>多人讨论难免遇到相左甚至相反的观点，出现这种情况，不要战队，不要争论，轻则浪费时间，重则拉跨整个小组都被pass掉</li><li>不要花太多自己的时间去总结别人的观点，这是没有意义的</li><li>也不要花时间去反对别人的观点，这样会引起争论，进而可能会导致整体结果都不好</li><li>在完善前面的讨论框架时，尽量活跃自己的思维去补充新的观点/讨论分支</li></ul></li><li><p>角色选择类</p><ul><li>Leader收益与风险并存，没有一定的能力还是不要争当Leader，成败都在一瞬，容错率低</li><li>Timekeeper虽然稳，是一个通过时间掌控全场的隐形领导者，但如果遇到优秀的Leader，控时者将很难发挥</li><li>根据自己的能力选择合适的角色，不要勉强</li></ul></li></ul><h2 id="总结">总结</h2><p>​无领导小组没有最优解，只能多参加多体会多总结，形成合适自己的一套看法和行为方式</p><ul><li>对于菜鸟来说，可以花一两次群面的机会，去留意并记录优秀的面试者的表现。在你回去后，可以根据自己的情况，模仿学习并拿来下次面试使用。</li><li>对于老鸟来说，要复盘自己的亮点和暗点，并学习优秀的面试者的亮点，下回争取自己也做到。总结改善暗点，学习别人的亮点，相信自己就是下一个面霸。</li></ul><p>参考网址：</p><p><a href="https://www.zhihu.com/question/278661487">如何在无领导小组讨论中表现出彩呢？</a></p><p><a href="https://www.zhihu.com/question/282540276">无领导小组讨论的题目有哪些？</a></p><p><a href="https://www.mbachina.com/html/mpaccfs/201701/181773.html">MBA复试：无领导小组讨论如何确定你的角色！- MBAChina网</a></p><p><a href="https://baike.baidu.com/item/%E6%97%A0%E9%A2%86%E5%AF%BC%E5%B0%8F%E7%BB%84%E8%AE%A8%E8%AE%BA/9531956?fr=aladdin">无领导小组讨论_百度百科</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无领导小组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DES、AES、SM4、ZUC、RSA、ElGamal</title>
      <link href="/posts/43cb853c.html"/>
      <url>/posts/43cb853c.html</url>
      
        <content type="html"><![CDATA[<h2 id="DES">DES</h2><p>DES的结构是典型的Feistel密码结构。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mi>E</mi><mi>S</mi><mtext>笔记脉络</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>初始置换</mtext><mi>I</mi><mi>P</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>轮结构</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>扩展置换</mtext><mi>E</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>轮密钥</mtext><msub><mi>K</mi><mi>i</mi></msub><mtext>生成过程</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>置换选择</mtext><mi>P</mi><mi>C</mi><mi mathvariant="normal">_</mi><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>循环左移</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>置换选择</mtext><mi>P</mi><mi>C</mi><mi mathvariant="normal">_</mi><mn>2</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>S</mi><mtext>盒代换</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>P</mi><mtext>盒置换</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>逆初始置换</mtext><mi>I</mi><msup><mi>P</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">DES笔记脉络\begin{cases}初始置换IP\\轮结构\begin{cases}扩展置换E\\轮密钥K_i生成过程\begin{cases}置换选择PC\_1\\循环左移\\置换选择PC\_2\end{cases}\\S盒代换\\P盒置换\end{cases}\\逆初始置换IP^{-1}\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:11.52em;vertical-align:-5.51em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">ES</span><span class="mord cjk_fallback">笔记脉络</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.95em;"><span style="top:-1.366em;"><span class="pstrut" style="height:5.916em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.358em;"><span class="pstrut" style="height:5.916em;"></span><span style="height:3.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='3.916em' style='width:0.8889em' viewBox='0 0 888.89 3916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V3916 H384z M384 0 H504 V3916 H384z'/></svg></span></span><span style="top:-5.916em;"><span class="pstrut" style="height:5.916em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-7.058em;"><span class="pstrut" style="height:5.916em;"></span><span style="height:3.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='3.916em' style='width:0.8889em' viewBox='0 0 888.89 3916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V3916 H384z M384 0 H504 V3916 H384z'/></svg></span></span><span style="top:-10.966em;"><span class="pstrut" style="height:5.916em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:5.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:6.01em;"><span style="top:-11.572em;"><span class="pstrut" style="height:6.57em;"></span><span class="mord"><span class="mord cjk_fallback">初始置换</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span><span style="top:-6.57em;"><span class="pstrut" style="height:6.57em;"></span><span class="mord"><span class="mord cjk_fallback">轮结构</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.45em;"><span style="top:-1.366em;"><span class="pstrut" style="height:4.416em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.358em;"><span class="pstrut" style="height:4.416em;"></span><span style="height:2.416em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='2.416em' style='width:0.8889em' viewBox='0 0 888.89 2416' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V2416 H384z M384 0 H504 V2416 H384z'/></svg></span></span><span style="top:-4.416em;"><span class="pstrut" style="height:4.416em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-5.558em;"><span class="pstrut" style="height:4.416em;"></span><span style="height:2.416em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='2.416em' style='width:0.8889em' viewBox='0 0 888.89 2416' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V2416 H384z M384 0 H504 V2416 H384z'/></svg></span></span><span style="top:-7.966em;"><span class="pstrut" style="height:4.416em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.95em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.57em;"><span style="top:-7.972em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mord cjk_fallback">扩展置换</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span><span style="top:-5.13em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mord cjk_fallback">轮密钥</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">生成过程</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">置换选择</span><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span><span class="mord">_1</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">循环左移</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">置换选择</span><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span><span class="mord">_2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.212em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">盒代换</span></span></span><span style="top:-0.772em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord cjk_fallback">盒置换</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.07em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-1.492em;"><span class="pstrut" style="height:6.57em;"></span><span class="mord"><span class="mord cjk_fallback">逆初始置换</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:5.51em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES、AES、SM4、ZUC、RSA、ElGamal/20180322144408819.png" alt="20180322144408819" style="zoom:150%;" /><ul><li><p>明文分组长为64bit。</p></li><li><p>初始密钥为64bit，其中，第8、16、24、32、40、48、56、64为奇偶检验位，实际密钥长为56bit。</p></li></ul><p>DES加密过程由三个阶段来完成：</p><ol><li><p>首先是一个初始置换IP,用于重排明文分组的64bit数据</p></li><li><p>然后是具有相同功能的16轮迭代，每轮中都有置换和代换运算，第16轮变换的输出分为左右两半，并交换次序</p></li><li><p>最后再经过一一个逆初始置换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>P</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">IP^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>(IP的逆)从而产生64bit的密文</p></li><li><p>初始置换IP</p></li></ol><p>对64bit的明文M中的各位进行换位，打乱明文中各位的排列次序。(其实IP和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>P</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">IP^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>在密码方面作用不大，意义在于打乱原来输入明文的ASCII码字划分的关系。</p><p>经过IP置换，明文中原有的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>58</mn></msub></mrow><annotation encoding="application/x-tex">m_{58}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">58</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>放在第1位，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>50</mn></msub></mrow><annotation encoding="application/x-tex">m_{50}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">50</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>放在第2位，依此类推，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>7</mn></msub></mrow><annotation encoding="application/x-tex">m_7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>放在第64位。输入64bit的明文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>3</mn></msub><mo>⋯</mo><msub><mi>m</mi><mn>64</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(m_1,m_2,m_3\cdots m_{64})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">64</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，经过IP置为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><msub><mi>m</mi><mn>58</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>50</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>42</mn></msub><mo>⋯</mo><msub><mi>m</mi><mn>7</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(m_{58},m_{50},m_{42}\cdots m_7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">58</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">50</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">42</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>这里X=IP(M)</p><table><thead><tr><th>初始置换IP表8*8=64bit</th><th>第1列</th><th>第2列</th><th>第3列</th><th>第4列</th><th>第5列</th><th>第6列</th><th>第7列</th><th>第8列</th></tr></thead><tbody><tr><td>第1行</td><td>58</td><td>50</td><td>42</td><td>34</td><td>26</td><td>18</td><td>10</td><td>2</td></tr><tr><td>第2行</td><td>60</td><td>52</td><td>44</td><td>36</td><td>28</td><td>20</td><td>12</td><td>4</td></tr><tr><td>第3行</td><td>62</td><td>54</td><td>46</td><td>38</td><td>30</td><td>22</td><td>14</td><td>6</td></tr><tr><td>第4行</td><td>64</td><td>56</td><td>48</td><td>40</td><td>32</td><td>24</td><td>16</td><td>8</td></tr><tr><td>第5行</td><td>57</td><td>49</td><td>41</td><td>33</td><td>25</td><td>17</td><td>9</td><td>1</td></tr><tr><td>第6行</td><td>59</td><td>51</td><td>43</td><td>35</td><td>27</td><td>19</td><td>11</td><td>3</td></tr><tr><td>第7行</td><td>61</td><td>53</td><td>45</td><td>37</td><td>29</td><td>21</td><td>13</td><td>5</td></tr><tr><td>第8行</td><td>63</td><td>55</td><td>47</td><td>39</td><td>31</td><td>23</td><td>15</td><td>7</td></tr></tbody></table><ol start="2"><li>轮结构</li></ol><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES%E3%80%81AES%E3%80%81SM4%E3%80%81ZUC%E3%80%81RSA%E3%80%81ElGamal/image-20200420190514485.png" alt="image-20200420190514485"></p><p>​64bit的明文M经初始IP置换后，分成左<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">L_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和右<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">R_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>两个32bit的部分，然后经过16轮迭代后再输出。</p><p>​每轮迭代的结构和Feistel加密结构一样，如上图4-5所示。其数学公式如下</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>L</mi><mi>i</mi></msub><mo>=</mo><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><msub><mi>L</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⊕</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}L_i=R_{i-1}\\R_i=L_{i-1}⊕F(R_{i-1},K_i)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>式中：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(R_{i-1},K_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 轮的轮函数(图中虚线框)</p><p>⊕：两个比特串的异或</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>，</mtext><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">L_{i-1}，R_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 轮的左、右两部分</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub><mtext>，</mtext><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_{i}，R_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>轮的左、右两部分（各32bit）</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 轮用的子密钥（48bit）</p><p>轮结构中的核心是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(R_{i-1},K_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>函数，它是每轮实现混乱和扩散的关键模块。其基本加密结构如下图4-6所示。</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES%E3%80%81AES%E3%80%81SM4%E3%80%81ZUC%E3%80%81RSA%E3%80%81ElGamal/image-20200420190214536.png" alt="image-20200420190214536"></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(R_{i-1},K_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>函数的执行过程包括：</p><p>​<strong>扩展置换E表</strong>：将输入的32bit<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">R_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>置换成48bit；</p><p>​这48bit与子密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(48bit)进行异或运算；</p><p>​<strong>代换选择S盒</strong>：结果输入S盒，输出32bit的输出   （输入为48bit，输出为32bit）；</p><p>​<strong>置换P表</strong>：最后经过P置换后即为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(R_{i-1},K_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>函数的输出。</p><p>（1）扩展置换E表</p><p>​扩展置换E将32bit的输入分成8组，每组4bit，经置换E的扩展后，变成每组6bit输出</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES、AES、SM4、ZUC、RSA、ElGamal/{33C1CA8A-10EE-5EE5-1779-76A3728B0968}-1591097816450.jpg" alt="{33C1CA8A-10EE-5EE5-1779-76A3728B0968}" style="zoom:50%;" /><p>扩展后的结果与子密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>进行异或运算，结果作为S盒的输入</p><p>（2）轮密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>生成过程</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES%E3%80%81AES%E3%80%81SM4%E3%80%81ZUC%E3%80%81RSA%E3%80%81ElGamal/image-20200420171722765.png" alt="image-20200420171722765"></p><p>子密钥K;的生成大致分成三个过程:</p><p>​1）置换选择PC_1</p><p>​2）循环左移</p><p>​3）置换选择PC_2</p><p>​1）置换选择PC_1</p><p>​初始密钥K为64bit，经过置换选择PC_1去掉密钥中的8个奇偶检验位，并对其余的56位打乱重新排序</p><p>​将置换后的56bit分为各28bit的左<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">C_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、右<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">D_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>两半。</p><p>​<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>C</mi><mn>0</mn></msub><msub><mi>D</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">PC_1(K)=C_0D_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">C_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PC_1(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span>前28位组成，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">D_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>由后28位组成</p><table><thead><tr><th>选择置换PC_1</th><th>第1列</th><th>第2列</th><th>第3列</th><th>第4列</th><th>第5列</th><th>第6列</th><th>第7列</th></tr></thead><tbody><tr><td>第1行</td><td>57</td><td>49</td><td>41</td><td>33</td><td>25</td><td>17</td><td>9</td></tr><tr><td>第2行</td><td>1</td><td>58</td><td>50</td><td>42</td><td>34</td><td>26</td><td>18</td></tr><tr><td>第3行</td><td>10</td><td>2</td><td>59</td><td>51</td><td>43</td><td>35</td><td>27</td></tr><tr><td>第4行</td><td>19</td><td>11</td><td>3</td><td>60</td><td>52</td><td>44</td><td>36</td></tr><tr><td>第5行</td><td>63</td><td>55</td><td>47</td><td>39</td><td>31</td><td>23</td><td>15</td></tr><tr><td>第6行</td><td>7</td><td>62</td><td>54</td><td>46</td><td>38</td><td>30</td><td>22</td></tr><tr><td>第7行</td><td>14</td><td>6</td><td>61</td><td>53</td><td>45</td><td>37</td><td>29</td></tr><tr><td>第8行</td><td>21</td><td>13</td><td>5</td><td>28</td><td>20</td><td>12</td><td>4</td></tr></tbody></table><ul><li><p>密钥k中有8位奇偶检验位，分别位于8，16，24，32，40，48，56，64位，奇偶检验位用于检查密钥k在产生、分配及存储过程中可能发生的错误</p><p>2）循环左移</p></li></ul><p>​<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">1≤i≤16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><mi>L</mi><msub><mi>S</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C_i=LS_i(C_{i-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mi>L</mi><msub><mi>S</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>D</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D_i=LS_i(D_{i-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 轮分别对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">C_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">D_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>进行循环左移，所移位数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 位。</p><p>​（当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">i=1,2, 9, 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">16</span></span></span></span>时，则左移1个位置，其余左移2个位置。如下表所示）</p><table><thead><tr><th>迭代次数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr></thead><tbody><tr><td>左移位数</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td></tr></tbody></table><p>​移位后的结果作为求下一轮子密钥的输入，同时也作为置换选择PC_2的输入。</p><p>​3）置换选择PC_2</p><p>​<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo>=</mo><mi>P</mi><mi>C</mi><mi mathvariant="normal">_</mi><mn>2</mn><mo stretchy="false">(</mo><msub><mi>C</mi><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_i=PC\_2(C_iD_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span><span class="mord">_2</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">PC_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为固定置换，用于从56bit的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_iD_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中选取48位作为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 轮迭代的子密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>​子密钥中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中的各位从左到右依次为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_iD_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>14</mn><mtext>，</mtext><mn>17</mn><mtext>，</mtext><mo>⋯</mo><mtext>，</mtext><mn>29</mn><mtext>，</mtext><mn>32</mn></mrow><annotation encoding="application/x-tex">14，17，\cdots，29，32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">14</span><span class="mord cjk_fallback">，</span><span class="mord">17</span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">，</span><span class="mord">29</span><span class="mord cjk_fallback">，</span><span class="mord">32</span></span></span></span>位</p><table><thead><tr><th>选择置换PC_2</th><th>第1列</th><th>第2列</th><th>第3列</th><th>第4列</th><th>第5列</th><th>第6列</th></tr></thead><tbody><tr><td>第1行</td><td>14</td><td>17</td><td>11</td><td>24</td><td>1</td><td>5</td></tr><tr><td>第2行</td><td>3</td><td>28</td><td>15</td><td>6</td><td>21</td><td>10</td></tr><tr><td>第3行</td><td>23</td><td>19</td><td>12</td><td>4</td><td>26</td><td>8</td></tr><tr><td>第4行</td><td>16</td><td>7</td><td>27</td><td>20</td><td>13</td><td>2</td></tr><tr><td>第5行</td><td>41</td><td>52</td><td>31</td><td>37</td><td>47</td><td>55</td></tr><tr><td>第6行</td><td>30</td><td>40</td><td>21</td><td>45</td><td>33</td><td>48</td></tr><tr><td>第7行</td><td>44</td><td>49</td><td>39</td><td>56</td><td>34</td><td>53</td></tr><tr><td>第8行</td><td>46</td><td>42</td><td>50</td><td>36</td><td>29</td><td>32</td></tr></tbody></table><p>（3）S盒代换</p><p>输入为48bit，经S盒后输出为32bit，输出结果为P盒置换的输入。</p><p>轮函数中的代换由8个S盒组成，每个S盒的输入长为6位、输出长为4位，</p><p>对于S盒，其6位输入中，第1位和第6位形成一个2位二进制数，用来选择S的行，中间4位用来选择列。</p><p>行和列选定后，得到其交叉位置的十进制数，将这个数表示为4位二进制数即得这一S盒的输出。</p><table><thead><tr><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>0</td><td>14</td><td>4</td><td>13</td><td>1</td><td>2</td><td>15</td><td>11</td><td>8</td><td>3</td><td>10</td><td>6</td><td>12</td><td>5</td><td>9</td><td>0</td><td>7</td></tr><tr><td>1</td><td>0</td><td>15</td><td>07</td><td>4</td><td>14</td><td>2</td><td>13</td><td>1</td><td>10</td><td>6</td><td>12</td><td>11</td><td>9</td><td>5</td><td>3</td><td>8</td></tr><tr><td>2</td><td>4</td><td>1</td><td>14</td><td>8</td><td>13</td><td>6</td><td>2</td><td>11</td><td>15</td><td>12</td><td>9</td><td>7</td><td>3</td><td>10</td><td>5</td><td>0</td></tr><tr><td>3</td><td>15</td><td>12</td><td>8</td><td>2</td><td>4</td><td>9</td><td>1</td><td>7</td><td>5</td><td>11</td><td>3</td><td>14</td><td>10</td><td>0</td><td>6</td><td>13</td></tr></tbody></table><table><thead><tr><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>0</td><td>15</td><td>1</td><td>8</td><td>14</td><td>6</td><td>11</td><td>3</td><td>4</td><td>9</td><td>7</td><td>2</td><td>13</td><td>12</td><td>0</td><td>5</td><td>10</td></tr><tr><td>1</td><td>3</td><td>13</td><td>4</td><td>7</td><td>15</td><td>2</td><td>8</td><td>14</td><td>12</td><td>0</td><td>1</td><td>10</td><td>6</td><td>9</td><td>11</td><td>5</td></tr><tr><td>2</td><td>0</td><td>14</td><td>7</td><td>11</td><td>10</td><td>4</td><td>13</td><td>1</td><td>5</td><td>8</td><td>12</td><td>6</td><td>9</td><td>3</td><td>2</td><td>15</td></tr><tr><td>3</td><td>13</td><td>8</td><td>10</td><td>1</td><td>3</td><td>15</td><td>4</td><td>2</td><td>11</td><td>6</td><td>7</td><td>12</td><td>0</td><td>5</td><td>14</td><td>9</td></tr></tbody></table><table><thead><tr><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">S_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>0</td><td>10</td><td>0</td><td>9</td><td>14</td><td>6</td><td>3</td><td>15</td><td>5</td><td>1</td><td>13</td><td>12</td><td>7</td><td>11</td><td>4</td><td>2</td><td>8</td></tr><tr><td>1</td><td>13</td><td>7</td><td>0</td><td>9</td><td>3</td><td>4</td><td>6</td><td>10</td><td>2</td><td>8</td><td>5</td><td>14</td><td>12</td><td>11</td><td>15</td><td>1</td></tr><tr><td>2</td><td>13</td><td>6</td><td>4</td><td>9</td><td>8</td><td>15</td><td>3</td><td>0</td><td>11</td><td>1</td><td>2</td><td>12</td><td>5</td><td>10</td><td>14</td><td>7</td></tr><tr><td>3</td><td>1</td><td>10</td><td>13</td><td>0</td><td>6</td><td>9</td><td>8</td><td>7</td><td>4</td><td>15</td><td>14</td><td>3</td><td>11</td><td>5</td><td>2</td><td>12</td></tr></tbody></table><table><thead><tr><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">S_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>0</td><td>7</td><td>13</td><td>14</td><td>3</td><td>0</td><td>6</td><td>9</td><td>10</td><td>1</td><td>2</td><td>8</td><td>5</td><td>11</td><td>12</td><td>4</td><td>15</td></tr><tr><td>1</td><td>13</td><td>8</td><td>11</td><td>5</td><td>6</td><td>15</td><td>0</td><td>3</td><td>4</td><td>7</td><td>2</td><td>12</td><td>1</td><td>10</td><td>14</td><td>9</td></tr><tr><td>2</td><td>10</td><td>6</td><td>9</td><td>0</td><td>12</td><td>11</td><td>7</td><td>13</td><td>15</td><td>1</td><td>3</td><td>14</td><td>5</td><td>2</td><td>8</td><td>4</td></tr><tr><td>3</td><td>3</td><td>15</td><td>0</td><td>6</td><td>10</td><td>1</td><td>13</td><td>8</td><td>9</td><td>4</td><td>5</td><td>11</td><td>12</td><td>7</td><td>2</td><td>14</td></tr></tbody></table><table><thead><tr><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">S_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>0</td><td>2</td><td>12</td><td>4</td><td>1</td><td>7</td><td>10</td><td>11</td><td>6</td><td>8</td><td>5</td><td>3</td><td>15</td><td>13</td><td>0</td><td>14</td><td>9</td></tr><tr><td>1</td><td>14</td><td>11</td><td>2</td><td>12</td><td>4</td><td>7</td><td>13</td><td>1</td><td>5</td><td>0</td><td>15</td><td>10</td><td>3</td><td>9</td><td>8</td><td>6</td></tr><tr><td>2</td><td>4</td><td>2</td><td>1</td><td>11</td><td>10</td><td>13</td><td>7</td><td>8</td><td>15</td><td>9</td><td>12</td><td>5</td><td>6</td><td>3</td><td>0</td><td>14</td></tr><tr><td>3</td><td>11</td><td>8</td><td>12</td><td>7</td><td>1</td><td>14</td><td>2</td><td>13</td><td>6</td><td>15</td><td>0</td><td>9</td><td>10</td><td>4</td><td>5</td><td>3</td></tr></tbody></table><table><thead><tr><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">S_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>0</td><td>12</td><td>1</td><td>10</td><td>15</td><td>9</td><td>2</td><td>6</td><td>8</td><td>0</td><td>13</td><td>3</td><td>4</td><td>14</td><td>7</td><td>5</td><td>11</td></tr><tr><td>1</td><td>10</td><td>15</td><td>4</td><td>2</td><td>7</td><td>12</td><td>9</td><td>5</td><td>6</td><td>1</td><td>13</td><td>14</td><td>0</td><td>11</td><td>3</td><td>8</td></tr><tr><td>2</td><td>9</td><td>14</td><td>15</td><td>5</td><td>2</td><td>8</td><td>12</td><td>3</td><td>7</td><td>0</td><td>4</td><td>10</td><td>1</td><td>13</td><td>11</td><td>6</td></tr><tr><td>3</td><td>4</td><td>3</td><td>2</td><td>12</td><td>9</td><td>5</td><td>15</td><td>10</td><td>11</td><td>14</td><td>1</td><td>7</td><td>6</td><td>0</td><td>8</td><td>13</td></tr></tbody></table><table><thead><tr><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>7</mn></msub></mrow><annotation encoding="application/x-tex">S_7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>11</td><td>2</td><td>14</td><td>15</td><td>0</td><td>8</td><td>13</td><td>3</td><td>12</td><td>9</td><td>7</td><td>5</td><td>10</td><td>6</td><td>1</td></tr><tr><td>1</td><td>13</td><td>0</td><td>11</td><td>7</td><td>4</td><td>9</td><td>1</td><td>10</td><td>14</td><td>3</td><td>5</td><td>12</td><td>2</td><td>15</td><td>8</td><td>6</td></tr><tr><td>2</td><td>1</td><td>4</td><td>11</td><td>13</td><td>12</td><td>3</td><td>7</td><td>14</td><td>10</td><td>15</td><td>6</td><td>8</td><td>0</td><td>5</td><td>9</td><td>2</td></tr><tr><td>3</td><td>6</td><td>11</td><td>13</td><td>8</td><td>1</td><td>4</td><td>10</td><td>7</td><td>9</td><td>5</td><td>0</td><td>15</td><td>14</td><td>2</td><td>3</td><td>12</td></tr></tbody></table><table><thead><tr><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">S_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>0</td><td>13</td><td>2</td><td>8</td><td>4</td><td>6</td><td>15</td><td>11</td><td>1</td><td>10</td><td>9</td><td>3</td><td>14</td><td>5</td><td>0</td><td>12</td><td>7</td></tr><tr><td>1</td><td>1</td><td>15</td><td>13</td><td>8</td><td>10</td><td>3</td><td>7</td><td>4</td><td>12</td><td>5</td><td>6</td><td>11</td><td>0</td><td>14</td><td>9</td><td>2</td></tr><tr><td>2</td><td>7</td><td>11</td><td>4</td><td>1</td><td>9</td><td>12</td><td>14</td><td>2</td><td>0</td><td>6</td><td>10</td><td>13</td><td>15</td><td>3</td><td>5</td><td>8</td></tr><tr><td>3</td><td>2</td><td>1</td><td>14</td><td>7</td><td>4</td><td>10</td><td>8</td><td>13</td><td>15</td><td>12</td><td>9</td><td>0</td><td>3</td><td>5</td><td>6</td><td>11</td></tr></tbody></table><p>​DES算法中除了S盒是非线性变换外，其余变换均为线性变换，DES算法保密的关键在于S盒。S盒是经过精心设计和严格挑选的，美国国家安全局(NSA)曾公布了下列几条设<br>计准则:<br>●S盒的每一行是整数0~15的一个置换；<br>●没有一个S盒是它输入变量的线性函数;<br>●改变S盒输入中的某1bit, 至少引起2bit的输出变化;<br>●对任一S盒的任何两 个输入x和x⊕001100， 则对应的输出至少有2bit不同;<br>●对任一S盒的任何两 个输入x和x⊕11ab00 (其中a, b属于{0,1}), 则对应的输出至少<br>有2bit不同;<br>●任一S盒的6bit输入，若某lbit输入保持不变，当其它5bit输入变化时，则输出中的0与1数目分布的总数接近相等。</p><p>（4）P盒置换</p><p>​P盒置换将S盒的32bit输出重新排列，排列后的32bit即为函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(R_{i-1},K_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的输出。</p><table><thead><tr><th>P盒置换表</th><th>第1列</th><th>第2列</th><th>第3列</th><th>第4列</th><th>第5列</th><th>第6列</th><th>第7列</th><th>第8列</th></tr></thead><tbody><tr><td>第1行</td><td>16</td><td>7</td><td>20</td><td>21</td><td>29</td><td>12</td><td>28</td><td>17</td></tr><tr><td>第2行</td><td>1</td><td>15</td><td>23</td><td>26</td><td>5</td><td>18</td><td>31</td><td>10</td></tr><tr><td>第3行</td><td>2</td><td>8</td><td>24</td><td>14</td><td>32</td><td>27</td><td>3</td><td>9</td></tr><tr><td>第4行</td><td>19</td><td>13</td><td>30</td><td>6</td><td>22</td><td>11</td><td>4</td><td>25</td></tr></tbody></table><ol start="3"><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>逆初始置换</mtext><mi>I</mi><msup><mi>P</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">逆初始置换IP^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord cjk_fallback">逆初始置换</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p><p>DES算法经过16轮迭代后，最后一步是逆初始置换，该置换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>P</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">IP^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>如下表所示，将第16轮迭代的输出经过逆初始置换Ip-处理得到密文C，即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mi>I</mi><msup><mi>P</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><msub><mi>R</mi><mn>16</mn></msub><msub><mi>L</mi><mn>16</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C=IP^{-1}(R_{16}L_{16})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><table><thead><tr><th>逆初始置换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>P</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">IP^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></th><th>第1列</th><th>第2列</th><th></th><th>第3列</th><th>第4列</th><th>第5列</th><th>第6列</th><th>第7列</th></tr></thead><tbody><tr><td>第1行</td><td>40</td><td>8</td><td>48</td><td>16</td><td>56</td><td>24</td><td>64</td><td>32</td></tr><tr><td>第2行</td><td>39</td><td>7</td><td>47</td><td>15</td><td>55</td><td>23</td><td>63</td><td>31</td></tr><tr><td>第3行</td><td>38</td><td>6</td><td>46</td><td>14</td><td>54</td><td>22</td><td>62</td><td>30</td></tr><tr><td>第4行</td><td>37</td><td>5</td><td>45</td><td>13</td><td>53</td><td>21</td><td>61</td><td>29</td></tr><tr><td>第5行</td><td>36</td><td>4</td><td>44</td><td>12</td><td>52</td><td>20</td><td>60</td><td>28</td></tr><tr><td>第6行</td><td>35</td><td>3</td><td>43</td><td>11</td><td>51</td><td>19</td><td>59</td><td>27</td></tr><tr><td>第7行</td><td>34</td><td>2</td><td>42</td><td>10</td><td>50</td><td>18</td><td>58</td><td>26</td></tr><tr><td>第8行</td><td>33</td><td>1</td><td>41</td><td>9</td><td>49</td><td>17</td><td>57</td><td>25</td></tr></tbody></table></li></ol><h2 id="AES">AES</h2><p>参考网址：</p><p><a href="https://zhuanlan.zhihu.com/p/7891339">https://zhuanlan.zhihu.com/p/7891339</a></p><p>AES加密流程图：</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES、AES、SM4、ZUC、RSA、ElGamal/AES加密流程图.jpg" alt="AES加密流程图" style="zoom: 67%;" /><ul><li>明文长度为128bit</li><li>密文长度  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span>｛128,192,256｝bit</li><li>经过AES加密后的密文为128bit</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>E</mi><mi>S</mi><mtext>加密流程</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>初始轮密钥加（</mtext><mi>A</mi><mi>d</mi><mi>d</mi><mi>R</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mi>K</mi><mi>e</mi><mi>y</mi><mtext>）</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>N</mi><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>轮迭代</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>字节代换（</mtext><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>b</mi><mtext>）</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>行移位（</mtext><mi>S</mi><mi>h</mi><mi>i</mi><mi>f</mi><mi>t</mi><mi>R</mi><mi>o</mi><mi>w</mi><mtext>）</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>列混合（</mtext><mi>M</mi><mi>i</mi><mi>x</mi><mi>C</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>m</mi><mi>n</mi><mtext>）</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>轮密钥加（</mtext><mi>A</mi><mi>d</mi><mi>d</mi><mi>R</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mi>K</mi><mi>e</mi><mi>y</mi><mtext>）</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>最后一轮变换</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>字节代换（</mtext><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>b</mi><mtext>）</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>行移位（</mtext><mi>S</mi><mi>h</mi><mi>i</mi><mi>f</mi><mi>t</mi><mi>R</mi><mi>o</mi><mi>w</mi><mtext>）</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>密钥加（</mtext><mi>A</mi><mi>d</mi><mi>d</mi><mi>R</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mi>K</mi><mi>e</mi><mi>y</mi><mtext>）</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable></mrow><mtext>  其中每轮轮密钥加的密钥由密钥拓展算法得到</mtext></mrow><annotation encoding="application/x-tex">AES加密流程\begin{cases}初始轮密钥加（AddRoundKey）\\[3ex]N_{r-1}轮迭代\begin{cases}字节代换（ByteSub）\\行移位（ShiftRow）\\列混合（MixColumn）\\轮密钥加（AddRoundKey）\end{cases}\\[3ex]最后一轮变换\begin{cases}字节代换（ByteSub）\\行移位（ShiftRow）\\密钥加（AddRoundKey）\end{cases}\end{cases}\ \ 其中每轮轮密钥加的密钥由密钥拓展算法得到</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:12.813em;vertical-align:-6.1565em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">ES</span><span class="mord cjk_fallback">加密流程</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:6.55em;"><span style="top:-1.366em;"><span class="pstrut" style="height:6.516em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.358em;"><span class="pstrut" style="height:6.516em;"></span><span style="height:4.516em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='4.516em' style='width:0.8889em' viewBox='0 0 888.89 4516' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V4516 H384z M384 0 H504 V4516 H384z'/></svg></span></span><span style="top:-6.516em;"><span class="pstrut" style="height:6.516em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-7.658em;"><span class="pstrut" style="height:6.516em;"></span><span style="height:4.516em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='4.516em' style='width:0.8889em' viewBox='0 0 888.89 4516' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V4516 H384z M384 0 H504 V4516 H384z'/></svg></span></span><span style="top:-12.166em;"><span class="pstrut" style="height:6.516em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.05em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:6.6565em;"><span style="top:-10.7785em;"><span class="pstrut" style="height:5.13em;"></span><span class="mord"><span class="mord cjk_fallback">初始轮密钥加（</span><span class="mord mathnormal">A</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-5.9235em;"><span class="pstrut" style="height:5.13em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">轮迭代</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-1.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.592em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.916em' style='width:0.8889em' viewBox='0 0 888.89 916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V916 H384z M384 0 H504 V916 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.916em' style='width:0.8889em' viewBox='0 0 888.89 916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V916 H384z M384 0 H504 V916 H384z'/></svg></span></span><span style="top:-5.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.13em;"><span style="top:-5.13em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">字节代换（</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">行移位（</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.00773em;">tR</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">列混合（</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">mn</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-0.81em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">轮密钥加（</span><span class="mord mathnormal">A</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mord cjk_fallback">）</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-0.8835em;"><span class="pstrut" style="height:5.13em;"></span><span class="mord"><span class="mord cjk_fallback">最后一轮变换</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">字节代换（</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">行移位（</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.00773em;">tR</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">密钥加（</span><span class="mord mathnormal">A</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mord cjk_fallback">）</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.1565em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">其中每轮轮密钥加的密钥由密钥拓展算法得到</span></span></span></span></span></p><p>AES加密过程描述如下：</p><ol><li><p>初始轮密钥加。给定一个明文M和种子密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">K_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，将它们以矩阵排列并进行<strong>异或加法</strong>（即初始密钥加）运算；</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">N_{r-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>轮迭代。对前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">N_{r-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>轮中的每一轮，依次进行字节代换（ByteSub）、行移位（ShiftRow）、列混合（MixColumn），轮密钥加（AddRoundKey）操作</p><p>其中，轮迭代中的密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>由种子密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">K_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>通过密钥扩展算法产生</p></li><li><p>最后一轮变换。最后一轮中与前面各轮稍有不同，依次字节代换（ByteSub）、行移位（ShiftRow），轮密钥加（AddRoundKey)。</p></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>E</mi><mi>S</mi><mtext>流程笔记</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>字节代换（</mtext><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>b</mi><mtext>）</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>行移位（</mtext><mi>S</mi><mi>h</mi><mi>i</mi><mi>f</mi><mi>t</mi><mi>R</mi><mi>o</mi><mi>w</mi><mtext>）</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>列混合（</mtext><mi>M</mi><mi>i</mi><mi>x</mi><mi>C</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>m</mi><mi>n</mi><mtext>）</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>轮密钥加（</mtext><mi>A</mi><mi>d</mi><mi>d</mi><mi>R</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mi>K</mi><mi>e</mi><mi>y</mi><mtext>）</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>密钥拓展</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">AES流程笔记\begin{cases}字节代换（ByteSub）\\行移位（ShiftRow）\\列混合（MixColumn）\\轮密钥加（AddRoundKey）\\密钥拓展\\\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.2em;vertical-align:-3.35em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">ES</span><span class="mord cjk_fallback">流程笔记</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.85em;"><span style="top:-1.366em;"><span class="pstrut" style="height:3.816em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.358em;"><span class="pstrut" style="height:3.816em;"></span><span style="height:1.816em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='1.816em' style='width:0.8889em' viewBox='0 0 888.89 1816' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V1816 H384z M384 0 H504 V1816 H384z'/></svg></span></span><span style="top:-3.816em;"><span class="pstrut" style="height:3.816em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.958em;"><span class="pstrut" style="height:3.816em;"></span><span style="height:1.816em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='1.816em' style='width:0.8889em' viewBox='0 0 888.89 1816' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V1816 H384z M384 0 H504 V1816 H384z'/></svg></span></span><span style="top:-6.766em;"><span class="pstrut" style="height:3.816em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.85em;"><span style="top:-5.85em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">字节代换（</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">行移位（</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.00773em;">tR</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">列混合（</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">mn</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">轮密钥加（</span><span class="mord mathnormal">A</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-0.09em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">密钥拓展</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>​在Rijndael的设计中，其算法的明文分组和密钥长度都有三个可选值，分别为128、192和256bit，产生的密文没有数据扩展。但在AES中，明文和密文长度固定为128bit，密钥长度可使用128、192和256bit三者中的任意一种。</p><p>​明文及加密过程的中间结果都称为状态State。状态State被表示成矩阵，矩阵的每个元素是一个字节，并看成是有限域<em>GF</em>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>)中的一个元素，矩阵的行数为4，列数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">N_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为4</p><p>​密钥被表示成4行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">N_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>列的矩阵</p><p>​矩阵列数由明文长度or密钥长度➗32bit算出</p><p>​<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">N_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：加密轮数</p><table><thead><tr><th>AES不同密钥长度下的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>b</mi></msub><mtext>、</mtext><msub><mi>N</mi><mi>k</mi></msub><mtext>、</mtext><msub><mi>N</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">N_b、N_k、N_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th>明文分组矩阵列数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">N_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（明文为128，分组长度是32bit，所以128/32=4）</th><th>密钥矩阵列数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">N_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th>加密和解密论数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">N_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th></tr></thead><tbody><tr><td>密钥长度为128</td><td>4</td><td>4（128/32=4）</td><td>10</td></tr><tr><td>192</td><td>4</td><td>6（192/32=6）</td><td>12</td></tr><tr><td>256</td><td>4</td><td>8（256/32=8）</td><td>14</td></tr></tbody></table><p>下面以密钥长度为128bit为例，讲解AES算法具体加密过程：</p><p>AES的处理单位是字节。</p><p>明文矩阵是4行4列，共4*4=16个元素（字节），输入的明文分成16个字节后，按从上到下、从左至右的顺序，排成输入矩阵，如下所示</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>0</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>4</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>8</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>12</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>6</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>9</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>14</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>2</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>6</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>10</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>14</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>3</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>7</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>11</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>p</mi><mn>15</mn></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}p_0 &amp; p_4 &amp; p_8 &amp; p_{12} \\p_1 &amp; p_6 &amp; p_9 &amp; p_{14} \\p_2 &amp; p_6 &amp; p_{10} &amp; p_{14} \\p_3 &amp; p_7 &amp; p_{11} &amp; p_{15} \\\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.8001em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-1.711em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.858em;"><span class="pstrut" style="height:3.216em;"></span><span style="height:1.216em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='1.216em' style='width:0.6667em' viewBox='0 0 666.67 1216' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V1216 H319z M319 0 H403 V1216 H319z'/></svg></span></span><span style="top:-4.7111em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-1.711em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.858em;"><span class="pstrut" style="height:3.216em;"></span><span style="height:1.216em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='1.216em' style='width:0.6667em' viewBox='0 0 666.67 1216' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V1216 H263z M263 0 H347 V1216 H263z'/></svg></span></span><span style="top:-4.7111em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES、AES、SM4、ZUC、RSA、ElGamal/明文输入矩阵.jpg" alt="明文输入矩阵" style="zoom:67%;" /><ol><li><p>字节代换（ByteSub）</p><p>字节代换层的主要功能就是让输入的数据通过S_box表完成从一个字节到另一个字节的映射（是关于字节的非线性变换），S盒的具体计算方法上课没讲。</p><p>把状态矩阵State中的元素字节高4位作为行值，低4位作为列值，取出S盒中对应行列交叉点的元素作为输出。</p><p>AES的字节代换表（或叫S盒）如下所示：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES%E3%80%81AES%E3%80%81SM4%E3%80%81ZUC%E3%80%81RSA%E3%80%81ElGamal/image-20200427150532187.png" alt="image-20200427150532187"></p><p>加密图示：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES%E3%80%81AES%E3%80%81SM4%E3%80%81ZUC%E3%80%81RSA%E3%80%81ElGamal/S%E7%9B%92%E5%8A%A0%E5%AF%86%E5%9B%BE%E7%A4%BA.jpg" alt="S盒加密图示"></p></li><li><p>行移位（ShiftRow）</p><p>​在行移位变换中，状态矩阵State中的每一行将以字节为单位，循环左移不同的位移量。</p><p>​State的第一行保持不变，第二行循环左移一个字节，第三行循环左移两个字节，第四行循环左移三个字节。</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES%E3%80%81AES%E3%80%81SM4%E3%80%81ZUC%E3%80%81RSA%E3%80%81ElGamal/image-20200427162153390.png" alt="image-20200427162153390"></p><p>​行位移操作最为简单，它是用来将输入数据作为一个4·4的字节矩阵进行处理的，然后将这个矩阵的字节进行位置上的置换。ShiftRows子层属于AES手动的扩散层，目的是将单个位上的变换扩散到影响整个状态，从而达到雪崩效应。</p></li><li><p>列混合（MixColumn）</p><p>列混合变换将State乘以一个固定的矩阵A，对State逐列进行变换，每一列中的每个字节被变换成一个新值，直到4列都变换完毕。<br>相乘后得到的乘积矩阵，其中每个元素均是一行和一列中所对应元素的乘积之和。这里的乘法和加法都是定义在有限域GF(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>)上的。</p><p>固定矩阵A：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>02</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>03</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>01</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>01</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>01</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>02</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>03</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>01</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>01</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>01</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>02</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>03</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>03</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>01</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>01</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>02</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}02 &amp; 03 &amp; 01 &amp; 01 \\01 &amp; 02 &amp; 03 &amp; 01 \\01 &amp; 01 &amp; 02 &amp; 03 \\03 &amp; 01 &amp; 01 &amp; 02 \\\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.8001em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-1.711em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.858em;"><span class="pstrut" style="height:3.216em;"></span><span style="height:1.216em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='1.216em' style='width:0.6667em' viewBox='0 0 666.67 1216' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V1216 H319z M319 0 H403 V1216 H319z'/></svg></span></span><span style="top:-4.7111em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">02</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">01</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">01</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">03</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">03</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">02</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">01</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">01</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">01</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">03</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">02</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">01</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">01</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">01</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">03</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">02</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-1.711em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.858em;"><span class="pstrut" style="height:3.216em;"></span><span style="height:1.216em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='1.216em' style='width:0.6667em' viewBox='0 0 666.67 1216' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V1216 H263z M263 0 H347 V1216 H263z'/></svg></span></span><span style="top:-4.7111em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES、AES、SM4、ZUC、RSA、ElGamal/列混合矩阵相乘.jpg" alt="列混合矩阵相乘" style="zoom:33%;" /><p>列混淆子层是AES算法中最为复杂的部分，属于扩散层，列混淆操作是AES算法中主要的扩散元素，它混淆了输入矩阵的每一列，使输入的每个字节都会影响到4个输出字节。行位移子层和列混淆子层的组合使得经过三轮处理以后，矩阵的每个字节都依赖于16个明文字节成可能。其中包含了矩阵乘法、伽罗瓦域内加法和乘法的相关知识。</p></li><li><p>轮密钥加（AddRoundKey）</p><p>密钥加是将轮密钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与状态 State 进行逐比特异或。</p><p>轮密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>由种子密钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">K_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 通过密钥扩展算法得到。</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES、AES、SM4、ZUC、RSA、ElGamal/AES轮密钥加.jpg" alt="AES轮密钥加" style="zoom:80%;" /></li><li><p>密钥拓展算法</p><p>由密钥扩展算法将种子密钥扩展成为扩展密钥的计算过程如下：</p></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>W</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>W</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><msub><mi>N</mi><mi>k</mi></msub><mo stretchy="false">]</mo><mo>⊕</mo><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mspace width="2em"/><mtext>      </mtext><mo stretchy="false">(</mo><mi>i</mi><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><msub><mi>N</mi><mi>k</mi></msub><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>W</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><msub><mi>N</mi><mi>k</mi></msub><mo stretchy="false">]</mo><mo>⊕</mo><mi>W</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mspace width="2em"/><mo stretchy="false">(</mo><mi>i</mi><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><msub><mi>N</mi><mi>k</mi></msub><mo mathvariant="normal">≠</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><mspace linebreak="newline" height="1.724em"></mspace><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mo>=</mo><mi>S</mi><mi>u</mi><mi>b</mi><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><mi>R</mi><mi>o</mi><mi>t</mi><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⊕</mo><mi>R</mi><mi>c</mi><mi>o</mi><mi>n</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">W[i]=\begin{cases}W[i-N_k]⊕temp\qquad\ \ \ \ \ \ (i\;mod\;N_k=0)\\[2ex]W[i-N_k]⊕W[i-1]\qquad(i\;mod\;N_k\ne0)\\\end{cases}\\[4ex]temp=SubByte(RotByte(W[i-1]))⊕Rcon[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.742em;vertical-align:-1.621em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.5em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.492em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.016em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.016em' style='width:0.8889em' viewBox='0 0 888.89 16' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V16 H384z M384 0 H504 V16 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.016em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.016em' style='width:0.8889em' viewBox='0 0 888.89 16' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V16 H384z M384 0 H504 V16 H384z'/></svg></span></span><span style="top:-4.3em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.121em;"><span style="top:-4.121em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:2em;"></span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-1.819em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:2em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.621em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline" style="margin-top:1.724em;"></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.05017em;">tB</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>temp首先将4个输入字节进行翻转，并执行一个按字节的S盒代换，最后用第一个字节与轮系数Rcon进行异或运算。</p><p>目的：一是增加密钥编排中的非线性；二是消除AES中的对称性。</p><p>这两种属性都是抵抗某些分组密码攻击必要的。</p><p>其中，</p><p>RotByte()：循环左移一个字节</p><p>SubByte()：S盒字节代换</p><p>Rcon[i]为轮常数，定义为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>c</mi><mi>o</mi><mi>n</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">(</mo><mi>R</mi><mi>C</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mn>00</mn><mo separator="true">,</mo><mn>00</mn><mo separator="true">,</mo><mn>00</mn><mo stretchy="false">)</mo><mspace linebreak="newline" height="0.862em"></mspace><mtext>其中</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>R</mi><mi>C</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mtext>，即</mtext><mn>01</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>R</mi><mi>C</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>x</mi><mo>⋅</mo><mi>R</mi><mi>C</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><msup><mi>x</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>i</mi><mo>≥</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">Rcon[i]=(RC[i],00,00,00)\\[2ex]其中\begin{cases}RC[1]=1，即01\\[2ex]RC[i]=x\cdot RC[i-1]=x^{k-1},(i\ge2)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">RC</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">00</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">00</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">00</span><span class="mclose">)</span></span><span class="mspace newline" style="margin-top:0.862em;"></span><span class="base"><span class="strut" style="height:3.742em;vertical-align:-1.621em;"></span><span class="mord cjk_fallback">其中</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.5em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.492em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.016em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.016em' style='width:0.8889em' viewBox='0 0 888.89 16' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V16 H384z M384 0 H504 V16 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.016em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.016em' style='width:0.8889em' viewBox='0 0 888.89 16' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V16 H384z M384 0 H504 V16 H384z'/></svg></span></span><span style="top:-4.3em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.121em;"><span style="top:-4.121em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">RC</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，即</span><span class="mord">01</span></span></span><span style="top:-1.819em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">RC</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">RC</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.621em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>​字节用十六进制表示，同时为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>F</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mn>8</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">GF(2^8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">GF</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>上的元素.</p><p>​其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>F</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mn>8</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">GF(2^8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">GF</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>域中的多项式 x 的 i-1次方所对应的字节。</p><p>​由于 x 对应的字节为 02，上式也可以写为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>c</mi><mi>o</mi><mi>n</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>02</mn><msup><mo stretchy="false">)</mo><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mn>00</mn><mo separator="true">,</mo><mn>00</mn><mo separator="true">,</mo><mn>00</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Rcon[i]=((02)^{i-1},00,00,00)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1247em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord">02</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">00</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">00</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">00</span><span class="mclose">)</span></span></span></span></span></p><p>Rcon[i]数据表（直接看这个表，上面Rcon[i]的定义课上没讲）</p><table><thead><tr><th>i</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>Rcon[i]</td><td>01000000</td><td>02000000</td><td>04000000</td><td>08000000</td><td>10000000</td><td>20000000</td><td>40000000</td><td>80000000</td><td>1b000000</td><td>36000000</td></tr></tbody></table><p>AES密钥大致流程：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES%E3%80%81AES%E3%80%81SM4%E3%80%81ZUC%E3%80%81RSA%E3%80%81ElGamal/v2-3027156eb00bcddcdac69657c8aad1e7_720w.jpg" alt="v2-3027156eb00bcddcdac69657c8aad1e7_720w"></p><p>​子密钥的生成是以列为单位进行的，一列是32Bit，四列组成子密钥共128Bit。生成子密钥的数量比AES算法的轮数多一个，因为第一个密钥加法层进行密钥漂白时也需要子密钥。</p><p>​密钥漂白是指在AES的输入盒输出中都使用的子密钥的XOR加法。</p><p>​子密钥在图中都存储在W[0]、W[1]、…、W[43]的扩展密钥数组之中。</p><p>​k1-k16表示原始密钥对应的字节，而图中子密钥k0与原始子密钥相同。</p><p>​在生成的扩展密钥中<strong>W的下标如果是4的倍数时(从零开始)需要对异或的参数进行G函数处理</strong>。</p>  <img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES、AES、SM4、ZUC、RSA、ElGamal/v2-772b661b3a89b1b3d7ec5fd0a47652e9_r.jpg" alt="v2-772b661b3a89b1b3d7ec5fd0a47652e9_r" style="zoom:67%;" /><p>在加密时行位移处理与解密时的处理相反，我们这里将解密时的处理称作逆行位移。它之所以称作行位移，是因为它只在4·4矩阵的行间进行操作，每行4字节的数据。在加密时，保持矩阵的第一行不变，第二行向左移动8Bit(一个字节)、第三行向左移动2个字节、第四行向左移动3个字节。而在解密时恰恰相反，依然保持第一行不变，将第二行向右移动一个字节、第三行右移2个字节、第四行右移3个字节。操作结束！</p><h2 id="SM4">SM4</h2><p>参考网址：</p><p><a href="http://www.mamicode.com/info-detail-2603734.html">http://www.mamicode.com/info-detail-2603734.html</a></p><p><a href="https://blog.csdn.net/cg129054036/article/details/83016958">https://blog.csdn.net/cg129054036/article/details/83016958</a></p><p>SM4是对称密钥中的分组密码</p><p>密钥标准长度  和  分组固定长度  都为128bit，所以每组的输出也为128bit</p><p>SM4是对“字”友好的算法，一个字节长度为8bit，一个字长度为4个字节，也就是32bit。SM4算法中，32bit的操作非常多，一方面是为了提高运行效率，另一方面也是为了一次性处理整数个字时的方便。</p><p>一些参数(以下每个变量表示一个字)</p><p>主密钥(128bit)：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>K</mi><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><msub><mi>K</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>M</mi><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>M</mi><msub><mi>K</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>M</mi><msub><mi>K</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">MK=(MK_0,MK_1,MK_2,MK_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>轮密钥(128bit)：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><msub><mi>k</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>r</mi><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>r</mi><msub><mi>k</mi><mn>31</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(rk_0,rk_1,\cdots,rk_{31})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，轮密钥由加密密钥生成</p><p>系统参数(128bit)：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>K</mi><mo>=</mo><mo stretchy="false">(</mo><mi>F</mi><msub><mi>K</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>F</mi><msub><mi>K</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>F</mi><msub><mi>K</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FK=(FK_0,FK_1,FK_2,FK_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，用于密钥扩展算法</p><p>固定参数(128bit)：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>K</mi><mo>=</mo><mo stretchy="false">(</mo><mi>C</mi><msub><mi>K</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>C</mi><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>C</mi><msub><mi>K</mi><mn>31</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CK=(CK_0,CK_1,\cdots,CK_{31})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>SM4算法加密流程图：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES%E3%80%81AES%E3%80%81SM4%E3%80%81ZUC%E3%80%81RSA%E3%80%81ElGamal/image-20200518183215647.png" alt="image-20200518183215647"></p><p>SM4算法示意图（将轮函数也放进去）：</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES%E3%80%81AES%E3%80%81SM4%E3%80%81ZUC%E3%80%81RSA%E3%80%81ElGamal/20190130190451954656.png" alt="20190130190451954656"></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>M</mi><mn>4</mn><mtext>笔记脉络</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>轮函数</mtext><mi>F</mi><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>合成置换</mtext><mi>T</mi><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>非线性变换</mtext><mi>τ</mi><mtext>—</mtext><mi>S</mi><mtext>盒</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>线性变换</mtext><mi>L</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>密钥拓展算法</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>反序变换</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">SM4笔记脉络\begin{cases}轮函数F\begin{cases}合成置换T\begin{cases}非线性变换\tau—S盒\\线性变换L\end{cases}\end{cases}\\密钥拓展算法\\反序变换\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.88em;vertical-align:-2.69em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SM</span><span class="mord">4</span><span class="mord cjk_fallback">笔记脉络</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-1.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.592em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.916em' style='width:0.8889em' viewBox='0 0 888.89 916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V916 H384z M384 0 H504 V916 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.916em' style='width:0.8889em' viewBox='0 0 888.89 916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V916 H384z M384 0 H504 V916 H384z'/></svg></span></span><span style="top:-5.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.19em;"><span style="top:-5.19em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord cjk_fallback">轮函数</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord cjk_fallback">合成置换</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">非线性变换</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mord">—</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">盒</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">线性变换</span><span class="mord mathnormal">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.932em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord cjk_fallback">密钥拓展算法</span></span></span><span style="top:-1.492em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord cjk_fallback">反序变换</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.69em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ol><li><p>轮函数F（32轮）</p><p>整体加密函数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>4</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub><mo separator="true">,</mo><mi>r</mi><msub><mi>k</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>X</mi><mi>i</mi></msub><mo>⊕</mo><mi>T</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub><mo>⊕</mo><mi>r</mi><msub><mi>k</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>i</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mn>31</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>这个是每一轮函数前最右边的那个</mtext><mi>X</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>前面三个</mtext><mi>X</mi><mtext>是由上一轮的后三个左移得到</mtext></mrow></mstyle></mtd></mtr></mtable></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}\begin{split}X_{i+4}&amp;=F(X_1,X_{i+1},X_{i+2},X_{i+3},rk_i)\\&amp;=X_i⊕T(X_{i+1},X_{i+2},X_{i+3}⊕rk_i)\\&amp;i=0,1,\cdots,31\\&amp;这个是每一轮函数前最右边的那个X\\&amp;前面三个X是由上一轮的后三个左移得到\end{split}\end{equation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.5em;vertical-align:-3.5em;"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4em;"><span style="top:-6em;"><span class="pstrut" style="height:6em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4em;"><span style="top:-6.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-0.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4em;"><span style="top:-6.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">31</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord cjk_fallback">这个是每一轮函数前最右边的那个</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span><span style="top:-0.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord cjk_fallback">前面三个</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord cjk_fallback">是由上一轮的后三个左移得到</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4em;"><span style="top:-6em;"><span class="pstrut" style="height:6em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5em;"><span></span></span></span></span></span></span></span></span></p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES%E3%80%81AES%E3%80%81SM4%E3%80%81ZUC%E3%80%81RSA%E3%80%81ElGamal/image-20200518183232491.png" alt="image-20200518183232491"></p><p>​SM4的轮函数F将输入部分看做了4个32bit长度的数据，每轮的后3个部分都向左移动32bit的数据长度，作为进行下一轮函数的前三个输入。</p><p>​这三组数据异或后进入非线性部分τ和线性部分L，运算后的结果与第一组数据异或并置于最右面。</p><p>​如此循环往复32轮，也就是数据一共左移了8个周期，将其中的混乱因素不断扩散至每个bit位中。</p><p>​最后将4段数据反序置放，如此才能在解密时重复利用现有的结构。</p><p>（1）合成置换T</p><p>​<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mtext>：</mtext><msubsup><mi>Z</mi><mn>2</mn><mn>32</mn></msubsup><mo>→</mo><msubsup><mi>Z</mi><mn>2</mn><mn>32</mn></msubsup></mrow><annotation encoding="application/x-tex">T：Z^{32}_{2}\rightarrow Z^{32}_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0622em;vertical-align:-0.2481em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0622em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span>，是一个可逆变换，由<strong>非线性变换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span><strong>和</strong>线性变换L</strong>复合而成</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>τ</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(\cdot)=L(\tau(\cdot))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">))</span></span></span></span></span></p><p>①非线性变换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span></p><p>​这个部分由4个平行的8bit进8bit输出的S盒组成。</p><p>​这里使用的S盒是一种256个数到256个数的映射，因为其具有较好的非线性程度等良好的密码学性质，比较适合用作数据混乱的核心工具。</p><p>​用公式表达<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>函数为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>S</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mtext>，</mtext><mi>S</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mtext>，</mtext><mi>S</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mtext> </mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b_0,b_1,b_2,b_3)=\tau(A)=(Sbox(a_0),Sbox(a_1)，Sbox(a_2)，Sbox(a_3)\ )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">b</span><span class="mord mathnormal">o</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">b</span><span class="mord mathnormal">o</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">b</span><span class="mord mathnormal">o</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">b</span><span class="mord mathnormal">o</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mclose">)</span></span></span></span></span></p><p>其中，输入为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A=(a_0,a_1,a_2,a_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>输出为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B=(b_0,b_1,b_2,b_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>​</p><p>​S盒如下表所示，S盒中的数据均采用十六进制数表示。</p><p>​设S盒的输入为EF，则经S盒运算的输出结果为表中第E行、第F列的值，即Sbox(EF)=0x84</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES%E3%80%81AES%E3%80%81SM4%E3%80%81ZUC%E3%80%81RSA%E3%80%81ElGamal/image-20200603110308761.png" alt="image-20200603110308761"></p><p>​经过4个S盒进行非线性映射后的数据，与原数据没有直观的数学关系，是抵抗线性分析非常有效的工具。</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES、AES、SM4、ZUC、RSA、ElGamal/SM4-S盒.png" style="zoom: 67%;" /><p>②线性变换L</p><pre><code> 非线性变换$\tau$的输出作为线性变换L的输入</code></pre><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>C</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>B</mi><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mo>&lt;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>⊕</mo><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mo>&lt;</mo><mn>10</mn><mo stretchy="false">)</mo><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mo>&lt;</mo><mn>18</mn><mo stretchy="false">)</mo><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mo>&lt;</mo><mn>24</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}\begin{split}C&amp;=L(B)\\&amp;=B⊕(B&lt;&lt;&lt;2)⊕⊕(B&lt;&lt;&lt;10)⊕(B&lt;&lt;&lt;18)⊕(B&lt;&lt;&lt;24)\end{split}\end{equation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">⊕</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">10</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">18</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">24</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></p></li></ol><blockquote><p>​直观解释为将B（τ函数的输出值，32bit）分别左移2,10,18,24比特后，与其自身一同异或，即可将比特位影响到其它位置。</p><p>​【&lt;&lt;&lt;表示向左循环移位】像移位、异或等这些操作都属于线性运算，硬件实现方便，软件实现同样高效，作为密码算法中辅助混乱扩散的重要部分，在算法中大量普遍存在。</p></blockquote><ol start="2"><li>密钥拓展算法</li></ol><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/DES%E3%80%81AES%E3%80%81SM4%E3%80%81ZUC%E3%80%81RSA%E3%80%81ElGamal/20190130190452177298.png" alt="技术分享图片"></p><blockquote><p>​这看上去是不是和轮密钥的结构是一样？</p><p>​这样在硬件实现上避免了单独制作一个轮密钥扩展电路，降低了电路门数，是一种不错的解决方法。</p><p>​这种结构生成的轮密钥是非线性度较高的，系统参数还能确保SM4算法在不同的应用环境中隔离使用，不同的系统中使用不同的系统参数，即使使用相同的密钥也无法加密加密，无法正常通信。</p></blockquote><p>轮密钥生成方法：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>K</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><msub><mi>K</mi><mn>0</mn></msub><mo>⊕</mo><mi>F</mi><msub><mi>K</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>M</mi><msub><mi>K</mi><mn>1</mn></msub><mo>⊕</mo><mi>F</mi><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>M</mi><msub><mi>K</mi><mn>2</mn></msub><mo>⊕</mo><mi>F</mi><msub><mi>K</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>M</mi><msub><mi>K</mi><mn>3</mn></msub><mo>⊕</mo><mi>F</mi><msub><mi>K</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mspace linebreak="newline" height="0.862em"></mspace><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>r</mi><msub><mi>k</mi><mi>i</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>K</mi><mrow><mi>i</mi><mo>+</mo><mn>4</mn></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>K</mi><mi>i</mi></msub><mo>⊕</mo><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><msub><mi>K</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>K</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>K</mi><mrow><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub><mo separator="true">,</mo><mi>C</mi><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">(K_0,K_1,K_2,K_3)=(MK_0⊕FK_0,MK_1⊕FK_1,MK_2⊕FK_2,MK_3⊕FK_3)\\[2ex]\begin{equation}\begin{split}rk_{i}&amp;=K_{i+4}\\&amp;=K_i⊕T&#x27;(K_{i+1},K_{i+2},K_{i+3},CK_i)\\\end{split}\end{equation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace newline" style="margin-top:0.862em;"></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>L</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>τ</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T&#x27;(\cdot)=L&#x27;(\tau(\cdot))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">))</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>变换与加密轮函数中的相同，只是线性变换L变为L’</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>L</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mo>&lt;</mo><mn>13</mn><mo stretchy="false">)</mo><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mo>&lt;</mo><mn>23</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L&#x27;(B)=B⊕(B&lt;&lt;&lt;13)⊕(B&lt;&lt;&lt;23)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">13</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">23</span><span class="mclose">)</span></span></span></span></span></p><p>系统参数FK取值固定，用十六进制数表示：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>K</mi><mo>=</mo><mo stretchy="false">(</mo><mi>F</mi><msub><mi>K</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>F</mi><msub><mi>K</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>F</mi><msub><mi>K</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FK=(FK_0,FK_1,FK_2,FK_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msub><mi>K</mi><mn>0</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mi>A</mi><mn>3</mn><mi>B</mi><mn>1</mn><mi>B</mi><mi>A</mi><mi>C</mi><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FK_0=(A3B1BAC6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msub><mi>K</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>56</mn><mi>A</mi><mi>A</mi><mn>3350</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FK_1=(56AA3350)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">56</span><span class="mord mathnormal">AA</span><span class="mord">3350</span><span class="mclose">)</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msub><mi>K</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>677</mn><mi>D</mi><mn>9197</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FK_2=(677D9197)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">677</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">9197</span><span class="mclose">)</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msub><mi>K</mi><mn>3</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mi>B</mi><mn>27022</mn><mi>D</mi><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FK_3=(B27022DC)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">27022</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span></p><p>(没讲)固定参数CK这样来取：设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>k</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mtext>为</mtext><mi>C</mi><msub><mi>K</mi><mi>i</mi></msub><mtext>的第</mtext><mi>j</mi><mtext>个字节</mtext><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mn>31</mn><mo separator="true">;</mo><mi>j</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ck_{ij}为CK_i的第j个字节(i=0,1,\cdots,31;j=0,1,2,3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">为</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">的第</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">个字节</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">31</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>K</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mi>c</mi><msub><mi>k</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo separator="true">,</mo><mi>c</mi><msub><mi>k</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi>c</mi><msub><mi>k</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><mi>c</mi><msub><mi>k</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>3</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CK_i=(ck_{i,0},ck_{i,1},ck_{i,2},ck_{i,3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>k</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><mi>i</mi><mo>+</mo><mi>j</mi><mo stretchy="false">)</mo><mo>×</mo><mn>7</mn><mtext>（</mtext><mi>m</mi><mi>o</mi><mi>d</mi><mn>256</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ck_{ij}=(4i+j)\times7（mod256)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord">256</span><span class="mclose">)</span></span></span></span></p><p>​32个固定参数CK的十六进制表示形式具体值：00070E15，1C232A31，383F464D，545B6269，70777E85，8C939AA1，A8AFB6BD，C4CBD2D9，E0E7EEF5，FC030A11，181F262D，343B4249，50575E65，6C737A81，888F969D，A4Abb2b9，C0C7CEd5，DCE3EAF1，F8FF060d，141B2229，30373E45，4C535A61，686F767D，848B9299，A0A7AEB5，BCC3CAD1，D8DFE6ED，F4FB0209，10171E25，2C333A41，484F565D，646B7279。</p><h2 id="ZUC">ZUC</h2><p>见pdf</p><h2 id="RSA">RSA</h2><ul><li><p>欧拉函数</p><ul><li><p>n：一正整数</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>：小于n且与n互为素数的正整数的个数</p></li><li><p>特殊地</p><ul><li>若p为素数，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mtext>（</mtext><mi>n</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">\psi（n）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">）</span></span></span></span>=p-1</li><li>那么，对于两个素数p和q，记它们的乘积n=qp，则有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(n)=(p-1)(q-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul></li><li><p>举个例子：</p><ul><li>求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span>。比6小且与6互素的正整数有{1，5}两个，所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\psi(6)=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></li><li>求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mn>21</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(21)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord">21</span><span class="mclose">)</span></span></span></span>。<ul><li>法:1：比21小而且比21互素的正整数有{1,2,4,5,8,10,11,13,16,17,19,20}共12个</li><li>法2：21=3×7（3和7都是素数），所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mn>21</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>7</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">\psi(21)=(3-1)×(7-1)=12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord">21</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span></li></ul></li></ul></li></ul></li><li><p>费马定理</p><ul><li>p：素数；a：正整数；且gcd（a，p）=1（即a和p互素）</li><li>则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>1</mn><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">a^{p-1}\equiv1\ mod\ p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">p</span></span></span></span></li></ul></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>S</mi><mi>A</mi><mtext>笔记脉络</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>参数定义和密钥生成</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>加密算法</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>解密算法</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">RSA笔记脉络\begin{cases}参数定义和密钥生成\\加密算法\\解密算法\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">RS</span><span class="mord mathnormal">A</span><span class="mord cjk_fallback">笔记脉络</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">参数定义和密钥生成</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">加密算法</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">解密算法</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ol><li><p>参数定义和密钥生成</p><p>（1）选两个大素数p和q；（p，q保密）</p><p>（2）计算n=pq，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(n)=(p-1)×(q-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>；（n公开，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>保密）</p><p>（3）随即选一整数e，要求满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>e</mi><mo>&lt;</mo><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1&lt;e&lt;\psi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>e</mi><mo separator="true">,</mo><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(e,\psi(n))=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>；（e公开）</p><p>（4）计算d，要求满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>×</mo><mi>d</mi><mo>≡</mo><mn>1</mn><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e\times d\equiv1(mod\psi(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>，即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mo>≡</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d\equiv e^{-1}(mod\psi(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span></p><p>​因为在（3）中选e时e就是要与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>互素，所以e的乘法逆元一定存在</p><p>​    （d保密）</p><p>p、q、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>可以销毁，但不能泄露</p></li><li><p>加密算法</p><p>加密时首先将明文比特串分组，使得每个分组对应的十进制数小于n，即分组长度小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>，然后对每个明文分组m，作加密运算得密文c</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mo>≡</mo><msup><mi>m</mi><mi>e</mi></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c\equiv m^e(mod\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p></li><li><p>解密算法</p><p>对密文分组进行解密运算得明文m</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo>≡</mo><msup><mi>c</mi><mi>d</mi></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m\equiv c^d(mod\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1491em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p></li></ol><h2 id="ElGamal">ElGamal</h2><ul><li>本原元==《杨波》P91==<ul><li>若g是n的本原元素，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><msup><mi>g</mi><mn>2</mn></msup><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msup><mi>g</mi><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(g,g^2,\cdots,g^{\psi(n)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ψ</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>在mod n下互不相同且都与n互素</li><li>特别地，若n是一个素数p；则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><msup><mi>g</mi><mn>2</mn></msup><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msup><mi>g</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(g,g^2,\cdots,g^{p-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>在mod n下都不相同</li><li>例子<ul><li>n=19，g=3，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mn>1</mn></msup><mtext>到</mtext><msup><mn>3</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">3^1到3^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">到</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">18</span></span></span></span></span></span></span></span></span></span></span></span>在mod 19下的幂分别为3, 9, 8, 5, 15, 7, 2, 6, 18, 16, 10, 11, 14, 4, 12, 17, 13, 1。即，3为19的本原元素</li></ul></li><li>本原元素不唯一，可验证除3外，19的本原元素还有2，10，13，14，15</li></ul></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mi>l</mi><mi>G</mi><mi>a</mi><mi>m</mi><mi>a</mi><mi>l</mi><mtext>笔记脉络</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>选取公共参数</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>确定公私钥对</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>加密变换</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>解密变换</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">ElGamal笔记脉络\begin{cases}选取公共参数\\确定公私钥对\\加密变换\\解密变换\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="mord mathnormal">ElG</span><span class="mord mathnormal">ama</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord cjk_fallback">笔记脉络</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-1.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.592em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.916em' style='width:0.8889em' viewBox='0 0 888.89 916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V916 H384z M384 0 H504 V916 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.916em' style='width:0.8889em' viewBox='0 0 888.89 916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V916 H384z M384 0 H504 V916 H384z'/></svg></span></span><span style="top:-5.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.13em;"><span style="top:-5.13em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">选取公共参数</span></span></span><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">确定公私钥对</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">加密变换</span></span></span><span style="top:-0.81em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">解密变换</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>（1）选取公共参数</p><p>​选择大素数p和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> 是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Z</mi><mi>p</mi><mo>∗</mo></msubsup></mrow><annotation encoding="application/x-tex">Z^*_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0718em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-2.453em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span></span></span></span>上的一个生成元） （p和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>公开）</p><p>（2）确定公私钥对</p><p>​随机选取整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>∈</mo><mtext>（</mtext><mn>0</mn><mtext>，</mtext><mi>p</mi><mo>−</mo><mn>1</mn><mtext>）</mtext></mrow><annotation encoding="application/x-tex">d\in （0，p-1）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">（</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span>（作为私钥），计算公钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>α</mi><mi>d</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">y=\alpha^d\ mod\ p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0435em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">p</span></span></span></span>（d是私钥，y是公钥）</p><p>（3）加密变换</p><p>​对于任意明文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∈</mo><msubsup><mi>Z</mi><mi>p</mi><mo>∗</mo></msubsup></mrow><annotation encoding="application/x-tex">m\in Z^*_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0718em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-2.453em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span></span></span></span>，随机选取一个整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k\in(1,p-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，计算密文</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>α</mi><mi>k</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mo separator="true">,</mo><mi>m</mi><msup><mi>y</mi><mi>k</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c_1,c_2)=(\alpha^k\ mod\ p,my^k\ mod\ p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1491em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></span></p><p>（4）解密变换</p><p>对任意密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∈</mo><msubsup><mi>Z</mi><mi>p</mi><mo>∗</mo></msubsup><mo>×</mo><msubsup><mi>Z</mi><mi>p</mi><mo>∗</mo></msubsup></mrow><annotation encoding="application/x-tex">(c_1,c_2)\in Z^*_p\times Z^*_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0718em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-2.453em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0718em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-2.453em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span></span></span></span>，使用私钥d进行解密得出明文m</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo>=</mo><msub><mi>c</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msubsup><mi>c</mi><mn>1</mn><mi>d</mi></msubsup><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">m=c_2(c_1^d)^{-1}\ mod\ p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1491em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">p</span></span></span></span></span></p><p>证明：</p><p>已知：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>=</mo><msup><mi>α</mi><mi>k</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mi>p</mi><mspace linebreak="newline"></mspace><msub><mi>c</mi><mn>2</mn></msub><mo>=</mo><mi>m</mi><msup><mi>y</mi><mi>k</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mspace linebreak="newline"></mspace><mi>y</mi><mo>=</mo><msup><mi>α</mi><mi>d</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">c_1=\alpha^k\ mod p\\c_2=my^k\ mod\ p\\y=\alpha^d\ mod\ p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0935em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0935em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">p</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0935em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">p</span></span></span></span></span></p><p>开始推导：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>c</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msubsup><mi>c</mi><mn>1</mn><mi>d</mi></msubsup><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≡</mo><mi>m</mi><msup><mi>y</mi><mi>k</mi></msup><mo stretchy="false">(</mo><msup><mi>α</mi><mrow><mi>d</mi><mtext> </mtext><mi>k</mi></mrow></msup><msup><mtext>）</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≡</mo><mi>m</mi><msup><mi>y</mi><mi>k</mi></msup><mo stretchy="false">(</mo><msup><mi>y</mi><mi>k</mi></msup><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mspace width="1em"/><mtext>【</mtext><msup><mi>y</mi><mi>k</mi></msup><mo stretchy="false">(</mo><msup><mi>y</mi><mi>k</mi></msup><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext>约掉】</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≡</mo><mi>m</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi></mrow></mstyle></mtd></mtr></mtable></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}\begin{split}c_2(c_1^d)^{-1}&amp;\equiv my^k(\alpha^{d\ k}）^{-1}\ mod\ p\\&amp;\equiv my^k(y^k)^{-1}\ mod\ p\quad【y^k(y^k)^{-1}约掉】\\&amp;\equiv m\ mod\ p\end{split}\end{equation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.6182em;vertical-align:-2.0591em;"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5591em;"><span style="top:-4.5591em;"><span class="pstrut" style="height:4.5591em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5591em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.1009em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-1.6009em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0591em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5591em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord cjk_fallback">）</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">p</span></span></span><span style="top:-3.1009em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">【</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">约掉】</span></span></span><span style="top:-1.6009em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">m</span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0591em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0591em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5591em;"><span style="top:-4.5591em;"><span class="pstrut" style="height:4.5591em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0591em;"><span></span></span></span></span></span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Windows安全 </category>
          
          <category> 解密篇 </category>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DES </tag>
            
            <tag> AES </tag>
            
            <tag> SM4 </tag>
            
            <tag> ZUC </tag>
            
            <tag> RSA </tag>
            
            <tag> ElGamal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++笔记-网易云课堂翁恺老师</title>
      <link href="/posts/a9cf272f.html"/>
      <url>/posts/a9cf272f.html</url>
      
        <content type="html"><![CDATA[<h2 id="良好的程序风格建议">良好的程序风格建议</h2><ul><li>消灭所有的warning，它是隐藏的error。当然，级别不一样。</li><li>每个类对应一个.h和一个.cpp文件</li><li>建议：类里所有成员变量都在Initializer list初始化，父类的构造函数调用也要放这里</li><li>建议：坚决不用default value</li><li>每写一个类，不管当前有用没有，把default constructor，virtual destructor，copy constructor写下来</li><li>尽量少用（运算符重载里讲的）类型转换，更倾向于使用显示的函数，方便代码阅读</li></ul><h2 id="基本概念">基本概念</h2><h3 id="什么是对象">什么是对象</h3><ul><li><p>What is an object?</p><ul><li>Object对象=Entity东西</li><li>Object may be visible or invisible，对象可以是实体(eg.杯子)也可以是虚物(eg.我说的话，但可被加工、记录)</li><li>Object is variable in programming languages.在程序设计语言中，对象以变量形式出现</li></ul></li><li><p>Object=Attributes属性+Services服务</p><ul><li>Data=the propertied or status</li><li>Operations：the functions</li><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200416141954690.png" alt="image-20200416141954690" style="zoom:50%;" /></li><li><strong>！！只能通过对象提供的服务去接触里面的属性！！</strong></li></ul></li><li><p>Mapping</p><ul><li>From the problem space to the solution one.</li><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200416144904543.png" alt="image-20200416144904543" style="zoom:50%;" /></li></ul></li><li><p>面向过程 vs. 面向对象</p><ul><li>按时间顺序发送的流程 vs. 存在什么</li></ul></li><li><p>What is object-oriented?</p><ul><li><p>物件导向，从对象出发来考虑、分析、解决问题</p></li><li><p>A way to organize 是一种用来组合设计和实现的方式</p><ul><li>Designs  设计，找到问题的解决思路</li><li>Implementations  实现，把代码写出来</li></ul></li><li><p>Objects,not control or data flow,are the primary focus of the design and implementation.</p><p>对象，是我们设计和实现主要关注的东西，而不是控制或数据流转（它的过程）</p></li><li><p>To focus on things,not operations.</p></li></ul></li></ul><h3 id="面向对象基本原理">面向对象基本原理</h3><ul><li><p>Object Oriented Programming</p><ul><li>Objects send and receive messages(objects do things!)</li><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200416150129871.png" alt="image-20200416150129871" style="zoom:50%;" /></li></ul></li><li><p>Objects send messages</p><ul><li><p>Messages are</p><ul><li>Composed by the sender  sender表达你要干什么</li><li>Interpreted by the receiver  实不实现，由receiver接受者决定</li><li>Implemented by methods</li></ul></li><li><p>Messages</p><ul><li><p>May cause receiver to change state  消息可能会让接受者改变状态</p></li><li><p>May return results</p><p>消息可能返回结果，可以通过消息本身返回结果（函数有返回值）or通过另外一个消息去读取你的结果（不过在OOP本意里，你的结果（状态）我是另外去读的）</p></li></ul></li></ul></li><li><p>Object vs. Class东西的总类</p><ul><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200416151311319.png" alt="image-20200416151311319" style="zoom:50%;" /></li><li>Object(cat)   实体<ul><li>Represent things,events,or concepts</li><li>Respond to messages at run-time</li></ul></li><li>Classes(cat class)  概念<ul><li>Define properties of instances</li><li>Act like types in C++</li></ul></li></ul></li><li><p>OOP Characteristics  OOP五大原则</p><ol><li>Everything is an object.一切都是对象</li><li>A program is a bunch of objects telling each other <strong>what</strong> to do by sending messages.<ul><li>程序是一堆对象以消息的方式告诉别人要去做什么</li><li>what to do而不是how to do，怎么做由接受者决定。人日常打交道也是what to do，告诉你要去做什么，不会去教你怎么做</li></ul></li><li>Each object has its own memory made up of other objects.<ul><li>每一个对象有它自己的内存，对象里也有自己的对象；对象里面有对象</li><li>对象可以细分下去，但为了某种大局，分到一定程度就可以了。这叫抽象，屏蔽细节</li></ul></li><li>Every object has a type.<ul><li>所有对象都有它自己的类型</li><li>对于OOP来说，先有类型后有对象，任何东西都是由某个类型定义出来的</li></ul></li><li>All objects of a particular type can receive the same messages.<ul><li>正过来：一个特定类型的所有对象可以接收相同的消息</li><li>反过来：所有可以接收相同消息的对象可以被认为是相同的类型</li></ul></li></ol></li><li><p>An object has an interface</p><ul><li>The interface is the way it receives messages.  对象都是以接口和外界打交道</li><li>It is defined in the class the object belong to.  这个接口也定义了它是哪一类</li></ul></li><li><p>Functions of the interface</p><ul><li>Communication  通信、交流</li><li>Protection  接口能对内部的Attribute进行保护</li></ul></li><li><p>The Hidden Implementation</p><ul><li>Inner part of an object,data members to present its state,and the actions it takes when messages is hidden.</li><li>Class creators（写类的人） vs. Client programmers （用别人写完现有的类去写东西）<ul><li>Keep client programmers’ hands off portions they should not touch.</li><li>Allow the class creators to change the internal working of the class without worrying about it will affect the client programmers.</li></ul></li></ul></li><li><p>Encapsulation 分装</p><ul><li>bundle data and methods dealing with these data together in an object</li><li>Hide the details of the data and the action</li><li>Restrict only access to the publicized methods.</li></ul></li></ul><h3 id="自动售票机例子">自动售票机例子</h3><ul><li><p>::resolver域的解析符</p><ul><li><p><Class Name>::<function name></p></li><li><p>::<function name></p></li><li><pre><code class="language-c++">void S::f() &#123;::f( ); // Would be recursive otherwise!  全局的f()::a++; // Select the global a   全局的aa--; //The a at class scope    用类里的成员变量a&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 头文件</span><br><span class="line"></span><br><span class="line">+ Definition of a class </span><br><span class="line">  + In C++, separated .h and .cpp files are used to define one class.</span><br><span class="line">  + Class declaration and prototypes in that class are in the header file (.h).类的声明放.h</span><br><span class="line">  + All the bodies of these functions are in the source file (.cpp). 类中函数body部分放.cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ The header files</span><br><span class="line">  + If a function is declared in a header file, you must include the header file everywhere the function is used and where the function is defined.</span><br><span class="line">    + 一个函数在头文件中声明，要在所有用到这个函数以及定义这个函数body的文件中#include这个头文件</span><br><span class="line">  + If a class is declared in a header file, you must include the header file everywhere the class is used and where class member functions are defined.</span><br><span class="line">    + 一个类在头文件中声明，要在所有用到这个类以及定义这个类实体的文件中#include这个头文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Header = interface</span><br><span class="line">  + The header is a contract between you and the user of your code.</span><br><span class="line">    + 程序员通过.h告诉使用者这个类长什么样子，你怎样去用。然后使用者#include这个类的头文件去做事情。这是程序员和使用这个类的人之间的一种合同</span><br><span class="line">  + The compile enforces the contract by requiring you to declare all structures and functions before they are used.</span><br><span class="line">    + 编译器会强化这种合同，你在使用所有结构和函数之前必须要声明它们，否则无法使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Structure of C++ program</span><br><span class="line"></span><br><span class="line">  + &lt;img src=&quot;/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200416170958761.png&quot; alt=&quot;image-20200416170958761&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  + 各种后缀名文件</span><br><span class="line">    + .h</span><br><span class="line">    + .cpp</span><br><span class="line">    + .ii编译预处理后的文件</span><br><span class="line">    + .o目标代码</span><br><span class="line">    + .out最终可执行程序</span><br><span class="line">    + .s汇编</span><br><span class="line">    + 编译顺序</span><br><span class="line">      + $.cpp\ \ 预编译处理指令\longrightarrow.ii\ \ 编译器\longrightarrow.s\ \ 汇编器\longrightarrow.o\ \ \ ld链接器 \longrightarrow .out$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Declarations vs. Definitions</span><br><span class="line"></span><br><span class="line">  + A.cpp file is a compile unit</span><br><span class="line"></span><br><span class="line">    + 一个.cpp文件是一个编译单元，编译时候只针对这个.cpp文件进行编译</span><br><span class="line"></span><br><span class="line">  + Only declarations are allowed to be in .h  </span><br><span class="line"></span><br><span class="line">    只能在.h放声明。如果放了定义，有多个.cpp#include了这个.h，编译能过（因为每个.cpp是一个编译单元），但链接器那关会出问题，duplicate symbol</span><br><span class="line"></span><br><span class="line">    + extern variables 全局变量声明(extern int i;前面加extern是声明)</span><br><span class="line">    + function prototypes 函数原型（没有&#123;&#125;的是声明）</span><br><span class="line">    + class/struct declaration 类/结构体声明（类/结构体没有叫定义的东西）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ #include</span><br><span class="line"></span><br><span class="line">  + #include is to insert the included file into the .cpp file at where the #include statement is.</span><br><span class="line"></span><br><span class="line">    #编译预处理，把你#的头文件里的**文本插入**进来，形成一个编译前的大文件</span><br><span class="line"></span><br><span class="line">    + #include“xx.h&quot;&quot;：first search in the current directory, then the directories declared somewhere.  </span><br><span class="line"></span><br><span class="line">      先从那个#include了的文件的当前目录找这个.h</span><br><span class="line"></span><br><span class="line">    + #include &lt;xx.h&gt;:search in the specified directories.  </span><br><span class="line"></span><br><span class="line">      去系统目录找(编译器所认定的头文件所在的目录windows没统一目录，通常在编译器安装的目录下；UNIX在  /usr/include/)</span><br><span class="line"></span><br><span class="line">    + #include &lt;xx&gt; :same as #include &lt; &lt;xx.h&gt;（做文本插入功能，管你后缀是啥）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Standard header file structure</span><br><span class="line"></span><br><span class="line">  + #ifndef HEADER_ FLAG</span><br><span class="line">    #define HEADER_ FLAG</span><br><span class="line">    // Type declaration here.. .</span><br><span class="line">    #endif   // HEADER_ _FLAG </span><br><span class="line"></span><br><span class="line">  为了防止在同一个.cpp文件里多次#include了一个.h，而出现那个.h里类的声明重复出现的问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Tips for header</span><br><span class="line">  1. One class declaration per header file  一个头文件只放一个类</span><br><span class="line">  2. Associated with one source file in the same prefix of file name.</span><br><span class="line">  3. The contents of a header file is surrounded with #ifndef #define #endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 时钟的例子</span><br><span class="line"></span><br><span class="line">+ Abstract抽象</span><br><span class="line"></span><br><span class="line">  + Abstraction is the ability to ignore details of parts to focus attention on a higher level of a problem.</span><br><span class="line"></span><br><span class="line">    忽略细节</span><br><span class="line"></span><br><span class="line">  + Modularization is the process of dividing a whole into well-defined parts, which can be built and examined separately, and which interact in well-defined ways.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 成员变量</span><br><span class="line"></span><br><span class="line">+ local variable</span><br><span class="line"></span><br><span class="line">  + Local variables are defined inside a method,have a scope limited to the method to which they belong.</span><br><span class="line"></span><br><span class="line">    在函数内部定义的变量叫本地变量，它只在这个函数执行时有效</span><br><span class="line"></span><br><span class="line">  + A local variable of the same name as a field will prevent the field being accessed from within a method.  </span><br><span class="line"></span><br><span class="line">    函数里本地变量和成员变量同名，最近原则，按照最近的定义来，所以成员变量被屏蔽</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Fields成员变量，parameters函数的形参，local variables本地变量</span><br><span class="line">  + All three kinds of variable are able to store a value that is appropriate to their defined type.</span><br><span class="line">  + Fields are defined outside constructors and methods.</span><br><span class="line">  + Fields are used to store data that persists throughout the life of an object.成员变量在谋某个对象的生存期一直存在，它的作用域是类的作用域，在整个类的所有成员函数都可以直接使用这些成员变量As such, they maintain the current state of an object. They have a lifetime that lasts as long as their object lasts.</span><br><span class="line">  + Fields have class scope: their accessibility extends throughout the whole class, and so they can be used within any of the constructors or methods of the class in which they are defined.</span><br><span class="line">  + parameters和local varibles完全一样，存储都是本地存储，存放在堆栈stack，进入函数前不存在，离开函数不存在，具体位置是不一样的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ 成员变量在类定义的每一个对象里。类是declaration，这里有一个，有这么个东西，但不指出在哪里。类是概念、虚的、观点，不拥有变量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ 函数是属于类的，不是属于对象的</span><br><span class="line"></span><br><span class="line">~~~c++</span><br><span class="line">#include &lt;iostream&gt;using namespace std;class A&#123;public:    A():i(10)&#123;&#125;    void f();private:    int i;&#125;;void A::f()&#123;    i=20;    cout&gt;&gt;i&gt;&gt;endl;&#125;int main()&#123;    A a;    A aa;    a.f();    aa.f();        return 0;&#125;------------------------------------------------------------------------------------------------f()如何知道是哪个对象的i去调用它？------------------------------------------------------------------------------------------------//c的代码如何实现谁调它？struct B&#123;    int i;&#125;;void f(struct B* p)&#123;    p-&gt;i=20;    cout&lt;&lt;p-&gt;i&lt;&lt;endl;&#125;//从这里得到启发，猜测通过传对象的地址给类里的函数（如下）------------------------------------------------------------------------------------------------void A::f(A* p)&#123;    p-&gt;i=20;    cout&gt;&gt;p-&gt;i&gt;&gt;endl;&#125;    int main()&#123;    ....    A::f(&amp;a);&#125;    ------------------------------------------------------------------------------------------------//证明过程：#include &lt;stdio.h&gt;class A&#123;public:    A():i(10)&#123;&#125;    void f();private:    int i;&#125;;void A::f()&#123;    i=20;    printf(&quot;A::f()--&amp;i=%p\n&quot;,&amp;i);&#125;int main()&#123;    A a;    printf(&quot;&amp;a=%p\n&quot;,&amp;a);    printf(&quot;&amp;a.i=%p\n&quot;,&amp;(a.i));    a.f();        A aa;    printf(&quot;&amp;aa=%p\n&quot;,&amp;aa);    aa.f();        return 0;&#125;------------------------------------------------------------------------------------------------//运行结果：Kai-MBA:cc wengkai$ g++ -m32 a.cppKai-MBA:cc wengkai$ ./a.out&amp;a=0xbff99c58&amp;a.i=0xbff99c58A::f()--&amp;i=0xbff99c58&amp;aa=0xbff99c50.A::f()--&amp;i=0xbff99c50//不同对象去调同一个函数，这个函数知道是哪个对象调它------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>Call functions in a class</p><p>Point a;</p><p>a. print();</p><ul><li>There is a relationship with the function be called and the variable calls it.</li><li>The function itself knows it is doing something with the variable.</li></ul></li><li><p>this: the hidden parameter</p><ul><li><p>this is a hidden parameter for all member functions,with the type of the class</p><p>void Point::print()     --&gt; (can be regarded as)     void Point::print(Point *p)</p></li></ul></li><li><p>this: pointer to the caller</p><ul><li>Inside member functions, you can use <strong>this</strong> as the pointer to the variable that calls the function.</li><li>this is a natural local variable of all class member functions that you can not define, but can use it directly.</li></ul></li></ul><h3 id="构造与析构">构造与析构</h3><ul><li><p>没给对象初始化，对象的值是内存中随机的值（为了效率）。而JAVA的值是0</p><p>（visual studio，未初始化内存，Debug模式下编译时会往内存塞两个0xCD，连起来是国标码的“烫”，表名你未初始化内存）</p></li><li><p>Guaranteed initialization with the constructor （加入一种机制，哪怕初级程序员也能提醒他去做，即构造器（constructor））</p><ul><li>If a class has a constructor, the compiler automatically calls that constructor at the point an object is created, before client programmers can get their hands on the object.在对象被创建时自动调用</li><li>The name of the constructor is the same as the name of the class.  构造函数和类名字一样，无返回类型</li></ul></li><li><p>How a constructor does?</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200421174716835.png" alt="image-20200421174716835" style="zoom:50%;" /><p>X a;的时候实际上是作a.X();</p></li><li><p>Constructors with arguments  构造函数带参数</p><ul><li><p>The constructor can have arguments to allow you to specify how an object is created, give it initialization values, and so on.</p><p>Tree(int i) {…}</p><p>Tree t(12);</p></li></ul></li><li><p>The destructor</p><ul><li><p>In C++, cleanup is as important as initialization and is therefore guaranteed with the destructor.</p></li><li><p>The destructor is named after the name of the class with a leading tilde (~).The destructor never has any arguments.</p></li><li><p>都析构了，没法给参数</p></li><li><p>析构函数用来处理先前内部申请的资源</p></li><li><pre><code class="language-c++">class Y&#123;public:    ~Y();&#125;;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ When is a destructor called?</span><br><span class="line"></span><br><span class="line">  + The destructor is called automatically by the compiler when the object goes out of scope.</span><br><span class="line"></span><br><span class="line">  + The only evidence for a destructor call is the closing brace of the scope that surrounds the object.</span><br><span class="line"></span><br><span class="line">    对象在关闭的大括号时调用析构函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 对象初始化</span><br><span class="line"></span><br><span class="line">+ Storage allocation</span><br><span class="line"></span><br><span class="line">  + The compiler allocates all the storage for a scope at the opening brace of that scope.</span><br><span class="line"></span><br><span class="line">    编译器在大括号开始的地方，分配大括号里所有变量的空间</span><br><span class="line"></span><br><span class="line">  + The constructor call doesn&#x27;t happen until the sequence point where the object is defined.</span><br><span class="line"></span><br><span class="line">    构造器要在对象的定义时才调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Aggregate initialization  数组初始化</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  int a[5]=&#123;1,2，3，4,5&#125;;int b[6] = &#123;5&#125;;//第一个是5，其余是0int c[]=&#123;1，2,3,4&#125;;-sizeof C / sizeof *c//整个数组大小/某个单元大小=个数    struct X&#123; int i;float f;char c; &#125;;-X x1=&#123;1, 2.2，&#x27;c&#x27; &#125;;X x2[3] = &#123; &#123;1，1.1， &#x27;a&#x27;&#125;，&#123;2, 2.2， &#x27;b&#x27;&#125; &#125;;struct Y &#123; float f; int i; Y(int a); &#125;;Y y1[] = &#123; Y(1)，Y(2)，Y(3) &#125;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>The default constructor   缺省无参构造函数</p><ul><li><p>A default constructor is one that can be called with no arguments.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> &#123;</span>     <span class="keyword">float</span> f;    <span class="keyword">int</span> i;    <span class="built_in">Y</span>(<span class="keyword">int</span> a); &#125;;Y y1[] = &#123; <span class="built_in">Y</span>(<span class="number">1</span>)，<span class="built_in">Y</span>(<span class="number">2</span>)，<span class="built_in">Y</span>(<span class="number">3</span>) &#125;;<span class="comment">//okY y2[2]=&#123;Y(1)&#125;;//error  没给第二个参数----------------------------------------------------------------------------------------报错：    no matching function for call to ‘A::A()’    </span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="new-delete">new&amp;delete</h3><ul><li><p>Dynamic memory allocation  c++引入两个运算符（运算一定有结果）</p><ul><li>new  运算的结果是地址<ul><li>new int</li><li>new Stach;  分配类Stach的空间，分配后调用构造函数</li><li>new int[10];</li></ul></li><li>delete    给地址给它，delete掉。先调用析构函数，然后delete掉<ul><li>delete p;</li><li>delete[]  p;</li></ul></li><li>new&lt;-&gt;delete               new p[ ]&lt;-&gt;delete [ ] p</li></ul></li><li><p>new and delete</p><ul><li>new is the way to allocate memory as a program runs. Pointers become the only access to that memory  指针是访问这块内存的唯一方式</li><li>delete enables you to return memory to the memory pool when you are finished with it.</li></ul></li><li><p>Dynamic Arrays  动态数组</p><ul><li>int* psome = new int [10];<ul><li>The new operator returns the address of the first element of the block.</li></ul></li><li>delete[ ] psome;<ul><li>The presence of the brackets tells the program that it should free the whole array, not just the element</li></ul></li></ul></li><li><p>The new-delete mech.</p><ul><li>new在堆里找块空地，同时会有张表记录申请多大的空间（字节为单位），以及申请的地址是多少</li><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200421212515639.png" alt="image-20200421212515639" style="zoom:67%;" /></li><li>编译时，通过q的类型知道是一个类，要析构，所以先析构，后delete</li><li>delete的时候找这个表，然后读表上的地址，收回表上记录的字节大小，同时把表抹掉</li><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/wps2.jpg" alt="wps2" style="zoom:67%;" /></li><li>new p[ ]但delete p，只会调用第一个析构（即p所指的那个对象的析构），但空间是全都回收（空间回收和表有关）<ul><li>[ ]告诉它由多个对象，具体多少个它自己会算</li></ul></li></ul></li><li><p>Tips for new and delete</p><ul><li><p>Don’t use <strong>delete</strong> to free memory that <strong>new</strong> didn’t allocate. 不要用delete去free不是new出来的空间，因为没那个表</p></li><li><p>Don’t use <strong>delete</strong> to free the same block of memory twice in succession. 不要delete同一块</p></li><li><p>Use <strong>delete [ ]</strong> if you used <strong>new [ ]</strong> to allocate an array.</p></li><li><p>Use <strong>delete</strong> (no brackets) if you used <strong>new</strong> to allocate a single entity.</p></li><li><p>It’s safe to apply <strong>delete</strong> to the null pointer (nothing happens).  delete空指针是安全的，（delete前判断一下，若空则不做事情）</p><ul><li><p>留这个口子为了代码好写</p></li><li><p>eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">private</span>:    <span class="keyword">int</span> *p;<span class="keyword">public</span>:    <span class="built_in">A</span>()&#123;        p=<span class="number">0</span>;        ...&#125;    ~<span class="built_in">A</span>()    &#123;        <span class="comment">//if (p)  但还是建议加上这行，稳妥，保险。如果new了不delete会发生内存泄漏        delete p;        ...    &#125;        void f()    &#123;        p=new int;    &#125;    &#125;;void f()不一定被调用，所以delete了空指针，因为留了这个口子，所以这样没事</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="访问限制">访问限制</h3><ul><li><p>Setting limits</p><ul><li>to keep the client programmer’s hands off members they shouldn’t touch.</li><li>to allow the library designer（写这个类的人） to change the internal workings of the structure without worrying about how it will affect the client programmer.</li></ul></li><li><p>C++ access control</p><ul><li><p>The members of a class can be cataloged,marked as:</p><p>-public  任何人</p><p>-private  只有类的成员函数可以访问这些成员变量或者成员函数</p><p>-protected  只有类自己以及子子孙孙可以</p></li></ul></li><li><p>public</p><ul><li>public means all member declarations that follow are available to everyone.</li></ul></li><li><p>private</p><ul><li>The private keyword means that no one can access that menber except inside function members of that type.</li><li>private是对类而言的，而不是对象。<strong>同一个类里的不同对象是可以互相访问的</strong></li></ul></li><li><p>public和private权限仅仅在编译时刻编译器来检查，运行时没人管了</p></li><li><p>Friends</p><ul><li><p>to explicitly grant access to a function that isn’t a member of the structure</p></li><li><p>The class itself controls which code has access to its members.</p></li><li><p>Can declare a global function as a <strong>friend</strong>, as well as a member function of another class,or even an entire class, as a <strong>friend</strong>.</p></li><li><pre><code class="language-c++">//: C05:Friend. cpp// From Thinking in C++, 2nd Edition// Available at http ://www.BruceEckel.com// (c) Bruce Eckel 2000// Copyright notice in Copyright.txt// Friend allows special access// Declaration (incomplete type specification): struct X;//前向声明，告诉编译器X是个东西，但不需要知道X具体什么样struct Y &#123;void f(X*);//因为后面Y里用到了X，要让编译通过&#125;;struct X &#123; // Definitionprivate:int i;public:void initialize();friend void g(X*，int); // Global friendfriend void Y::f(X*); // Struct member friend   //X里面用到了Y里的f()，所以Y要在struct X前面声明friend struct Z; // Entire struct is a friendfriend void h();&#125;;void x::initialize() &#123;i=0;&#125;void g(X* x，int i) &#123;x-&gt;i = i;&#125;void Y::f(X* x) &#123;x-&gt;i = 47;&#125;struct Z &#123;private:int j;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + 已经封装的一个类，比如系统库那你没办法去friend了</span><br><span class="line"></span><br><span class="line">  + friend授权是编译时候检查</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ class vs. struct</span><br><span class="line">  + **class** defaults to **private **     class缺省访问属性默认为private</span><br><span class="line">  + **struct** defaults to **public**      struct 默认为public</span><br><span class="line">  + 在c++首选用class，除非那个类简单到无以复加，只是表达几个数字组合，用struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 初始化列表</span><br><span class="line"></span><br><span class="line">+ Initializer list</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  class Point &#123;private :const float X，y;Point(float xa = 0.0，float ya = 0.0): y(ya)，x(xa) &#123;&#125;&#125;;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>Can initialize any type of data<br>一pseudo-constructor calls for built- ins<br>一No need to perform assignment within body of ctor</p></li><li><p>Order of initialization is order of declaration</p><p>—Not the order in the list!</p><p>—Destroyed in the reverse order.</p></li></ul></li><li><p>Initialization vs. assignment</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student:: <span class="built_in">Student</span> (string s) :<span class="built_in">name</span> (s) &#123;&#125;</span><br></pre></td></tr></table></figure><p>initialization<br>before constructor</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student:: <span class="built_in">Student</span> (string s) &#123;name=s; &#125;</span><br></pre></td></tr></table></figure><p>assignment</p><p>inside constructor</p><p>string must have a default constructor</p></li><li><p>建议：类里所有成员变量都在Initializer list初始化</p><p>​父类的构造函数调用也要放这里</p></li></ul><h3 id="对象组合">对象组合</h3><ul><li><p>Reusing the implementation  软件重用</p><ul><li><p>Composition: construct new object with existing objects</p></li><li><p>It is the relationship of“has-a&quot;</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422143910989.png" alt="image-20200422143910989" style="zoom:50%;" /></li></ul></li><li><p>Composition  组合</p><ul><li>Objects can be used to build up other objects</li><li>Ways of inclusion   （根据语义选择）<br>-Fully  是组成我的一部分（成员变量是对象）<br>-By reference  我知道它在哪，可以调用它，但不是我身体一部分（成员变量是指针）</li><li>Inclusion by reference allows sharing</li><li>For example,an Employee has a<ul><li>Name</li><li>Address</li><li>Health Plan</li><li>Salary History<ul><li>Collection of Raise objects</li></ul></li><li>Supervisor  （前面是Fully，这个不能是Fully，语义不符合，且Employee里又有Employee，完没了）<ul><li>Another Employee object!</li></ul></li><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422162014753.png" alt="image-20200422162014753" style="zoom:50%;" /></li></ul></li></ul></li><li><p>Example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span> . .. &#125;;<span class="class"><span class="keyword">class</span> <span class="title">Currency</span> &#123;</span> . .. &#125;;<span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> &#123;</span><span class="keyword">public</span>:<span class="built_in">SavingsAccount</span>( <span class="keyword">const</span> <span class="keyword">char</span>* name ,<span class="keyword">const</span> <span class="keyword">char</span>* address, <span class="keyword">int</span> cents ) ;~<span class="built_in">SavingsAccount</span> () ;<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>;<span class="keyword">private</span> :Person m saver ;Currency m_ balance;&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>组合进来的对象仍是独立的，不能去破坏它的边界</p></li><li><p>SavingsAccount初始化列表要调用那两个组合对象的构造函数，让它们自己处理自己内部的事情</p><p>如果不调用，就要要求m_saver和m_balance这两个对象要有default constructor</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Savi ngsAccount: : <span class="built_in">SavingsAccount</span>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* address,<span class="keyword">int</span> cents):<span class="built_in">m_saver</span> (name，address) ，<span class="built_in">m_balance</span> (<span class="number">0</span>，cents) &#123; &#125;<span class="comment">//仍然用组合进来的对象提供的操作去访问它的成员void SavingsAccount::print() &#123;m_saver.print () ;m_balance.print() ;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Embedded objects(课上没讲？)</p><ul><li><p>All embedded objects are initialized</p><p>—The default constructor is called if</p><ul><li>you don’t supply the arguments, and there is a default constructor (or one can be built)</li></ul></li><li><p>Constructors can have initialization list</p><p>—any number of objects separated by commas</p><p>—is optional</p><p>—Provide arguments to sub-constructors</p></li><li><p>Syntax:name ( args )  [ ‘:’ init-list ] ‘{‘</p></li></ul></li><li><p>Question</p><ul><li><p>If we wrote the constructor as (assuming we have the set accessors for the subobjects):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SavingsAccount::<span class="built_in">SavingsAccount</span> ( <span class="keyword">const</span> <span class="keyword">char</span>* name,<span class="keyword">const</span> <span class="keyword">char</span>* address, <span class="keyword">int</span> cents ) &#123;m_saver.<span class="built_in">set_name</span> ( name ) ;m_saver.<span class="built_in">set_address</span> ( address ) ;m_balance.<span class="built_in">set_cents</span> ( cents ) ;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Default constructors would be called</p></li></ul></li><li><p>Public vs. Private</p><ul><li><p>It is common to make embedded objects (嵌入对象)</p><p>private:</p><p>—they are part of the underlying implementation</p><p>—the new class only has part of the public interface of the old class</p></li><li><p>Can embed as a public object if you want to have the entire public interface of the subobject available in the new object:（如果设置嵌入对象为public）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> &#123;</span><span class="keyword">public</span>:Person m saver;    ...&#125;;<span class="comment">// assumePerson class haS set name ( )SavingsAccount account ;account.m saver.set_name (&quot;Fred&quot; ) ;//通过.来访问//但不是OOP所喜欢的，破坏了封装</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="继承">继承</h3><ul><li><p>组合和继承都是软件重用的一种方式</p><ul><li>区别：<ul><li>组合：拿已有对象拼装成一个新对象，（玩实的）</li><li>继承：改造一个类，（玩虚的）</li></ul></li></ul></li><li><p>Reusing the interface</p><ul><li>Inheritance is to take the existing class, clone it,and then make additions and modifications to the clone.</li></ul></li><li><p>Inheritance</p><ul><li><p>Language implementation technique</p></li><li><p>Also an important component of the OO design methodology</p></li><li><p>Allows sharing of design for</p><ul><li>Member data</li><li>Member functions</li><li>Interfaces  一个类public的部分是这个类的Interfaces，它可能有Member data，可能有Member functions，所以这里写个Interfaces</li></ul></li><li><p>Key technology in C++</p></li><li><p>The ability to define the behavior or implementation of one class as a <strong>superset</strong> （超集）of another class.</p><ul><li><p>这句话one class是指：Student</p><p>another class是指Person</p><p>Studnet是在Person的属性上扩充，表达学生的数据比表达Person的数据要多，是对原有的类进行扩充，所以说superset（超集）</p></li></ul></li><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422145613325.png" alt="image-20200422145613325" style="zoom:50%;" /><p>Person是Student的超类，Person是被学习者</p></li><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422145643439.png" alt="image-20200422145643439" style="zoom:50%;" /><ul><li>画图一般把被继承的类放上面，表示高低关系</li><li>上面的：基类、超类、父类</li><li>下面的：派生类、子类</li></ul></li></ul></li><li><p>Scopes and access in C++</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422170734507.png" alt="image-20200422170734507" style="zoom:67%;" /></li></ul><h3 id="子类父类关系">子类父类关系</h3><ul><li><p>Decalre an Employee class</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span><span class="keyword">public</span>:<span class="built_in">Employee</span> ( <span class="keyword">const</span> std::string&amp; name,<span class="keyword">const</span> std::string&amp; ssn ) ;    <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">get_name</span> <span class="params">()</span> <span class="keyword">const</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(std::ostream&amp; out)</span> <span class="keyword">const</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(std::ostream&amp; out，<span class="keyword">const</span> std::string&amp; msg)</span> <span class="keyword">const</span></span>;<span class="keyword">protected</span>:<span class="comment">//偷懒的写法，好处少想很多事情，坏处不知道你的子类会对这两个东西动什么手脚std::string m_name;std::string m_ssn;&#125;;</span></span><br></pre></td></tr></table></figure></li><li><p>Constructor for Employee</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee::<span class="built_in">Employee</span>(<span class="keyword">const</span> string&amp; name,<span class="keyword">const</span> string&amp; ssn ):<span class="built_in">m_name</span>(name)，<span class="built_in">m_ssn</span>(ssn)&#123;<span class="comment">// initializer list sets up the values!已经在initializer list初始化了，函数里不做任何事情&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Employee member functions</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; Employee::get_ <span class="title">name</span> <span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> m_name ;&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Employee::print</span><span class="params">(std::ostream&amp; out )</span> <span class="keyword">const</span></span>&#123;out&lt;&lt;m_name&lt;&lt;endl;out&lt;&lt;m_ssn&lt;&lt;endl;&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Employee::print</span><span class="params">(std::ostream&amp; out, <span class="keyword">const</span> std::string&amp; msg)</span> <span class="keyword">const</span></span>&#123;out &lt;&lt; msg &lt;&lt; endl;<span class="built_in">print</span> (out) ;<span class="comment">//调用了第6行的函数，避免了code duplication代码复制。未来要修改函数只需修改一处就行了。尽量使用已有的代码&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Now add Manager</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> :</span> <span class="keyword">public</span> Employee &#123;<span class="keyword">public</span>:<span class="built_in">Manager</span> (<span class="keyword">const</span> std::string&amp; name,<span class="keyword">const</span> std::string&amp; ssn,<span class="keyword">const</span> std::string&amp; title);<span class="function"><span class="keyword">const</span> std::string <span class="title">title_name</span> <span class="params">()</span> <span class="keyword">const</span></span>;<span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">get_title</span> <span class="params">()</span> <span class="keyword">const</span> </span>;<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(std::ostream&amp; out)</span> <span class="keyword">const</span></span>;<span class="keyword">private</span>:std::string m_title;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Inheritance and constructors</p><ul><li><p>Think of inherited traits as anembedded object</p></li><li><p>Base class is mentioned by class name</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Manager::<span class="built_in">Manager</span> ( <span class="keyword">const</span> string&amp; name， <span class="keyword">const</span> string&amp; ssn，<span class="keyword">const</span> string&amp; title = <span class="string">&quot;&quot;</span> ):<span class="built_in">Employee</span> (name， ssn)，<span class="function">m_ <span class="title">title</span><span class="params">( title )</span>    </span>&#123;    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>More on constructors</p><ul><li>Base class is always constructed first</li><li>If no explicit arguments are passed to base class.<ul><li>Default constructor will be called</li><li>建议2：父类的构造函数，放在初始化列表（顺序是按你声明的顺序，而不是在初始化列表写的顺序。父类最先，然后其他成员变量（成员变量按你声明的顺序））</li></ul></li><li>Destructors are called in exactly the reverse order of the constructors. 先构造的后析构</li></ul></li><li><p>Manager member functions</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Manager::print</span><span class="params">(std::ostream&amp; out)</span> <span class="keyword">const</span></span>&#123;Employee::<span class="built_in">print</span>(out);<span class="comment">// call the base class print     //cout &lt;&lt; m_title &lt;&lt; endl;&#125;inline const std::string&amp; Manager::get_title() const&#123;return m_title;&#125;inline const std::string Manager::title_name() const&#123;return string(m_title+&quot;:&quot;+m_name);//access base m_name&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Uses</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;<span class="function">Employee <span class="title">bob</span><span class="params">( <span class="string">&quot;Bob Jones&quot;</span>, <span class="string">&quot;555-44-0000&quot;</span> )</span> </span>;    <span class="function">Manager <span class="title">bill</span><span class="params">( <span class="string">&quot;Bill Smith&quot;</span>, <span class="string">&quot;666-55-1234&quot;</span>， <span class="string">&quot; Important Person&quot;</span> )</span> </span>;    string name = bill .get_ <span class="built_in">name</span> () ;<span class="comment">// okay Managerinherits Employee         //string title = bob.get_title() ;// Error -- bob is an Employee !cout &lt;&lt; bill.title name () &lt;&lt; &#x27; \n&#x27; &lt;&lt; endl;    bill.print (cout) ;bob.print (cout) ;bob.print (cout, &quot;Employee:&quot;) ;//bill.print (cout, &quot;Employee:&quot;) ;// Error hidden!&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>Name Hidden</p><ul><li><p>只有c++这样：如果父类有overloading的函数，在子类中出现和父类当中重复的函数（相同的名字、参数），那么父类那些就被隐藏掉了，只有子类的</p><p>why？它俩无关系，所以把父类所有overload的都隐藏掉，要不就乱了</p><p>如果想调用父类的，用解析符：：</p></li></ul></li></ul></li></ul><h3 id="函数重载和默认参数">函数重载和默认参数</h3><ul><li><p>函数的返回类型不构成overload的条件</p><ul><li>编译器不知道你要调哪个函数</li></ul></li><li><p>Function overloading</p><ul><li><p>Same functions with different arguments list.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> * str， <span class="keyword">int</span> width)</span></span>; <span class="comment">// #1 .void print(double d，int width) ;//#2void print(long 1，int width); // #3void print(int i，int width); // #4void print(char *str); // #5print( &quot;Pancakes&quot;，15);print(&quot;Syrup&quot;) ;print(1999.0，10);print(1999，12);print(1999L，15);</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Overload and auto-cast（Manager去调//bill.print (cout, “Employee:”) ;// Error hidden!  这个例子）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">short</span> i)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> d)</span></span>;<span class="built_in">f</span>(<span class="string">&#x27;a&#x27;</span>);<span class="built_in">f</span>(<span class="number">2</span>);<span class="built_in">f</span>(<span class="number">2L</span>);<span class="built_in">f</span>(<span class="number">3.2</span>);</span><br></pre></td></tr></table></figure></li><li><p>Default arguments</p><ul><li><p>A default argument is a value given in the declaration that the compiler automatically inserts if you don’t provide a value in the function call.函数声明时预先给一个值（写在.h里，在.cpp不能有）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stash</span>(<span class="keyword">int</span> size， <span class="keyword">int</span> initQuantity = <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>default arguments是编译时刻的事情，编译器看到函数原型声明时看到说后面几个参数有default的值，就补上了那个值</p></li><li><p>To define a function with an argument list, defaults must be added from right to left.从右往左写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">intharpo</span>(<span class="keyword">int</span> n，<span class="keyword">int</span> m=<span class="number">4</span>，intj=<span class="number">5</span>);<span class="function"><span class="keyword">int</span> <span class="title">chico</span><span class="params">(<span class="keyword">int</span> n，<span class="keyword">int</span> m = <span class="number">6</span>，<span class="keyword">int</span> j)</span></span>;<span class="comment">//illeagleintgroucho(int k=1，int m=2，int n=3);beeps = harpo(2);beeps = harpo(1, 8); beeps = harpo(8,7,6);</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>建议：坚决不用default value</p><ul><li>原因：<ul><li>让你少打字的事情，在软件工程上一般不是好事</li><li>阅读困难：传参时你以为这个函数只需要这么点参数</li><li>不安全：可能和设计者意图不同，可以改default value</li></ul></li></ul></li></ul><h3 id="内联函数">内联函数</h3><ul><li><p>Overhead for a function call  调一个函数时有额外开销</p><ul><li><p>the processing time required by a device prior to the execution of a command</p><ul><li>Push parameters            push（传给函数的）实参</li><li>Push return address       push返回地址</li><li>Prepare return values     准备返回的值给寄存器</li><li>Pop all pushed                pop之前push的所有东西</li></ul></li><li><p>Example</p><ul><li><pre><code class="language-c++">int f(int i) &#123;return i*2;&#125;main() &#123;int a=4;int b= f(a);&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  _f_int:add ax,@sp[-8],@sp[-8]ret_main:add sp,#8//stack pointer堆栈指针mov ax,#4mov @sp[-8],axmov ax,@sp[-8]push axcall _f_intmov @sp[-4],axpop ax    //函数参数和本地变量地位一样，都在堆栈里 </span><br></pre></td></tr></table></figure></code></pre></li><li><p>做成inline函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> i*<span class="number">2</span>;&#125;<span class="built_in">main</span>() &#123;<span class="keyword">int</span> a=<span class="number">4</span>;<span class="keyword">int</span> b= <span class="built_in">f</span>(a);&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译之后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">main</span>()&#123;    <span class="keyword">int</span> a=<span class="number">4</span>;    <span class="keyword">int</span> b=a+a<span class="number">&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>汇编之后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_main: add sp,#<span class="number">8</span>mov ax,#<span class="number">4</span>mov @sp[<span class="number">-8</span>],axadd ax, @sp[<span class="number">-8</span>], @sp[<span class="number">-8</span>]mov @sp[<span class="number">-4</span>],ax </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Inline Functions</p><ul><li><p>An inline function is expanded in place, like a preprocessor macro, so the overhead of the function call is eliminated.</p></li><li><p>把函数嵌入调用它的地方，但仍保持函数的独立性</p><p>在最终可执行文件里是没有这个函数的，因为这个函数在编译经过类型检查后嵌入了主函数中</p></li><li><pre><code class="language-c++">inline int plusOne(int x);inline int plusOne(int x) &#123;return ++x; &#125;;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ Repeat **inline** keyword at declaration and definition.</span><br><span class="line"></span><br><span class="line">  + .h:给调用这个函数的地方看的</span><br><span class="line"></span><br><span class="line">    .cpp:用来产生这个函数</span><br><span class="line"></span><br><span class="line">    在.cpp没放Inline，编译器认为这个函数不是Inline，会在可执行文件里留下这个函数，这与头文件原型声明无关</span><br><span class="line"></span><br><span class="line">    .h里的Inline是在调用这个函数的地方时告诉编译器这是个Inline函数，你不能生成调用的代码，而是把代码插进去</span><br><span class="line"></span><br><span class="line">    这样会产生问题：</span><br><span class="line"></span><br><span class="line">    ~~~c++</span><br><span class="line">    //a.hinline void f(int i,int j);//a.cpp#include &quot;a.h&quot;#include &lt;iostream&gt;using namespace std;inline void f(int i,int j)&#123;    cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;&#125;//main.cpp#include &quot;a.h&quot;int main()&#123;    f(10, 10);        return 0;&#125;</span><br></pre></td></tr></table></figure>  g++ main.cpp a.pp后  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kai-MBA:CC wengkai$ g++ main.cpp a. cppa.h:<span class="number">1</span>: warning: <span class="keyword">inline</span> function <span class="string">&#x27;void f(int, int)&#x27;</span> used but never definedUndefined symbols <span class="keyword">for</span> architecture x86_64:<span class="string">&quot;f(int, int)&quot;</span>， referenced from:_main in cc3KiXGJ.old: <span class="built_in">symbol</span>(s) <span class="keyword">not</span> found <span class="keyword">for</span> architecture x86_64collect2: ld returned <span class="number">1</span> exit status</span><br></pre></td></tr></table></figure>  经过预编译处理指令后，看main.ii  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kai-MBA:CC wengkai$ more main.ii#<span class="number">1</span><span class="string">&quot;main. cpp&quot;</span>#<span class="number">1</span><span class="string">&quot;&lt;built- in&gt;&quot;</span>#<span class="number">1</span><span class="string">&quot;&lt;command-line&gt;&quot;</span>#<span class="number">1</span><span class="string">&quot;main. cpp&quot;</span>#<span class="number">1</span><span class="string">&quot;a.h&quot;</span> <span class="number">1</span><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;#<span class="number">2</span><span class="string">&quot;main.cpp&quot;</span> <span class="number">2</span><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="built_in">f</span>(<span class="number">10</span>， <span class="number">10</span>);        <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//因为编译器同时只能看到一个文件，当编译器看main.cpp经过预编译处理指令后的main.ii,编译器知道f（）函数是inline,但不知道长什么样子，因为f（）函数的body不在这个文件里//当在main（）里调用f（）函数时，本来应该不产生调用函数的代码，把f（）函数的代码插入到这里，但现在编译器不知道f（）函数长什么样，那只能放弃把f（）函数作内联，产生对f（）函数的调用//而对于a.cpp，因为有了inline,所以编译器不去产生任何代码（a.o里就不会有关于f（）函数的汇编代码）//那么链接器时候就会出问题，main.cpp说要个f（）,而汇编里没有关于f（）函数的代码，所以就会报f（）函数没有定义的错误</span></span><br></pre></td></tr></table></figure>  解决方案，把函数body放入.h，此时函数声明那一句其实多余了，可以去掉。若此时带上a.cpp进行编译  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kai-MBA: CC wengkai$ g++ main.cpp a. cppa.cpp: In function <span class="string">&#x27;void f(int， int)&#x27;</span>:a.cpp:<span class="number">6</span>: error: redefinition of <span class="string">&#x27;void f(int， int) &#x27;</span>a.h:<span class="number">4</span>: error: <span class="string">&#x27;void f(int, int)&#x27;</span> previously defined here   因为a.cpp<span class="meta">#<span class="meta-keyword">include</span>了a.h    a.cpp里有f（）函数body部分    #<span class="meta-keyword">include</span>的.h里也有f（）函数body部分    所以有重复定义</span></span><br></pre></td></tr></table></figure>  **结论：Inline函数的定义其实是它的声明，不能放.cpp，只放.h就够了**</code></pre></li><li><p>An inline function definition may not generate any code in .obi file.</p></li></ul></li><li><p>Inline functions in header file</p><ul><li>So you can put inline functions’ bodies in header file. Then #include it where the function is needed.</li><li>Never be afraid of multi-definition of inline functions, since they have no body at all.</li><li>Definitions of inline functions are just declarations.     Inline函数的definition就是它的declaration</li></ul></li><li><p>Tradeoff of inline functions</p><ul><li><p>Body of the called function is to be inserted into the caller.     嵌入函数会让空间变大，以空间换时间</p></li><li><p>This may expand the code size</p></li><li><p>but deduces the overhead of calling time.</p></li><li><p>So it gains speed at the expenses of space.</p></li><li><p>In most cases, it is worth.    但大多数情况下，这是值得的。因为空间不是很大的问题</p></li><li><p>It is much better than macro in C. It checks the types of the parameters.比C的宏好，因为inline函数是函数，可以做类型检查</p><ul><li><p>Example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(a) (a)+(a)main() &#123;double a=4;printf(<span class="meta-string">&quot;%d&quot;</span>,f(a) );&#125;<span class="comment">//直接替换，输出结果错误-----------------------------------------------------------------inline int f(int i) &#123;return i*2;&#125;main() &#123;double a=4;printf(&quot;%d&quot; ,f(a) );&#125;//编译时会做类型检查，会报错</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Inline may not in-line</p><ul><li>The compiler does not have to honor your request to make a function inline. It might decide the function is too large or notice that it calls itself (recursion is not allowed or indeed possible for inline functions)（堆栈不可能做成inline，因为堆栈就要不断地进栈出栈）, or the feature might not be implemented for your particular compiler.</li></ul></li><li><p>Inline inside classes</p><ul><li>Any function you define inside a class declaration is automatically an inline.</li><li>在类的声明时候给出成员函数的body，那些函数通通是inline</li></ul></li><li><p>Access functions</p><ul><li><p>They are small functions that allow you to read or change part of the state of an object - that is, an internal variable or variables.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cup</span> &#123;</span><span class="keyword">int</span> color;<span class="keyword">public</span>:<span class="function"><span class="keyword">int</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> color; &#125;<span class="function"><span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;    <span class="keyword">this</span>-&gt;color =color;&#125;<span class="comment">//做成内联，好处是，调用这个函数和直接访问这个成员变量运行效率上没差别&#125;;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Reducing clutter</p><ul><li><p>Member functions defined within classes use the Latin in <em>situ</em> (in place) and maintains that all definitions should be placed outside the class to keep the interface clean.</p></li><li><p>Example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span><span class="keyword">int</span> width, height;<span class="keyword">public</span>:    <span class="built_in">Rectangle</span>(<span class="keyword">int</span> W = <span class="number">0</span>，<span class="keyword">int</span> h = <span class="number">0</span>);    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">( )</span> <span class="keyword">const</span></span>;    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span>;    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> <span class="keyword">const</span> </span>;    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span>;&#125;;<span class="comment">//类里可以加inline前缀，但没必要inline Rectangle: :Rectangle(int W，int h): width(w)， height(h) &#123;&#125;inline int Rectangle: :getWidth() const &#123;return width;&#125;//这样可以保持类的清爽</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Inline or not?</p><ul><li>Inline:<ul><li>Small functions,2 or 3 lines</li><li>Frequently called functions,eg.inside loops   频繁调用的函数，比如循环，值得做成inline</li></ul></li><li>Not inline?<ul><li>Very large functions,more than 20 lines</li><li>Recursive functions  递归</li></ul></li></ul></li></ul><h3 id="const">const</h3><ul><li><p>Const</p><ul><li><p>decalres a variable to have a constant value   变量被初始化后不能再被赋值（修改）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">123</span>;x = <span class="number">27</span>; <span class="comment">// illegal!x++; // illegal!int y = x; // 0k， copy const to non-consty = x;      // 0k，same thingconst int z = y; // ok，const is safer  初始化，ok的</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Constants</p><ul><li>Constants are variables     加了const仍然是变量(变量要在内存中分配地址，而常量是编译时记在内存表的一项）<ul><li>Observe scoping rules   遵循本地变量的规则（进函数存在，离开函数不存在）</li><li>Declared with “const” type modifier</li></ul></li></ul></li><li><p>Compile time constants</p><ul><li><pre><code class="language-c++">const int busize = 1024;//在编译前就要明确地知道const的变量的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + value must be initialized</span><br><span class="line">  + unless you make an explicit extern declaration:   可以不知道，用extern</span><br><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  extern const int bufsize;//这是一句声明</span><br></pre></td></tr></table></figure>+ 编译器保证编译时刻不会去修改const，这和你真正是不是const两回事+ Compiler won't let you change it+ Compile time constants are entries in compiler symbol table, not really variables.</code></pre></li></ul></li><li><p>Run-time constants</p><ul><li><p>const value can be exploited</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> class_ size = <span class="number">12</span>;<span class="keyword">int</span> finalGrade[class_size]; <span class="comment">// ok   编译时刻知道const的值，可以做数组大小int x;cin &gt;&gt; x;const int size = x;double classAverage[size]; // error!   因为编译前不知道size是多少//因为编译时需要知道这个有多大，好给你分配空间（堆栈的大小）</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Pointers and const</p><ul><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422151945420.png" alt="image-20200422151945420" style="zoom:50%;" /></li><li><pre><code class="language-c++">char * const q = &quot;abc&quot;; // q is const   *q='c'; // 0Kq++;    // ERROR     指针是const，这个指针不能再指向别人const char *p =&quot;ABCD&quot;;// (*p) is a const char*p = 'b'; // ERROR! (*p) is the const     你不能通过这个p指针来修改p指针所指向的内存单元，而不是我指向哪，哪就是constp++; // 0K<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Quiz:What do these mean?</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  Person p1( &quot;Fred&quot;，200 );const Person* p = &amp;p1;//被指针指向的对象p1是const，即我不能通过这个指针去修改p1的值Person const* p = &amp;p1;//对象是constPerson *const p = &amp;p1;//指针是const//区分的标志：const写*前对象是  const写*后指针是const Person const* p=&amp;p1;指针和对象都是</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>Pointers and constants</p><ul><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423183727983.png" alt="image-20200423183727983" style="zoom:67%;" /></li><li><p>红色那行，error，因为in* ip不是const，它表明你可以通过*ip来修改值，与ci是const违背</p></li><li><p>Remember</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*ip  = <span class="number">54</span>; <span class="comment">// always legal since ip points to int*cip = 54; // never legal since cip points to const int</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>String Literals</p><ul><li><pre><code class="language-c++">char* s = &quot;Hello,world!&quot;;//把&quot;Hello,world!&quot;在代码段的地址交给指针s<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + s is a pointer initialized to point to a string constant</span><br><span class="line">  + This is actually a const char* s but compiler accepts it without the const</span><br><span class="line">  + Don&#x27;t try and change the character values (it is undefined behavior)</span><br><span class="line"></span><br><span class="line">+ If you want to change the string, put it in an array:</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  char s[] = &quot;Hello, world!&quot;;//这个数组在堆栈里。这一行将hello world一个一个拷贝给数组</span><br></pre></td></tr></table></figure></code></pre></li><li><p>内存分三部分：</p><ul><li><p>本地变量放堆栈</p></li><li><p>new的放堆，有且仅有new的放</p></li><li><p>全局变量（静态本地变量、静态成员变量）放全局数据区，全局变量里的常量在代码段（代码段是不可写的）里</p></li><li><pre><code class="language-c++">#include &lt;stdio.h&gt;int main( )&#123;    const char *S1 = &quot;hello world&quot;;    char s2[] = &quot;hello world&quot;;        printf(&quot;s1   =%p\n&quot;， s1);    printf(&quot;s2   =%p\n&quot;， s2);    printf(&quot;main =%p\n&quot;， main);        return 0;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 运行结果</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    Kai-MBA:CC wengkai$ ./a. outs1  =0x19f3a      //在内存很前面，代码段。和s3很近s2  =0xbffe7c48   //在堆栈main=0x19e40</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>Conversions</p><ul><li><p>Can always treat a non-const value as const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* x)</span> </span>;<span class="comment">//你虽然传地址给我，但我保证不通过指针改你的值，编译器作保证，它会检查我的行为int a=15;f(&amp;a) ; // okconst int b = a;f(&amp;b) ; // okb = a + 1;// Error !</span></span><br></pre></td></tr></table></figure><p>You cannot treat a constant object as non-constant without an explicit cast (const_cast)</p></li></ul></li><li><p>Passing by const value？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123;i++; <span class="comment">// Illegal -- compile-time error&#125;//对于调用f1的人无所谓，你传的不是地址，f（）里面怎么动，都不会改变你传进来的参数的值//这里只是说f（）函数里不能改形参i</span></span><br></pre></td></tr></table></figure></li><li><p>Returning by const value?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;<span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">f4</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="keyword">const</span> <span class="keyword">int</span> j = <span class="built_in">f3</span>() ; <span class="comment">// Works fineint k = f4() ; // But this works fine too!&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Passing and returning addresses</p><ul><li>Passing a whole object may cost you a <a href="http://lot.It">lot.It</a> is better to pass by a pointer.But it’s possible for the programmer to take it and modify the original value.</li><li>In fact, whenever you’re passing an address into a function, you should make it a const if at all possible.</li><li>直接传对象进出堆栈开销大，传地址就好，但怕修改，所以以const的方式做保证</li></ul></li></ul><h3 id="不可修改的对象">不可修改的对象</h3><ul><li><p>Constant objects   类的对象const</p><ul><li><p>What if an object is const?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Currency <span class="title">the_raise</span> <span class="params">(<span class="number">42</span>,<span class="number">38</span>)</span></span>;<span class="comment">//说明这个对象里的值不能被修改</span></span><br></pre></td></tr></table></figure></li><li><p>What members can access the internals?</p></li><li><p>How can the object be protected from change?</p><ul><li><p>那这个类的成员函数可能会动成员变量，怎么晓得会不会动成员变量？</p><p>我们可以看源码，但编译器干不了（编译单元），.h是原型，.cpp是body</p><p>解决方法：在函数后加const，说这个函数不修改任何成员变量</p></li></ul></li></ul></li><li><p>Const member functions</p><ul><li><p>Cannot modify their objects</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Date::set_day</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;<span class="comment">//...error check d here...day = d;// ok, non-const so can modify&#125;int Date::get_day() const &#123;day++;//ERROR modifies data memberset day(12) ; // ERROR calls non-const memberreturn day;// ok&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Const member function usage</p><ul><li><p>Repeat the const keyword in the definition as well as the declaration  声明和定义都要加const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_day</span> <span class="params">()</span> <span class="keyword">const</span></span>;<span class="function"><span class="keyword">int</span> <span class="title">get_day</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> day &#125; ;<span class="comment">//其实这里的const说的是this</span></span><br></pre></td></tr></table></figure></li><li><p>Function members that do not modify data should be declared const</p></li><li><p>const member functions are safe for const objects</p></li><li><p>其实这里的const说的是this</p><ul><li><pre><code class="language-c++">#include &lt;iostream&gt;using namespace std;class A &#123;int i;public:A() : i(0) &#123;&#125;void f() &#123; cout &lt;&lt; &quot;f()&quot; &lt;&lt; endl; &#125;  //完整版是void f(A* this) &#123; cout &lt;&lt; &quot;f()&quot; &lt;&lt; endl; &#125;void f() const &#123; cout &lt;&lt; &quot;f() const&quot; &lt;&lt; endl; &#125;  //完整版是void f(const A* this) const &#123; cout &lt;&lt; &quot;f() const&quot; &lt;&lt; endl; &#125;    //这两个函数参数表不同，构成了overload&#125;;int main( )&#123;    const A a;a.f();    return 0;&#125;-----------------------------------------------------------------------    //运行结果：f() const<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Constants in class  成员变量是const，必须在initializer list初始化</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  class A&#123;    const int i;&#125;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>has to be initialized in initializer list of the constructor</p></li></ul></li><li><p>Compile-time constants in classes</p><ul><li><pre><code class="language-c++">class HasArray &#123;const int size;int array[size]; // ERROR!    ...&#125;;//成员变量是const，不能做数组size<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ Make the const value static:     想让它可以的话，前面再加个static</span><br><span class="line"></span><br><span class="line">  + static const int size=100;</span><br><span class="line">  + static indicates only one per class(not one per object)</span><br><span class="line"></span><br><span class="line">+ Or use&quot;anonymous enum&quot; hack  或者用枚举</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    class HasArray &#123;enum&#123;size=100&#125;;//size同样是一个常数、int类型、不能被改变，但能作数组sizeint array[size] ; // OK!    ...&#125;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="引用">引用</h3><ul><li><p>c++内存模型复杂在：三种放对象的地方（堆、堆栈、全局数据区）×三种访问的方式（变量、指针、引用）</p></li><li><p>Declaring references</p><ul><li><p>References are a new data type in C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;<span class="comment">// a characterchar* p = &amp;c; // a pointer to a characterchar&amp; r = c;// a reference to a character  //别名，一个东西的两个名字</span></span><br></pre></td></tr></table></figure></li><li><p>Local or global variables</p><ul><li>type&amp; refname = name;</li><li>For ordinary variables,the initial value is required   本地或全局变量引用都需要初始化。初始值必须是一个变量或者可以作左值的东西</li></ul></li><li><p>In parameter lists参数表 and member variables成员变量</p><ul><li>type&amp; refname</li><li>Binding绑定 defined by caller or constructor  参数是调用函数的时候给值，成员变量是构造对象时候初始化</li></ul></li></ul></li><li><p>References</p><ul><li><p>Declares a new name for an existing object</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> X=<span class="number">47</span>;<span class="keyword">int</span>&amp; Y=X;<span class="comment">//Y is a reference to X.Y是X的别名// X and Y now refer to the same variablecout &lt;&lt; &quot;Y =&quot; &lt;&lt; y; //prints Y = 47Y=18;    //把18赋给Y绑着的Xcout&lt;&lt;&quot;X=&quot;&lt;&lt;X; // prints X = 18</span></span><br></pre></td></tr></table></figure></li><li><p>对references两种理解，别名、赋值</p></li></ul></li><li><p>Rules of references</p><ul><li><p>References must be initialized when defined</p></li><li><p>Initialization establishes a binding</p><ul><li><p>In declaration</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intx= <span class="number">3</span>;<span class="keyword">int</span>&amp;y= x;<span class="keyword">const</span> <span class="keyword">int</span>&amp; z = x;<span class="comment">//z是x的别名，但不能通过z修改x//其实和指针一回事const int* z = x;//不能通过指针z修改x的值</span></span><br></pre></td></tr></table></figure></li><li><p>As a function argument</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span>&amp; x)</span></span>;<span class="comment">//在f（）里其实x就是外面那个y，如果函数f（）里对x进行修改，外面y就被修改了f(y); // initialized when function is called</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Bindings don’t change at run time, unlike pointers</p></li><li><p>Assignment changes the object referred-to</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; y=x;y=<span class="number">12</span>;<span class="comment">//Changes value of x</span></span><br></pre></td></tr></table></figure></li><li><p>The target of a reference must have a location!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; )</span> </span>;<span class="built_in">func</span>(i*<span class="number">3</span>);<span class="comment">// Warning or error!    i*3有结果，是一个临时变量在放着他，但没有一个有名字的变量放着它，所以不能传给引用</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>&amp;其实是const的指针（这个指针不能再指向其他的地址），为了让代码少点*</p><p>JAVA对象只能放堆，并且只能通过指针访问，因为只有这一种方式，所以去掉所有*，然后叫它引用，但它实际更像c++的指针，因为c++的引用之间不能赋值</p><p>相比于c的指针Java的指针少了*，而且不能做计算（p++，p–，俩指针之间做计算）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">f</span><span class="params">(<span class="keyword">int</span>* x)</span> </span>&#123;(*x)++;<span class="keyword">return</span> x; <span class="comment">// Safe， x is outside this scope&#125;int&amp; g(int&amp; x) &#123;x++; // Same effect as in f()return x; // Safe, outside this scope&#125;/*int g(int x)&#123;    &#125;*/reference不构成overloadint x;int&amp; h() &#123;int q;//!  return q;  // Errorreturn x; // Safe， X lives outside this scope&#125;int main() &#123;int a=0;f(&amp;a); // Ugly (but explicit显而易见)g(a); // Clean (but hidden)h() = 16;//一个函数的返回结果是references，就可以做左值    //实际做的事是让x变成引用返回来，让那个引用=16，最终是让x=16    *k()=10;&#125; ///:</span></span><br></pre></td></tr></table></figure></li><li><p>Pointers vs. References</p><ul><li>References<ul><li>can’t be null</li><li>are dependent on an existing variable,they are an alias别名 for an variable</li><li>can’t change to a new “address” location</li></ul></li><li>Pointers<ul><li>can be set to null</li><li>pointer is independent of existing objects</li><li>can change to point to a different address</li></ul></li></ul></li><li><p>Restrictions</p><ul><li><p>No regerences to references</p></li><li><p>No pointers to references</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;* p;<span class="comment">//illegal//如果*p的类型是references，说明你可以取到references的地址，但references的地址是不让你取到的</span></span><br></pre></td></tr></table></figure></li><li><p>Reference to pointer is ok<br>void f(int*&amp; p);<br>//p是references，它所捆的变量是一个int类型的指针</p><p>//离变量近的决定它是什么</p></li><li><p>No arrays of references   引用不是实体，所以没有数组</p></li></ul></li></ul><h3 id="向上造型">向上造型</h3><ul><li><p>Conversions</p><ul><li><p>Public Inheritance should imply substitution</p><ul><li><p>If B is a A,you can use a B anywhere an A can be used.</p><ul><li>if B is a A,then everything that is true for A is also true of B</li></ul></li><li><p>Be careful if the substitution is not valid!</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423223047267.png" alt="image-20200423223047267" style="zoom:50%;" /><p>一个D的对象可以交给B的对象</p><p>一个D的指针可以交给B的指针</p><p>一个D的引用可以交给B的引用</p></li><li><p>因为从内容来说，子类的对象具有父类所有的东西，多的当不存在就好了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std;class A&#123;public:    int i;    public:    A():i(10)&#123;&#125;&#125;;class B:public A&#123;private:    int j;public:    B():j(30) &#123;&#125;    void f()&#123; cout &lt;&lt; <span class="meta-string">&quot;B.j&quot;</span> &lt;&lt; j &lt;&lt; endl; &#125;&#125;;int main()&#123;    A a;    B b;        cout &lt;&lt; a.i &lt;&lt;<span class="meta-string">&quot; &quot;</span> &lt;&lt; b.i &lt;&lt;endl;        cout &lt;&lt; sizeof(a) &lt;&lt; <span class="meta-string">&quot; &quot;</span> &lt;&lt; sizeof(b) &lt;&lt; endl;        int *p =(int*)&amp;a;<span class="comment">//把a的地址当成int类型指针交给*p    cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt;endl;    *p = 20;    cout &lt;&lt; a.i &lt;&lt;endl;        p = (int*)&amp;b;    cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt;endl;    p++;    *p = 50;    b.f();        return 0;&#125;-----------------------------------------------------------------------------------运行结果：-----------------------------------------------------------------------------------Kai-MBA:CC wengkai$ ./a. out10 104 80x7fff5609cbf0 10200x7fff5609cbe8 10B.j=50</span></span></span><br></pre></td></tr></table></figure><ul><li>子类增加的部分在后面<ul><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423225120569.png" alt="image-20200423225120569" style="zoom:67%;" /></li></ul></li></ul></li></ul></li></ul></li><li><p>Upcasting   把子类当父类看,UP是因为画图时候把子类画在下面，向上UP当父类看</p><ul><li><p>Upcasting is the act of converting from a Derived reference or pointer to a base class reference or pointer.</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200422154817924.png" alt="image-20200422154817924" style="zoom:50%;" /></li><li><p>cast造型，只是看待的眼光变了。而类型转换，丧失原来的数据类型</p></li></ul></li><li><p>Upcasting examples</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Manager <span class="title">pete</span><span class="params">( <span class="string">&quot;Pete&quot;</span>, <span class="string">&quot;444-55-6666&quot;</span>, <span class="string">&quot;Bakery&quot;</span>)</span></span>;Employee* ep = &amp;pete; <span class="comment">// UpcastEmployee&amp; er = pete;  // Upcast</span></span><br></pre></td></tr></table></figure><ul><li><p>Lose type information about the object:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ep-&gt;<span class="built_in">print</span>( cout ); <span class="comment">// prints base class version</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="多态性">多态性</h3><ul><li><p>A drawing program</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423193526026.png" alt="image-20200423193526026" style="zoom:50%;" /></li><li><p>Inheritance in C++</p><ul><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423194358065.png" alt="image-20200423194358065" style="zoom:67%;" /></li><li>Can define one class in terms of another</li><li>Can capture the notion that<ul><li>An ellipse is a shape</li><li>A circle is a special kind of ellipse</li><li>A rectangle is a different shape</li><li>Circles,ellipses,and rectangles share common<ul><li>attributes</li><li>services</li></ul></li><li>Circles, ellipses, and rectangles are not identical</li></ul></li></ul></li><li><p>Conceptual model</p><ul><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423194443465.png" alt="image-20200423194443465" style="zoom:67%;" /></li></ul></li><li><p>Shape</p><ul><li><p>Define the general properties of a Shape</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XYPos</span> &#123;</span>...&#125;;  <span class="comment">// x,y pointclass Shape &#123;public:    Shape () ;    virtual ~Shape () ;    virtual void render () ;//将来shape的所有子类里，如果重新写了render，名称一样，参数也相同。那么这个render和子类的render有联系    void move (const XYPos&amp;) ;    virtual void resize () ;protected :XYPos center ;&#125;;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Add new shapes</p><ul><li><pre><code class="language-c++">class Ellipse : public Shape &#123;public:    Ellipse (float maj, float minr) ;    virtual void render() ; // will define own   继承树中某个祖先加了virtual，子子孙孙都是virtual//在子孙中加上去是好习惯protected:float major_axis, minor_axis;&#125;;class Circle : public Ellipse &#123;public:Circle (float radius) : Ellipse (radius, radius) &#123; &#125;    virtual void render() ;&#125;;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ Example</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    void render (Shape* p) //这个函数对Shape的子类是通用的&#123;p-&gt;render(); // calls correct render function&#125;// for given Shape !//这里p是多态的，有的地方叫多态对象，P指哪个类型，就变成谁的形态，做那个类型的动作//另外的角度，p的静态类型是Shape的指针。动态类型是p当时指的对象的类型//如果这个函数是virtual的，就要看它的动态类型；如果不是，就是静态绑定void func() &#123;    Ellipse ell(10，20) ;    ell. render () ;    Circle circ(40) ;    circ. render () ;        render (&amp;ell) ;//把ell的地址传给Shape* p，把子类Ellipse的对象当作Shape来看待，发生了向上造型    //调用Ellipse的render（）    render (&amp;circ) ;//circle的render（）被调用&#125;//virtual的函数告诉编译器，如果对这个函数的调用是通过指针或引用的话，你就要到运行的时候看指针所指的对象是什么类型，再调用那个类型的函数</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>Polymorphism  多态性    建立在Upcast和动态绑定的基础上</p><ul><li>Upcast: take an object of the derived class as an object of the base one.<ul><li>Ellipse can be treated as a Shape</li></ul></li><li>Dynamic binding:   动态绑定<ul><li>Binding:which function to be called<ul><li>Static binding: call the function as the code   编译时确定</li><li>Dynamic binding: call the function of the object   运行时确定</li></ul></li></ul></li></ul></li></ul><h3 id="多态的实现">多态的实现</h3><ul><li><p>任何一个类只要有虚函数，这个类的对象就会比正常的大一点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std; class A&#123;public:A() : i(10) &#123;&#125;virtual void f() &#123; cout &lt;&lt; <span class="meta-string">&quot;A::f()&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;    int i;&#125;;int main( )&#123;A a;a.f() ;cout &lt;&lt; sizeof(a) &lt;&lt; endl;    int *p = (int*)&amp;a;    cout &lt;&lt; *p &lt;&lt; endl;     return 0;&#125;---------------------------------------------------------------------------------------------运行结果：---------------------------------------------------------------------------------------------Kai-MBA:CC wengkai$ g++ a.cpp -m32Kai-MBA:CC wengkai$ ./a.outA::f()108835680---------------------------------------------------------------------------------------------    <span class="comment">//17~18行加一行 p++;---------------------------------------------------------------------------------------------Kai-MBA:CC wengkai$ g++ a.cpp -m32Kai-MBA:CC wengkai$ ./a.outA::f()10810---------------------------------------------------------------------------------------------   对象里面是：隐藏的vptr（指针，指向一张表vtable（vtable里是所有virtual函数的地址）），然后是成员变量  </span></span></span><br></pre></td></tr></table></figure><ul><li><p>这张virtual不是对象的，是类的（检验方法：同一个类下不同对象的vtable地址是一样的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std; class A&#123;public:A() : i(10) &#123;&#125;virtual void f() &#123; cout &lt;&lt; <span class="meta-string">&quot;A::f()&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;    int i;&#125;;int main( )&#123;A a，b;a.f() ;cout &lt;&lt; sizeof(a) &lt;&lt; endl;    int *p = (int*)&amp;a;     int *q = (int*)&amp;b;        cout &lt;&lt; *p &lt;&lt; endl&lt;&lt;*q&lt;&lt;endl;     return 0;&#125;-----------------------------------------------------------------------------------------运行结果：-----------------------------------------------------------------------------------------Kai-MBA:CC wengkai$ ./a. outA::f()108725088725088</span></span><br></pre></td></tr></table></figure><ul><li><p>vtable里面第一项是什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std; class A&#123;public:A() : i(10) &#123;&#125;virtual void f() &#123; cout &lt;&lt; <span class="meta-string">&quot;A::f()&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;    int i;&#125;;int main( )&#123;A a，b;a.f() ;cout &lt;&lt; sizeof(a) &lt;&lt; endl;    int *p = (int*)&amp;a;     int *q = (int*)&amp;b;        int *x = (int*)*p;<span class="comment">//把*p的值在当作指针，二级指针，看看vtable里面第一项的值是什么    cout &lt;&lt; x &lt;&lt; endl;        cout &lt;&lt; *p &lt;&lt; endl&lt;&lt;*q&lt;&lt;endl;     return 0;&#125;--------------------------------------------------------------------------------------运行结果：--------------------------------------------------------------------------------------Kai-MBA:CC wengkai$ . /a. outA: :f()1080x2f068192616192616</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>How virtuals work in C++</p><ul><li><pre><code class="language-c++">class Shape &#123;public:    Shape () ;    virtual ~Shape () ;    virtual void render() ;    void move (const XYPos&amp;) ;    virtual void resize() ;protected:XYPos center;&#125;;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + &lt;img src=&quot;/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423201229022.png&quot; alt=&quot;image-20200423201229022&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">+ Ellipse</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    class Ellipse :public Shape&#123;public:Ellipse (float majr,float minr) ;virtual void render () ;protected:float major_ axis;float minor_ axis;&#125;;</span><br></pre></td></tr></table></figure></code></pre></li><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423201401951.png" alt="image-20200423201401951" style="zoom:67%;" /></li><li><p>Ellipse的对象里面，自己新增的成员变量部分在后面。</p><p>Ellipse也有自己的vtable（检验方法：Ellipse的vtable地址和父类Shape的不一样）</p><p>Ellipse的vtable的结构和父类一样（第一是dtor(),然后render(),然后resize() ），但dtor（）和render（）是自己写的</p></li></ul></li><li><p>Shape vs Ellipse</p><ul><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423201500704.png" alt="image-20200423201500704" style="zoom:67%;" /></li><li>动态绑定实现原理：p-&gt;render()，把p所指对象的第一个地址取出来，从这个地址访问到vtable，从vtable+2访问到render（）的地址，然后调用这个地址上的render（）函数</li><li>不用在运行时知道对象的类型是什么，只是顺着这条线找到render（），这其实很快</li></ul></li><li><p>Circle</p><ul><li><pre><code class="language-c++">class Circle:public Ellipse&#123;public:Circle (float radius) ;virtual void render() ;virtual void resize() ;virtual float radius () ;protected:float area;&#125;;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + &lt;img src=&quot;/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200423201800385.png&quot; alt=&quot;image-20200423201800385&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ What happens if</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  Ellipse elly (20F, 40F) ;Circle circ (60F) ;elly = circ;// 10 in 5?  vptr不参与赋值传递</span><br></pre></td></tr></table></figure></code></pre></li><li><p>Area of circ is sliced off</p><ul><li>一(Only the part of circ that fits in elly gets copied)</li></ul></li><li><p>Vtable from circ is ignored; the vtable in elly is the Ellipse vtable</p><ul><li><pre><code class="language-c++">elly.render() ; // Ellipse::render ()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  #include &lt;iostream&gt;using namespace std;class A &#123;public:A() : i(10) &#123;&#125;virtual void f() &#123; cout &lt;&lt; &quot;A::f()&quot; &lt;&lt; i &lt;&lt; endl; &#125;    int i;&#125;;class B: public A &#123;public:B() : j(20) &#123;&#125;virtual void f() &#123; cout &lt;&lt; &quot;B::f()&quot; &lt;&lt; j &lt;&lt; endl; &#125;    int j;&#125;;int main( )&#123;    A a;    B b;        A* p = &amp;b;        p-&gt;f();        return 0；&#125;-----------------------------------------------------------------------------------------运行结果：-----------------------------------------------------------------------------------------Kai-MBA:CC weng kai$ . /a.outB::f( )20 ========================================================================================= #include &lt;iostream&gt;using namespace std;class A &#123;public:A() : i(10) &#123;&#125;virtual void f() &#123; cout &lt;&lt; &quot;A::f()&quot; &lt;&lt; i &lt;&lt; endl; &#125;    int i;&#125;;class B: public A &#123;public:B() : j(20) &#123;&#125;virtual void f() &#123; cout &lt;&lt; &quot;B::f()&quot; &lt;&lt; j &lt;&lt; endl; &#125;    int j;&#125;;int main( )&#123;    A a;    B b;        A* p = &amp;b;    p-&gt;f();        a = b;//只是把b的成员变量赋给了a，vptr不参与赋值        a.f();        return 0；&#125;----------------------------------------------------------------------------------------运行结果：----------------------------------------------------------------------------------------Kai-MBA:CC weng kai$ . /a.outB::f()20A::f( )10========================================================================================#include &lt;iostream&gt;using namespace std;class A &#123;public:A() : i(10) &#123;&#125;virtual void f() &#123; cout &lt;&lt; &quot;A::f()&quot; &lt;&lt; i &lt;&lt; endl; &#125;    int i;&#125;;class B: public A &#123;public:B() : j(20) &#123;&#125;virtual void f() &#123; cout &lt;&lt; &quot;B::f()&quot; &lt;&lt; j &lt;&lt; endl; &#125;    int j;&#125;;int main( )&#123;    A a;    B b;        A* p = &amp;b;    p-&gt;f();        a = b;//把b的成员变量赋给了a，vptr不参与赋值        p = &amp;a;    p-&gt;f();        return 0；&#125;----------------------------------------------------------------------------------------运行结果：----------------------------------------------------------------------------------------Kai-MBA:CC weng kai$ . /a.outB::f()20A::f( )10========================================================================================#include &lt;iostream&gt;using namespace std;class A &#123;public:A() : i(10) &#123;&#125;virtual void f() &#123; cout &lt;&lt; &quot;A::f()&quot; &lt;&lt; i &lt;&lt; endl; &#125;    int i;&#125;;class B: public A &#123;public:B() : j(20) &#123;&#125;virtual void f() &#123; cout &lt;&lt; &quot;B::f()&quot; &lt;&lt; j &lt;&lt; endl; &#125;    int j;&#125;;int main( )&#123;    A a;    B b;        A* p = &amp;a;    int* r = (int*)&amp;a;    int* t = (int*)&amp;b;    *r = *t;                  //把a的vptr指向的vtable改成指向b的vtable       p-&gt;f();//f()去找j，把对象a里成员变量i的下一块地址当成j，于是结果是32767    return 0；&#125;----------------------------------------------------------------------------------------运行结果：----------------------------------------------------------------------------------------Kai-MBA:CC wengkai$ ./a.outB::f()32767</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200424153049193.png" alt="image-20200424153049193" style="zoom:50%;" /></li></ul></li><li><p>What happens with pointers?</p><ul><li><pre><code class="language-c++">Ellipse* elly = new Ellipse (20F，40F) ;Circle* circ = new Circle (60F) ;elly = circ;//两个对象没变，只是指针指过去<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ Well, the original Ellipse for elly is lost....</span><br><span class="line"></span><br><span class="line">+ elly and circ point to the same Circle object!</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    elly-&gt;render() ; // Circle::render ()</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>Virtuals and reference arguments</p><ul><li><pre><code class="language-c++">void func (Ellipse&amp; elly)&#123;elly.render () ;&#125;Circle circ (60F) ;func (circ) ;//circ::render()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + References act like pointers</span><br><span class="line"></span><br><span class="line">  + Circle::render() is called</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Virtual destructors</span><br><span class="line"></span><br><span class="line">  + Make destructors virtual if they might be inherited</span><br><span class="line"></span><br><span class="line">    ~~~c++</span><br><span class="line">    Shape *p = new Ellipse (100.0F，200.0F) ;...delete P;//如果这里Shape的析构不是virtual，这里的绑定是静态绑定，delete p时调用Shape的析构函数，子类Ellipse的析构函数丢掉了，没有被调用//如果是virtual的，delete p会根据对象的类型调用相应的析构函数//如果一个类有virtual函数，则必须声明析构函数是virtual//给以后程序修改，软件重用留口子//c++默认静态绑定，为了效率，因为静态比动态快//其它语言追求OOP语义，默认动态绑定</span><br></pre></td></tr></table></figure></code></pre></li><li><p>Want Ellipse: :~Ellipse() to be called</p><ul><li>Must declare Shape: :~Shape () virtual</li><li>It will call Shape: : ~Shape () automatically</li></ul></li><li><p>If Shape: : ~ Shape () is not virtual, only Shape: : ~Shape () will be invoked!</p></li></ul></li><li><p>Overriding</p><ul><li><p>Overriding redefines the body of a virtual function</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;<span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>;<span class="comment">//overrides Base::func()&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Calls up the chain</p><ul><li><p>You can still call the overridden function:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">voidDerived: : <span class="built_in">func</span>() &#123;cout &lt;&lt; <span class="string">&quot;In Derived: : func!&quot;</span>;Base: : <span class="built_in">func</span>() ; <span class="comment">// call to base class &#125;//在overriding里想调父类的func加：</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p>This is a common way to add new functionality</p><ul><li>No need to copy the old stuff !</li></ul></li><li><p>Return types relaxation(current)</p><ul><li>Suppose D is publicly derived from B</li><li>D::f()can return a subclass of the return type defined in B::f()</li><li>Applies to pointer and reference types<ul><li>eg.  D&amp;,  D*</li></ul></li></ul></li><li><p>Relaxation example</p><ul><li><pre><code class="language-c++">class Expr &#123;public:    virtual Expr* newExpr () ;//父类函数返回父类对象的指针    virtual Expr&amp; clone () ;//父类函数返回父类对象的引用    virtual Expr self() ;//父类函数返回父类对象自己&#125;;class BinaryExpr : public Expr &#123;            //子类overriding了public:virtual BinaryExpr* newExpr() ;// Okvirtual BinaryExpr&amp; clone() ;//Okvirtual BinaryExpr self() ; // Error !&#125;;//因为只有通过指针或引用才构成upcast的关系，才能发生Polymorphism<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Overloading and virtuals</span><br><span class="line"></span><br><span class="line">  + Overloading adds multiple signatures</span><br><span class="line"></span><br><span class="line">    + ~~~c++</span><br><span class="line">      Class Basepublic:virtual void func() ;virtual void func (int) ;&#125;;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>If you override an overloaded function, you must override all of the variants!</p><ul><li><p>Can't override just one</p></li><li><p>If you don't override all, some will be hidden</p></li><li><p>如果一个类里有重载的两个虚函数</p><p>子类必须也要写这两个，如果只写一个，那么父类另一个会被屏蔽（name hidden）</p></li></ul></li></ul></li></ul><h3 id="引用再研究">引用再研究</h3><ul><li><p>References as class members</p><ul><li><p>Declared without initial value</p></li><li><p>Must be initialized using constructor initializer list</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span><span class="keyword">public</span>:<span class="keyword">int</span>&amp; m_y;<span class="built_in">X</span>(<span class="keyword">int</span>&amp; a) ;&#125;;X::<span class="built_in">X</span>(<span class="keyword">int</span>&amp; a) : <span class="built_in">m_y</span>(a) &#123; &#125;<span class="comment">//成员变量是引用，必须用这样的代码去初始化</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Returning references</p><ul><li><p>Functions can return references<br>-But they better refer to non-local variables!函数类型可以返回引用（和返回指针一样），但不能返回函数里本地变量的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span>const int SIZE = 32;double myarray[SIZE] ;double&amp; subscript (const int i) &#123;return myarray [i] ;<span class="comment">//函数返回&amp;，return这里一定是个变量。这个变量的生存周期要比这个函数长&#125;</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Example</p><ul><li><pre><code class="language-c++">main () &#123;for(int i=0 ;i &lt; SIZE ;i++)&#123;myarray[i] = i*0.5;&#125;double value = subscript (12) ;//把myarray[12]的值赋给了value    subscript (3) = 34.5;    //其实是myarray[3]=34.5;    //一个函数返回&amp;，这个函数就可以做左值&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ const in Functions Arguments</span><br><span class="line"></span><br><span class="line">  + Pass by const value -- don&#x27;t do it</span><br><span class="line"></span><br><span class="line">  + Passing by const reference</span><br><span class="line"></span><br><span class="line">    ~~~c++</span><br><span class="line">    Person( const string&amp; name, int weight );//传一个对象进函数，常用const &amp;（const保证不修改，&amp;相比指针看起来少*）</span><br></pre></td></tr></table></figure>+ don't change the string object+ more efficient to pass by reference (address) than to pass by value (copy)+ const qualifier protects from change</code></pre></li></ul></li><li><p>Const reference parameters</p><ul><li><p>What if you don’t want the argument changed?</p></li><li><p>Use const modifier</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//y is a constant! Can&#x27;t be modified.void func (const int&amp; y, int&amp; z) &#123;z =z*5;// oky+=8;//error!&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Temporary values are const  内部有一个const int的临时变量存储这个值</p><ul><li><p>What you type</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span> &amp;)</span> </span>;<span class="built_in">func</span> (i * <span class="number">3</span>) ; <span class="comment">// Generates warning or error !</span></span><br></pre></td></tr></table></figure></li><li><p>What the compiler generates</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span> &amp;)</span> </span>;<span class="keyword">const</span> <span class="keyword">int</span> tmp@ = i *<span class="number">3</span>;<span class="built_in">func</span> (tmp@) ; <span class="comment">// Problem -- binding const ref to non-const argument !//有一种解释是说会产生一个const int的临时变量tmp@存i*3的值，所以不能传给boid func（int &amp;），问题：那如果我的函数就是boid func（const int &amp;）行不行=========================================================================================#include &lt;iostream&gt;using namespace std;void f(const int &amp; i)//这个函数要一个int类型的引用，并且有const保证绝对不会修改你传进来的东西&#123;    //把const去掉会得到error    cout &lt;&lt; i &lt;&lt;endl;&#125;int main()&#123;    int i = 3;    f(i*3);        return 0;&#125;-----------------------------------------------------------------------------------------运行结果：-----------------------------------------------------------------------------------------9        //这是可以的，const int的变量可以给const int的引用</span></span><br></pre></td></tr></table></figure></li><li><p>The temporary is constant, since you can’t access it</p></li></ul></li><li><p>const in Function returns  函数返回类型是const（即return一个const的value）</p><ul><li><p>return by const value</p><ul><li><p>for user defined types, it means &quot;prevent use as an value&quot;我返回的那个值你不能再修改</p></li><li><p>for built-in’s it means nothing</p></li><li><pre><code class="language-c++">#include &lt;iostream&gt;using namaspace std;class A&#123;public:    int i;    A() : i(0) &#123;&#125;&#125;;A f()&#123;    A a;    return a;&#125;int main()&#123;    A b;    b.i = 20;    f() = b;//f( )返回一个对象，可以做左值（这和A*/&amp; f()不一样，返回*or&amp;不行,因为离开这个函数，你指针指的or引用 的变量都消失了）    //f().i=10;    //20和21行，都是可以的。f()返回的那个对象a是存在的，但你无法访问到它，它失踪了    return 0;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + return by const pointer or reference</span><br><span class="line"></span><br><span class="line">    - depends on what you want your client to do with the return value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 拷贝构造</span><br><span class="line"></span><br><span class="line">+ Copying</span><br><span class="line">  + Create a new object from an existing one</span><br><span class="line">    一For example, when calling a function</span><br><span class="line">    + &lt;img src=&quot;/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200424165109693.png&quot; alt=&quot;image-20200424165109693&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ **Initialization初始化**和**assignment赋值**</span><br><span class="line"></span><br><span class="line">  + 标志：在**定义变量时**给它值，Initialization初始化</span><br><span class="line"></span><br><span class="line">    ​**定义好了**在给它值，assignment赋值</span><br><span class="line"></span><br><span class="line">  + 区别：任何对象**Initialization初始化**只有一次，后面在给值叫**assignment赋值**</span><br><span class="line"></span><br><span class="line">  + 初始化时=和（）等价</span><br><span class="line"></span><br><span class="line">    + Person baby_b = baby_a;     $\Leftrightarrow$    Person baby_c(baby_a);</span><br><span class="line"></span><br><span class="line">    + 主要看第54行</span><br><span class="line"></span><br><span class="line">      ~~~c++</span><br><span class="line">      //: C11: HowMany.cpp// From Thinking in C++, 2nd Edition// Available at http: //www. BruceEckel. com// (c) Bruce Eckel 2000// Copyright notice in Copyright. txt// A class that counts its objects#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;static int objectCount =0;class HowMany &#123;public:    HowMany()     &#123;        objectCount++;                //记录制作对象的个数        print (&quot;HowMany()&quot;);          //显示调用了构造函数    &#125;        HowMany(int i)          //新加这样一个构造函数    &#123;        objectCount++;                //记录制作对象的个数        print (&quot;HowMany()&quot;);          //显示调用了构造函数    &#125;    void print(const string&amp; msg = &quot;&quot;)     &#123;        if(msg.size() != 0)             cout &lt;&lt; msg &lt;&lt; &quot;: &quot;;cout &lt;&lt; &quot;objectCount = &quot;&lt;&lt; objectCount &lt;&lt; endl;&#125;    ~HowMany()     &#123;        objectCount--;              print(&quot;~HowMany()&quot;);    &#125;&#125;;// Pass and return BY VALUE:HowMany f (HowMany x)          //要一个HowMany对象的输入，返回也是一个Howmany的对象&#123;    cout &lt;&lt; &quot;begin of f&quot; &lt;&lt;endl;x.print(&quot;x argument inside f()&quot;);cout &lt;&lt; &quot;end of f&quot; &lt;&lt;endl;return X;&#125;int main() &#123;HowMany h;h.print(&quot;after construction of h&quot;) ;HowMany h2（10）    //HowMany h2 = 10;    和53行的代码等价，表面上看10是int，h2是一个对象。实际上h2就是要一个int型的参数 h.print(&quot;after call to f()&quot;);&#125;///:~</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>引例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: C11: HowMany.cpp// From Thinking in C++, 2nd Edition// Available at http: //www. BruceEckel. com// (c) Bruce Eckel 2000// Copyright notice in Copyright. txt// A class that counts its objects#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;static int objectCount =0;class HowMany &#123;public:    HowMany()     &#123;        objectCount++;                //记录制作对象的个数        print (&quot;HowMany()&quot;);          //显示调用了构造函数    &#125;    void print(const string&amp; msg = &quot;&quot;)     &#123;        if(msg.size() != 0)             cout &lt;&lt; msg &lt;&lt; &quot;: &quot;;cout &lt;&lt; &quot;objectCount = &quot;&lt;&lt; objectCount &lt;&lt; endl;&#125;    ~HowMany()     &#123;    objectCount--;              print(&quot;~HowMany()&quot;);    &#125;&#125;;// Pass and return BY VALUE:HowMany f (HowMany x)          //要一个HowMany对象的输入，返回也是一个Howmany的对象&#123;    cout &lt;&lt; &quot;begin of f&quot; &lt;&lt;endl;x.print(&quot;x argument inside f()&quot;);cout &lt;&lt; &quot;end of f&quot; &lt;&lt;endl;return X;&#125;int main() &#123;HowMany h;h.print(&quot;after construction of h&quot;) ;HowMany h2 = f(h);h.print(&quot;after call to f()&quot;);&#125;///:~---------------------------------------------------------------------------------------------运行结果：---------------------------------------------------------------------------------------------HowMany(): objectCount = 1after construction of h: objectCount = 1begin of fx argument inside f(): objectCount = 1end of f~HowMany(): objectCount = 0after call to f() : obj ectCount = 0~HowMany(): obj ectCount = -1~HowMany(): objectCount = -2        //不平衡？？</span></span><br></pre></td></tr></table></figure></li><li><p>The copy constructor</p><ul><li><p>Copying is implemented by the copy constructor</p></li><li><p>Has the unique signature</p><ul><li><pre><code class="language-c++">T::T (const T&amp;) ;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + Call-by-reference is used for the explicit argument</span><br><span class="line"></span><br><span class="line">+ C++ builds a copy ctor for you if you don&#x27;t provide one!     </span><br><span class="line"></span><br><span class="line">  c++默认会给拷贝构造函数，做的事情是**拷贝每一个成员变量**。有些东西你不想拷贝或者有些东西有特别的安排可以自己写拷贝构造函数。</span><br><span class="line"></span><br><span class="line">  + Copies each member variable</span><br><span class="line"></span><br><span class="line">    + Good for numbers, objects, arrays</span><br><span class="line"></span><br><span class="line">    + 如果**自己类（假设为类A）的成员变量**是int，会把int拷贝给int；如果是float类型，会把float拷贝给float；</span><br><span class="line"></span><br><span class="line">    + 如果**这个成员变量是其他类（假设为类B）的对象**，会让那个类（类B）的拷贝构造函数拷贝构造那个对象，即这个拷贝构造会递归下去（A的拷贝构造函数--&gt;B的拷贝构造函数）mark动手代码实现。</span><br><span class="line"></span><br><span class="line">      **这是成员级别上的拷贝，而不是bit字节对bit字节的拷贝**（只不过如果类A成员变量没有其他类的对象，是int、float什么的，最终结果和字节对字节的拷贝一样）</span><br><span class="line"></span><br><span class="line">  + Copies each pointer</span><br><span class="line"></span><br><span class="line">    + Data may become shared!  两个指针指向同一块内存</span><br><span class="line"></span><br><span class="line">+ 不是这种形式</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    class A&#123;public:    A(A o)&#123;&#125;;  //A(const A&amp; b);&lt;--默认有的&#125;;//你想传参数调用拷贝构造，却调用A(A o)&#123; &#125; 这个构造函数 ，这个构造函数需要对象作为参数，又传参给这个类去调用自身的拷贝构造，循环，导致递归=======================================================================================  error:invalid constructor;you probably meant &#x27;A(const A&amp;)&#x27;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>What if class contains pointers?  成员变量有指针.&amp;同理</p><ul><li><p>Choices</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200424173736430.png" alt="image-20200424173736430" style="zoom:50%;" /></li><li><p>如果<strong>成员变量有指针</strong>，默认的拷贝后结果是<strong>两个指针指向同一块内存</strong>（图左）</p><ul><li>要加一个拷贝构造函数，去处理指针的问题（图右）。因为默认的拷贝构造函数不会去做申请一块内存这种复杂动作</li></ul></li></ul></li><li><p>Example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.h#ifndef_ PERSON_ _H #define_ PERSON_ _H class Person &#123;public:Person(const char *s);~Person();void print() ;// ... accessor funct ions//private:char *name ;   // char * instead of string，注意这里是char类型指针而不是char类型//... more info e.g. age, address, phone   其他信息&#125;;#endif=============================================================================================//Person.cpp    #include &quot;Person. h&quot;#include &lt;cstring&gt;        // #include &lt;string. h&gt;using namespace std; //构造函数，要用你送进来的字符串指针去初始化对象里的namePerson::Person( const char *s ) &#123;name = new char[::strlen(s) + 1];  //【new一块John&quot;+1即大小为5的char类型的空间给     //name指针】: :strcpy(name, s);                //让指针name的地址=s的地址，即name指向s指向的内存&#125;Person: :~Person() &#123;delete [ ] name;    // array delete&#125;=============================================================================================//main.cpp    #include &lt;stdio. h&gt;#include &quot;person. h&quot;int main( )&#123;Person p1(&quot;John&quot;);    Person p2(p1);      //对象p1里的name指针指向“John”，拷贝构造后对象p2里的name指针也指向”                        //“John”    printf (&quot;p1.name=%p\n&quot;, p1.name) ;printf(&quot;p2.name= :%p\n&quot;，p2.name ) ;    return 0;&#125;//对象释放时，析构被调用，delete对象p1里的name指针，delete对象p2里的name指针，但它们指着同一块内存，所以同一块内存delete了两次，报错---------------------------------------------------------------------------------------------//运行结果：p1.name=0x7f90084000e0p2.name=0x7f90084000e0    //证明指向同一块内存a. out(10067) malloc: *** error for object 0x7f90084000e0: pointer //错误因为同一块内存free了两次eing freed was not allocated*** set a breakpoint in malloC_ error_ break to debugAbort trap: 6============================================================================================= //正确做法：加一个拷贝构造函数。这样被指的东西也复制了一份    //●To person declaration add copy ctor prototype:    Person(const Person&amp; w);  //copy ctor//●To Person.cpp add copy ctor defintionPerson::Person(const Person&amp; w)&#123;    name = new char[::strlen(w.name)+1];    ::strcpy(name,w.name);&#125;//传同类的另一个对象p1进来，得到p1里面name的长度去初始化创建p2 name的内存，然后做拷贝//●No value returned//●Accesses w.name across client boundary//●The copy ctor initializes uninitialized memory//private是针对类而不是对象，访问同类另一个对象private的东西是ok的</span></span><br></pre></td></tr></table></figure></li><li><p>Character strings</p><ul><li>In C++, a character string is<ul><li>An array of characters</li><li>With a special terminator— ‘\0’ or ASCII null<ul><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200424165936411.png" alt="image-20200424165936411" style="zoom:50%;" /></li></ul></li></ul></li><li>The string “C++” is represented, in memory, by an array of four (4, count’em) characters</li></ul></li><li><p>Standard C library String fxns</p><ul><li><p>Declared in <cstring>（C的标准款string.h，不过会有点不同，eg.某个参数有const；返回类型是size_t而不是int，给今后改成非int留下空间）</p><ul><li><pre><code class="language-c++">size_t strlen(const char *s);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + s is a null-terminated string</span><br><span class="line">  + returns the length of s</span><br><span class="line">  + length does not include the terminnator!</span><br><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  char *strcpy (char *dest,const char *src)</span><br></pre></td></tr></table></figure>+ Copies src to dest stopping after the terminating null-character is copied. (src should be null-terminated!)+ dest should have enough memory space allocated to contain src string.，+ Return Value: returns dest</code></pre></li></ul></li></ul></li><li><p>When are copy ctors called?</p><ul><li><p>函数形参是对象，调用这个函数时</p><ul><li><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200425134735028.png" alt="image-20200425134735028" style="zoom:50%;" /></li></ul></li><li><p>During initialization</p><ul><li><pre><code class="language-c++">Person baby_ a (&quot;Fred&quot;) ;// these use the copy ctorPerson baby_ b = baby_ a; // not an assignmentPerson baby_ C( baby_ a) ;// not an assignment<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    &lt;img src=&quot;/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200425134918145.png&quot; alt=&quot;image-20200425134918145&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">+ During function return(函数返回一个对象)</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200425135111465.png&quot; alt=&quot;image-20200425135111465&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  + Copies and overhead</span><br><span class="line"></span><br><span class="line">    + Compilers can &quot;optimize out&quot; copies when safe!</span><br><span class="line"></span><br><span class="line">      + **optimeize out** 编译器会把它认为不必要的拷贝构造给优化掉</span><br><span class="line"></span><br><span class="line">      + Example</span><br><span class="line"></span><br><span class="line">        ~~~c++</span><br><span class="line">        Person copy_func( char *who )&#123;Person local ( who ) ;   //who不是对象，初始化对象local不发生拷贝构造local .print() ;return local;             // copy ctor called!  &#125;// 返回对象local出去，初始化对象p的时候会调用拷贝构造---------------------------------------------------------------------------------Person nocopy_func( char *who ) &#123;return Person( who ) ;&#125;                             //no copy needed ! ---------------------------------------------------------------------------------//外头    Person p = copy_func(&quot;x&quot;); //nocopy func返回的是一个Person @tmp（who），在用这个临时对象去初始化下面那个p对象。但因为在nocopy func里你没使用过这个对象，所以编译器一步到位，直接用who去初始化对象p，跳过了这个临时变量@tmp的拷贝构造</span><br></pre></td></tr></table></figure>+ Programmers need to  - Program for &quot;dumb&quot; compilers  - Be ready to look for optimizations</code></pre></li></ul></li></ul></li><li><p>Constructions VS. assignment</p><ul><li>Every object is constructed once</li><li>Every object should be destroyed once<ul><li>Failure to invoke delete()</li><li>Invoking delete() more than once</li></ul></li><li>Once an object is constructed, it can be the target of many assignment operations</li></ul></li><li><p>Person:string name</p><ul><li><p>What if the name was a string (and not a char*)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>class Person &#123;public:Person( const string&amp; );~Person();void print();<span class="comment">// ... other accessor fxnsprivate:string name;// embedded object (composition)//..other data members...&#125;;//成员变量是系统类库里的string类，则不需要人为加拷贝构造函数,因为拷贝构造是成员级别上的拷贝，它可以拷贝string成员。（string是系统内库，库里有相应的拷贝构造函数，它能把这件事做好）//建议：在c++不使用c以前的string.h。用string类来做事情，string会自己take care of everything，包括拷贝构造的事情）// 用char*除非你要动内存or要做二进制的事情（Byte *，只不过Byte *在c和c++表现为char *）。//用字符串请使用string</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Copy ctor guidelines</p><ul><li>In general, be explicit<ul><li>Create your own copy ctor – don’t rely on the default  每写一个类，就为这个类写一个copy constructor，别太依赖默认的</li></ul></li><li>If you don’t need one declare a private copy ctor<ul><li>prevents creation of a default copy constructor</li><li>generates a compiler error if try to pass-by-value</li><li>don’t need a defintion</li><li>把copy constructor访问属性设置为private，别人不能拷贝你的对象<ul><li>别人无法弄一个函数，这个函数的参数是对象本身，因为拷贝构造函数被禁止了</li></ul></li></ul></li></ul></li></ul><h3 id="静态对象">静态对象</h3><ul><li><p>Static在C的两义（在哪和谁能看到两回事）</p><ul><li>持久存储<ul><li>如果说一个本地变量是static的，那么这个本地变量具有持久存储。实际上，static 本地变量就是全局变量</li></ul></li><li>访问性受局限<ul><li>如果说一个全局变量/函数是static的，说明这个全局变量/函数只在这个.c文件有效</li></ul></li></ul></li><li><p>Static in C++</p><p>Two basic meanings</p><ul><li>Static storage<ul><li>allocated once at a fixed address</li></ul></li><li>Visibility of a name<ul><li>internal linkage</li></ul></li><li>Don’t use static except inside functions and classes</li></ul></li><li><p>Uses of “static” in C++</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Static free functions</td><td><s>Internal linkage</s> (deprecated过时了)</td></tr><tr><td>Static global variables全局变量</td><td><s>Internal linkage</s>(deprecated)</td></tr><tr><td>Static local variables本地变量</td><td>Persistent storage持久存储</td></tr><tr><td>Static member variables成员变量</td><td>Shared by all instances所有对象间共享</td></tr><tr><td>Static member function成员函数</td><td>Shared by all instances, can  only access static member  variables只能访问静态成员变量or静态成员函数</td></tr></tbody></table></li><li><p>Global static hidden in file</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200425142233717.png" alt="image-20200425142233717" style="zoom:50%;" /><ul><li>在File2 extern int g_global;就可以在File2中使用File1中的g_global</li><li>但在File1中int s_local是static的，即s_local只能在File1中使用，File2extern了能骗过编译器，但到ld链接器那关会出问题</li></ul></li><li><p>Static inside functions</p><ul><li><p>Value is remembered for entire program</p></li><li><p>Initialization occurs only once</p></li><li><p>Example:</p><ul><li><p>count the number of times the function has been called</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;    staic <span class="keyword">int</span> num_calls = <span class="number">0</span>;    ...    num_calls++;&#125;<span class="comment">//全局变量，但只能在函数里访问</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Static applied to objects</p><ul><li><p>Suppose you have a class</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span><span class="built_in">X</span>(<span class="keyword">int</span>， <span class="keyword">int</span>) ;~<span class="built_in">X</span>() ;    ...&#125;;</span><br></pre></td></tr></table></figure></li><li><p>And a function with a static X object</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;    <span class="function"><span class="keyword">static</span> X my_ <span class="title">X</span><span class="params">(<span class="number">10</span>，<span class="number">20</span>)</span> </span>;...&#125;<span class="comment">//在链接器时，分配my_x的空间。//第一次进函数时，初始化my_x//只初始化一次，存储是全局的，如果后面再次调这个函数不初始化。//在目前c++格局下不知道对象有没有初始化过。所以需要一个伴随的变量知道这个对象有没有初始化过，见下面的Conditonal construction-Example//当你以后设计自己的OOP语言，你可以考虑给每个对象来一个hidden的变量，表示你这个对象有没有初始化过//JAVA不需要，因为JAVA会保证不会让你去用没有初始化过的内存</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Static applied to objects…   static 对象</p><ul><li>Construction occurs when definition is encountered<ul><li>Constructor called at-most once   构造只发生一次，有构造就会有析构</li><li>The constructor arguments must be satisfied</li></ul></li><li>Destruction takes place on exit from program    析构在程序结束时发生<ul><li>Compiler assures LIFO order of destructors</li></ul></li></ul></li><li><p>Conditional construction  有条件的构造</p><ul><li><p>Example：conditional construction</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;    <span class="keyword">if</span>(x&gt;<span class="number">10</span>)    &#123;        <span class="function"><span class="keyword">static</span> X <span class="title">my_X</span><span class="params">(x,x*<span class="number">21</span>)</span></span>;        ...    &#125;&#125;<span class="comment">//x作为伴随的变量，通过x可以知道这个对象有没有初始化过</span></span><br></pre></td></tr></table></figure></li><li><p>my_X</p><ul><li>is constructed once,if f() is ever called with x&gt;10</li><li>retains its value</li><li>destroyed only if constructed</li></ul></li></ul></li><li><p>Global objects  全局对象</p><ul><li><p>Consider</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;X.h&quot;</span>X glocal_x(12, 34);X global_x2(8, 16);</span></span><br></pre></td></tr></table></figure></li><li><p>Constructors are called before main()is entered</p><p>链接时分配空间，空间在全局数据区</p><p>全局对象的构造在程序一运行时执行，在main()之前，且只执行一次</p><ul><li>Order controlled by appearance in file</li><li>In this case,global_x before global_x2</li><li>main() is no longer the first function called</li></ul></li><li><p>Destructors called when      main()结束  or  exit()时调用析构     (即程序结束调用析构）</p><ul><li>main() exits</li><li>exit() is called</li></ul></li></ul></li><li><p>Static Initialization Dependency</p><ul><li><p>Order of construction within a file is known</p></li><li><p>Order between files is unspecified!</p></li><li><p>Problem when non-local static objects in different files have dependencies</p></li><li><p>A non-local static object is :</p><ul><li>defined at global or namespace scope</li><li>declared static in a class</li><li>defined static at file scope</li></ul></li><li><p>跨文件初始化全局对象（如果你的程序有多个.cpp文件，每个文件里都有一个全局变量）</p><ul><li>这些全局对象的初始化顺序没有规矩</li><li>如果你的这些全局对象初始化互相有依赖，比如某个对象的初始化要用另一个对象作为它构造函数的参数，就要那个对象先得到初始化，解决办法：<ul><li>别这么干</li><li>在逻辑许可的前提下，把所有有依赖的全局变量放在同一个地方</li><li>JAVA怎么做，JAVA没全局变量，就没这种问题</li></ul></li></ul></li></ul></li></ul><h3 id="静态成员">静态成员</h3><ul><li><p>Can we apply static to members?</p><ul><li>Static means<ul><li>Hidden  隐藏<ul><li>在c++stactic的Hidden任务结束了，通过类的访问属性public、private、protected就可以完成Hidden这个任务</li></ul></li><li>Persistent  持久存储<ul><li>对于一种在函数之间流转的语言来说，函数之间仍然存在的东西叫persistent。eg.c语言中是指全局变量和malloc的东西</li><li>对于一种在对象之间流转的语言来说，对象和对象之间还能存在的东西叫persisten。</li><li>类的不同对象之间的成员变量是Persistent保持一致的，不随对象的不同而不同。另外一种说法是这个static 的成员变量是class-wide，整个类领域里的东西。（其实是做了一个全局变量，让这个全局变量是类的成员，这样在一个对象里修改了，表象上看所有其他对象里这个值也改了）</li></ul></li></ul></li><li>Hidden：A static member is a member<ul><li>Obeys usual access rules</li></ul></li><li>Persistent：Independent of instances</li><li>Static members are class-wide<ul><li>variables or</li><li>functions</li></ul></li></ul></li><li><p>Static members</p><ul><li><p>Static member variables</p><ul><li><p>Global to all class member functions</p></li><li><p>Initialized once,at file scope</p></li><li><p>provide a place for this variable and init it in .cpp</p></li><li><p>No ‘static’ in .cpp</p></li><li><p>Example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std;class A&#123;public:    A() &#123;i= 0; &#125;void print() &#123; cout <span class="meta-string">&lt;&lt; &lt; i &lt;&lt; endl; &#125;void set(int ii) &#123; i= ii; &#125;private:static int i;&#125;;int main()&#123;    A a,b;    a.set(10);b.print();    return 0;&#125;----------------------------------------------------------------------------------------Undefined symbols for architecture x86_ _64:&quot;A::i&quot;， referenced f rom: .A::A()in ccQeG7fH.0 .A::set(int)in ccQeG7fH. 0A::print()in ccQeG7fH. 0ld: symbol(s) not found for architecture x86_ 64   //重点在这一句collect2: ld returned 1 exit status========================================================================================    //类里的都是declaration，并且static的成员变量在全局数据区。    //编译能通过但ld链接器会找不到这个全局变量    //类有static成员变量，要在某个.cpp文件里写上这个成员变量的defination======================================================================================== #include &lt;iostream&gt;</span>using namespace std;class A&#123;public:    A() &#123;i= 0; &#125;void print() &#123; cout <span class="meta-string">&lt;&lt; &lt; i &lt;&lt; endl; &#125;void set(int ii) &#123; i= ii; &#125;        //void set(int i) &#123; this-&gt;</span>i= i; &#125;    <span class="comment">//this指针可以访问静态和非静态的成员变量,静态变量仍然是类的成员变量private:static int i;&#125;;//int A::i;要加上这一句defination,否则报错如下代码区所示//可以在定义时候初始化int A::i=10;int main()&#123;    A a,b;    a.set(10);b.print();    return 0;&#125;  ========================================================================================static int A::i;//如果加的是这句，表示这个东西只能在这个.cpp文件里访问，这与类的静态成员访问属性(private)违背，因为类的静态成员可能会被外部（除这个.cpp文件外的东西）访问。会报错为：Kai-MBA:CC wengkai$ g++ a.cppa.cpp:14: error:&#x27;static&#x27; may not be used when defining (as opposed to declaring)a static data member========================================================================================//如果在Initializer list去初始化这个静态成员变量，则报错。因为Initializer list只能对非静态成员作初始化Kai-MBA:CC wengkai$ g++ a. cppa.cpp: In constructor &#x27;A: :A()&#x27; :a.cpp:7: error: &#x27;int A::i&#x27; is a static data member; it can only be initialized at its definition========================================================================================//静态成员变量/函数是public，在类以外有两种方式访问它:    a.i//通过具体某个对象or    A::i//通过类的名字加：：去访问</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>静态成员函数</p><ul><li>静态成员函数只能调静态成员函数、访问静态成员变量（表面上）</li><li>原因：静态成员函数因为可以通过类的名字加::去调用，所以静态成员函数是没有this这个hidden parameter，所以在这个函数里你无法访问其它非静态成员变量</li><li>我们需要有一些东西是它和类的对象存在与否无关的</li></ul></li></ul></li></ul><h2 id="重载">重载</h2><h3 id="运算符重载——基本规则">运算符重载——基本规则</h3><ul><li><p>Overloading Operators</p><ul><li><p>Allows user-defined types to act like bulit in types</p></li><li><p>Another way to make a function call.</p></li><li><p>Unary and binary operators can be overloaded:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+  -  *  /  %  ^  &amp;  |  ~=  &lt;  &gt;  +=  -=  *=  /=  %=^=  &amp;=  |=  &lt;&lt;  &gt;&gt;  &gt;&gt;=  &lt;&lt;=  ==!=  &lt;= &gt;=  !  &amp;&amp;  ||  ++  --,  -&gt;*  -&gt;  ()  []operator new         operator deleteoperator new[]       operator delete[]^异或 ~取反&lt;&lt;（左移or insert）, 运算符，表达式连接，结果是右边那个()函数传参数的时[]数组索引</span><br></pre></td></tr></table></figure></li><li><p>Operators you can’t overload</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.  .*  ::  ?:<span class="keyword">sizeof</span>  typeidstatic_cast  <span class="keyword">dynamic_cast</span>  const_castreinterpret_cast</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Restrictions</p><ul><li><p>Only existing operators can be overloaded(you can’t create a ** operator for exponentiation)</p><p>只能重载已有的运算符</p></li><li><p>Operators must be overloaded on a class or enumeration type</p><p>只能对类或枚举类型里的运算符进行重载</p></li><li><p>Overloaded operators must</p><ul><li><p>Preserve number of operands</p><p>保持运算符原来的操作数</p></li><li><p>Preserve precedence</p><p>保持原来的优先级</p></li></ul></li></ul></li><li><p>C++ overloaded operator</p><ul><li><p>Just a function with an operator name!</p><ul><li>Use the <strong>operator</strong> keyword as a prefix to name<br>operator * (…)     //重载*运算符</li></ul></li><li><p>Can be a member function</p><ul><li><p>Implicit first argument</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> String String::<span class="keyword">operator</span> + (<span class="keyword">const</span> String&amp; that) ;<span class="comment">//非静态成员函数自带this，因为+法要两个算子，所以还需要一个that</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Can be a global (free) function</p><ul><li><p>Both arguments explicit</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> String <span class="keyword">operator</span>+ (<span class="keyword">const</span> String&amp; r, <span class="keyword">const</span> String&amp; <span class="number">1</span>) ;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>How to overload</p><ul><li>As member function<ul><li>lmplicit first argument</li><li>No type conversion performed on receiver</li><li>Must have access to class definition</li></ul></li></ul></li><li><p>Operators as member functions</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> &#123;</span><span class="keyword">public</span>:<span class="built_in">Integer</span>(<span class="keyword">int</span> n=<span class="number">0</span>):<span class="built_in">i</span>(n)&#123;&#125;<span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer&amp; n) <span class="keyword">const</span>&#123;<span class="comment">//加法不会改变两个算子，所以Interger&amp; n 前有const，this也有const（加在函数结尾）    //前面这个const，让函数返回结果不能做左值，eg.a+b=6，在程序设计中是错的，不能有的return Integer (i + n.i) ;&#125;    ...private :int i;&#125;;</span></span><br></pre></td></tr></table></figure></li><li><p>Member Functions</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">x</span><span class="params">(<span class="number">1</span>)</span> ，<span class="title">y</span><span class="params">(<span class="number">5</span>)</span> , z</span>;x+y;     ====&gt; x.<span class="keyword">operator</span>+(y) ;<span class="comment">//operator+   函数//运算符左边那个算子叫receiver，它的类型决定用哪个+</span></span><br></pre></td></tr></table></figure><ul><li><p>Implicit first argument</p></li><li><p>Developer must have access to class definition</p></li><li><p>Members have full access to all data in class</p></li><li><p>No type conversion performed on receiver</p><ul><li>z=x+y;✔（receiver是x，用的是Integer的+）</li><li>z=x+3;✔（用的是Integer的+，3不能直接用，会把3用构造函数Integer(int n=0):i(n){}构造成一个Integer的对象，让x和这个匿名的（没有变量）对象做Integer的operator +，然后赋给对象z）<ul><li>z=x+3.5;不行，因为构造函数入口是int类型</li><li>z=x+3,构造函数是double n=0；也不行。int类型的3可以变成double类型的3（第一次自动类型转换）（窄的数据类型可以自动转换成宽的，宽的不能变窄的），然后double的3变成Integer类的3，（第二次自动类型转换）。只能有一次自动类型转换，两次不行</li></ul></li><li>z =3+y;✖（receiver是3，用的是系统默认的+，再发现右边的算子是Integer，需要Integer这个类里有一个手段把对象y变成int，这里没有，所以这个式子编译通不过）</li></ul></li><li><p>For binary operators (+, -, *,etc) member functions require one argument.二元运算符要1个参数（还有1个this）</p></li><li><p>For unary operators (unary -, !, etc) member functions require no arguments:一元不需要，对自己做运算的结果，制造成新的值交给别人，注意不改变自己！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>- () <span class="keyword">const</span> &#123;    <span class="keyword">return</span> <span class="built_in">Integer</span> (-i) ;&#125;  ...  z=-x;<span class="comment">// z.operator= (x. operator-()) ;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>How to overload</p><ul><li><p>As a global function</p><ul><li>Explicit first argument</li><li>Type conversions performed on both arguments</li><li>Can be made a friend</li></ul></li></ul></li><li><p>Operator as a global function</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer&amp; rhs,<span class="keyword">const</span> Integer&amp; lhs) ;<span class="comment">//左右两边算子都要写Integer x，y;x+y        ====&gt; operator+(x, y) ;//运算符重载是全局函数，可以不用修改一个类里的代码，直接给这个类加上这个运算符重载  //前提：能接触到类里的成员  //比如这个类有get函数能让外部访问它的成员变量  //左右两个算子都可以转换类型</span></span><br></pre></td></tr></table></figure><ul><li>Explicit first argument</li><li>Developer does not need special access to classes .</li><li>May need to be a friend</li><li>Type conversions performed on both arguments .</li></ul></li><li><p>Global operators（friend）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> &#123;</span><span class="keyword">friend</span> <span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer&amp; lhs,<span class="keyword">const</span> Integer&amp; rhs) ;    ...&#125;<span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer&amp; lhs,<span class="keyword">const</span> Integer&amp; rhs)&#123;<span class="keyword">return</span> <span class="built_in">Integer</span>( lhs.i + rhs.i ) ;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Global Operators</p><ul><li>binary operators require two arguments</li><li>unary operators require one argument</li><li>conversion:<br>z =x+y;✔<br>z=x+3;✔<br>z=3+y;✔（如果receiver是3，做不了；如果receiver是y，把3变成Integer，可以做，那就用这个做）<br>z=3+7;✔（3+7完是10，再把10转成Integer赋给z）</li><li>If you don’t have access to private data members, then the global function must use the public interface (e.g. accessors)</li></ul></li><li><p>Tips:Members vs. Free Functions</p><ul><li>Unary operators <strong>should be</strong> members     单目的should be 成员函数</li><li>= ()  []  -&gt;  -&gt;* must be members     必须是成员函数（不是成员没法做）</li><li>assignment operators should be members</li><li>All other binary operators as non-members     其他二元运算符做成非成员函数（因为相比于做成成员函数，全局函数，左右两个算子都可以做receiver）</li></ul></li></ul><h3 id="运算符重载——原型">运算符重载——原型</h3><ul><li><p>Argument Passing</p><ul><li>if it is trad-only pass it in as a const reference(except bulit-ins)  传进函数的参数一定是对象，所以是const 的引用</li><li>make member functions const that don’t change the class (boolean operators, +, -, etc)  不修改算子，函数结尾加上const（给this的），还有另外一个参数也要const</li><li>for global functions, if the left-hand side changes pass as a reference (assignment operators)</li></ul></li><li><p>Return Values  return的values是改变传进来的对象还是制造新的对象，如果是新的对象，能不能作左值？</p><ul><li><p>Select the return type depending on the expected meaning of the operator. For example,</p><ul><li><p>For operator+ you need to generate a new object.   //比如重载+号，是制造出一个新的对象，而且不能做作左值</p><p>Return as a const object so the result cannot be modified as an Ivalue.</p></li><li><p>Logical operators should return bool (or int for older compilers). 逻辑运算返回布尔量</p></li></ul></li></ul></li><li><p>The prototypes of operators  常见operators原型</p><ul><li><p>±*/%^&amp;|~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> T <span class="title">operatorX</span><span class="params">(<span class="keyword">const</span> T&amp; I, <span class="keyword">const</span> T&amp; r)</span> <span class="keyword">const</span></span>;<span class="comment">//返回的不能左左值//传对象，const（防开销） &amp;（清爽）//不会修改算子//返回的不是引用，是新对象</span></span><br></pre></td></tr></table></figure></li><li><p>!  &amp;&amp;  ||  &lt;  &lt;=  ==  &gt;=  &gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operatorX</span><span class="params">(<span class="keyword">const</span> T&amp; I, <span class="keyword">const</span> T&amp; r)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>[]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T&amp; T::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)    <span class="comment">//参数是个int    //一定是&amp;。并且我们要拿它作左值，所以函数最前面没const</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>operators ++ and –</p><ul><li><p>How to distinguish postfix from prefix?</p></li><li><p>postfix forms take an int argument – compiler will pass in 0 as that int</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> &#123;</span><span class="keyword">public</span>:    ...<span class="keyword">const</span> Integer&amp; <span class="keyword">operator</span>++ () ;<span class="comment">//prefix++   //eg.++a，先+后用（返回），即返回a加了以后的结果（自身变了），返回a的引用即可（可以不用&amp;，但用&amp;更节约，环保）。前面的const表示禁止拿它做左值，eg.++a=6，这不行    const Integer operator++ (int) ; //postfix++  //eg.a++,返回加以前的结果，对象变了，返回新对象         //这个int只是让编译器知道是prefix还是postfix    const Integer&amp; operator--() ; //prefix--          const Integer operator--(int) ; //postfix--    ...&#125;;const Integer&amp; Integer::operator++ () &#123;    *this += 1;// increment   this是指针，*this是它所指的对象（这里只是用*this表示对象里的成员变量，实际代码不是这样子写，对象和1没法+=）    return *this ;// fetch&#125;// int argument not used so leave unnamed so// won&#x27;t get compiler warningsconst Integer Integer::operator++( int ) &#123;Integer old( *this ) ; // fetch   //调用拷贝构造函数，制作一个新的对象++ (*this) ;// increment   调用13行的函数。return old;// return了原始的值    old对象只在这个函数里有效，返&amp;返不出去    &#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>附&lt;<a href="https://www.runoob.com/cplusplus/increment-decrement-operators-overloading.html">https://www.runoob.com/cplusplus/increment-decrement-operators-overloading.html</a>&gt;</p><ul><li><p>Using the overloaded ++ and –</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decrement operators similar to incrementInteger x(5) ;++x;// calls x.operator++() ;x++;// calls x.operator++(0) ;--x;// calls x.operator--() ;x--;// calls x.operator--(0) ;</span></span><br></pre></td></tr></table></figure><ul><li>User-defined prefix is more efficient than postfix.</li></ul></li><li><p>Relational operators</p><ul><li><p>implement != in terms of==</p></li><li><p>implement&gt;, &gt;= , &lt; &lt;= in terms of &lt;      只写&lt;和==的重载，其他的基于它们来实现。好处是将来好修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> &#123;</span><span class="keyword">public</span>:    ...    <span class="keyword">bool</span> <span class="keyword">operator</span>==( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span>;    <span class="keyword">bool</span> <span class="keyword">operator</span>!=( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span>;    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span>;    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span>;    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span>;    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span>;&#125;<span class="keyword">bool</span> Integer::<span class="keyword">operator</span>==( <span class="keyword">const</span> Integer&amp; rhs ) <span class="keyword">const</span> &#123;<span class="keyword">return</span> i == rhs.i;&#125;<span class="comment">// implement lhs != rhs in terms of ! (lhs == rhs)  用了12行的来写这个函数bool Integer::operator!=( const Integer&amp; rhs ) const &#123;return ! (*this == rhs) ;&#125;bool Integer::operator&lt;( const Integer&amp; rhs ) const &#123;return i &lt; rhs.i;&#125;// implement 1hs &gt; rhs in terms of lhs &lt; rhsbool Integer::operator&gt;( const Integer&amp; rhs ) const &#123;return rhs &lt; *this;// implement 1hs &lt;= rhs in terms of ! (rhs &lt; 1hs)bool Integer::operator&lt;=( const Integer&amp; rhs ) const &#123;return ! (rhs &lt; *this) ;&#125;    // implement lhs &gt;= rhs in terms of ! (lhs &lt; rhs)bool Integer::operator&gt;=( const Integer&amp; rhs ) const &#123;return ! (*this &lt; rhs) ;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Operator []</p><ul><li><p>Must be a member function</p></li><li><p>Single argument</p></li><li><p>Implies that the object it is being called for acts like an array, so it should return a reference</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">V</span> <span class="params">(<span class="number">100</span>)</span> </span>; <span class="comment">// create a vector of size 100 v[10] = 45;//[]返回的是引用，所以可以作左值//(Note: if returned a pointer you would need to do:*v[10] = 45;</span></span><br></pre></td></tr></table></figure></li><li><p>vector.h，vector.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector.h#ifndef _VECTOR_H_#define _VECTOR_H_class Vector &#123;public:Vector(int size):m_size(size)     &#123;m_array = new int[size];    &#125;~Vector() &#123; delete m_ array; &#125;int&amp; operatorD(int index) &#123; return m_array[index]; &#125;private:int m_size;int *m_array;//以后改变这个容器的容量很容易，相比于直接int m_array[size] &#125;;#endif</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="运算符重载——赋值">运算符重载——赋值</h3><ul><li><p>Copying VS. lnitialization</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyType b;MyType a= b;<span class="comment">//拷贝构造a=b;//赋值</span></span><br></pre></td></tr></table></figure></li><li><p>Example:Copying Vs Initialization.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fi</span> &#123;</span><span class="keyword">public</span>:    <span class="built_in">Fi</span>() &#123;&#125;&#125;;  <span class="class"><span class="keyword">class</span> <span class="title">Fee</span> &#123;</span><span class="keyword">public</span>:    <span class="built_in">Fee</span>(<span class="keyword">int</span>) &#123;&#125;  <span class="built_in">Fee</span>(<span class="keyword">const</span> Fi&amp;) &#123;&#125;&#125;;  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    Fee fee = <span class="number">1</span>; <span class="comment">// Fee(int)        Fi fi;  Fee fum = fi; // 调用构造函数Fee(Fi)        fum = fi;//先用Fee(const Fi&amp;)把fi变成Fee类对象，然后赋值给fum&#125;///:~</span></span><br></pre></td></tr></table></figure></li><li><p>Automatic operator= creation</p><ul><li><p>The compiler will automatically create a <strong>type::operator=(type)</strong> if you don’t make one.</p></li><li><p>memberwise assignment  系统默认的=是成员级别的拷贝，这点和拷贝构造函数一样</p></li><li><p>Example:AutomaticOperatorEquals.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Cargo &#123; public:    Cargo&amp; operator=(const Cargo&amp;)     &#123;    cout&lt;&lt;<span class="meta-string">&quot;inside Cargo::operator=()&quot;</span> &lt;&lt; endl;    return *this;    &#125;    &#125;;class Truck &#123;Cargo b;&#125;;int main() &#123;Truck a, b;a = b;<span class="comment">//Prints:&quot;inside Cargo::operator=()&quot;&#125;///：~</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Assignment Operator</p><ul><li><p>Must be a member function  必须是成员函数</p></li><li><p>Will be generated for you if you don’t provide one</p><ul><li>Same behavior as automatic copy ctor - memberwise assignment</li></ul></li><li><p>Check for assignment to self</p></li><li><p>Be sure to assign to all data members</p></li><li><p>Return a reference to *this</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=B=C;<span class="comment">// executed asA=(B=C);</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Skeleton assignment operator</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T&amp; T::<span class="keyword">operator</span>=( <span class="keyword">const</span> T&amp; rhs ) &#123;<span class="keyword">if</span>( <span class="keyword">this</span> != &amp;rhs)     <span class="comment">// check for self assignment，why？见12行   有动态分配内存的就要写    &#123;// perform assignment  作赋值的具体操作&#125;return *this;//最后一定是这句&#125;//This checks address vs. check value(*this!=rhs)//这种情况下自己又=一次自己有坏处：class A &#123;char *p;A&amp; operator=(const A&amp; that)&#123;delete p;//你肯定是申请过内存的啦，所以要先delete        //如果that已经就是this，这里delete p就把this和that都delete掉了。20行that.p不存在，无法执行        p=new[strlen(that.p)+1];    strcpy(p，that.p);    return *this;&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Assignment Operator</p><ul><li>For classes with dynamically allocated memory declare an assignment operator (and a copy constructor)有动态内存分配要写那个判断是否相等</li><li>To prevent assignment, explicitly declare operator= as private  如果你想防止系统作的那个=行为不正确，可以将=声明为私有，但代价是这个类的对象无法赋值</li></ul></li></ul><h3 id="运算符重载——类型转换">运算符重载——类型转换</h3><ul><li><p>Value classes  类的作用是表达值</p><ul><li>Appear to be primitive data types  看上去很像基本类型</li><li>Passed to and returned from functions  可以传进传出函数</li><li>Have overloaded operators (often)  一般需要有重载的运算符</li><li>Can be converted to and from other types  转换类型</li><li>Examples: Complex, Date, String</li></ul></li><li><p>User-defined Type conversions</p><ul><li><p>A conversion operator can be used to convert an object of one class into</p><ul><li>an object of another class</li><li>a built-in type</li></ul></li><li><p>Compilers perform implicit conversions</p><p>using:</p><ul><li>Single-argument constructors</li><li>implicit type conversion operators</li></ul></li></ul></li><li><p>Single argument constructors</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathName</span> &#123;</span>string name;<span class="keyword">public</span>:<span class="comment">// or could be multi- argument with defaults PathName (const string&amp;) ;~PathName () ;&#125;;...string abc (&quot;abc&quot;) ;PathName xyz (abc) ; // OK!xyz = abc;// OK abc =&gt; PathName，然后这个PathName的abc会和xyz这个PathName作operator assignment（=），然后PathName没有自己的operator assignment，就用调用系统默认的operator assignment。因为是对象的拷贝，没涉及到指针，所以在这个default operator assignment里是ok的，于是会递归调用string类的operator assignment来作abc和xyz的赋值</span></span><br></pre></td></tr></table></figure><ul><li><p>Example:AutomaticTypeConversion.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: C12:AutomaticTypeConversion.cpp// From Thinking in C++， 2nd Edition// Available at http://www.BruceEckel.com// (c) Bruce Eckel 2000// Copyright notice in Copyright . txt// Type conversion constructorclass One &#123;public:0ne() &#123;&#125;&#125;;class Two &#123;public:Two( const 0ne&amp;) &#123;&#125;&#125;;void f(Two) &#123;&#125;int main() &#123;One one;f(one); // Wants a Two，has a One&#125; ///:~</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Preventing implicit conversions  不想让编译器自动转换</p><ul><li><p>New keyword: explicit</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathName</span>&#123;</span>string name;<span class="keyword">public</span>:<span class="function"><span class="keyword">explicit</span> <span class="title">PathName</span> <span class="params">(<span class="keyword">const</span> string&amp;)</span> </span>;<span class="comment">//显式的，告诉编译器我这个构造函数只能做构造函数，而不能拿来作自动转换类型~PathName () ;&#125;;...string abc (&quot;abc&quot;) ;PathName xyz (abc) ; // OK!xyz = abc;// error !</span></span><br></pre></td></tr></table></figure></li><li><p>Example:ExplicitKeyword.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> &#123;</span><span class="keyword">public</span>:<span class="built_in">One</span>() &#123;&#125;&#125;;<span class="class"><span class="keyword">class</span> <span class="title">Two</span> &#123;</span><span class="keyword">public</span>:<span class="keyword">explicit</span> Two <span class="keyword">const</span> One&amp;) &#123;&#125;&#125;;<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Two)</span> </span>&#123;&#125;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;One one ;<span class="comment">//! f(one); // No auto conversion allowedf(Two(one)); // 0K -- user performs conversion&#125; ///:~</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Conversion operations  自己做一个自动转换类型的函数</p><ul><li><p>Operator conversion</p><ul><li>Function will be called automatically</li><li>Return type is same as function name</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span><span class="keyword">public</span>:    ...<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// Rational to double.这个double意思是把this转换成double&#125;Rational::operator double () const &#123;//这个double已经说明这个函数的返回类型。所以这个函数前面没返回类型return numerator_ / (double) denominator ;//把this转换掉了，但并没有改this的值，所以函数结尾有const&#125;Rational r(1,3) ; double d = 1.3 * r; // r=&gt;double</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>General form of conversion ops</p><ul><li>X::operator T ()<ul><li>Operator name is any type descriptor</li><li>No explicit arguments</li><li>No return type</li><li>Compiler will use it as a type conversion from X→T  把X的对象转换成T</li></ul></li></ul></li><li><p>C++type conversions</p><ul><li><p>Built-in conversions 基础类型</p><ul><li><p>Primitive</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++%E7%AC%94%E8%AE%B0-%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82%E7%BF%81%E6%81%BA%E8%80%81%E5%B8%88/image-20200425204121286.png" alt="image-20200425204121286"></p></li><li><p>Implicit (for any type T)</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200425204148911.png" alt="image-20200425204148911" style="zoom:67%;" /><ul><li>这里转的意思是，左边类型的变量或者值能否赋给右边类型的变量<ul><li>T=&gt;T&amp;,T的对象交给T的引用，两种情况，初始化或赋值</li><li>T&amp;=&gt;T，赋值</li><li>T*=&gt;void*  通过这个指针去看待那块内存的眼光变了，而不是那块内存的本身的东西变了</li><li>T[]=&gt;T*， 一个数组可以交给指针去管</li><li>T*=&gt;T[]，某个指针可以用数组来管它</li><li>T=&gt;const T，非const拿来当const看</li></ul></li></ul></li></ul></li><li><p>User-defined T <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> C  把T转成C，有以下两种方式</p><ul><li>if C(T) is a valid constructor call for C  //C类里有构造函数C(T)，可以把T转成C</li><li>if operator C() is defined for T  //T类里有operator C()</li></ul></li><li><p>BUT 如果都有呢？</p><ul><li><p>See:TypeConversionAmbiguity.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: C12:TypeConversionAmbiguity. cpp// From Thinking in C++, 2nd Edition // Available at http://www. BruceEckel. com// (c) Bruce Eckel 2000// Copyright notice in Copyright. txtclass Orange; // Class declarationclass Apple &#123;public:operator Orange() const; // Convert Apple to Orange&#125;;class Orange &#123;public:Orange(Apple); // Convert Apple to Orange    &#125;;void f(Orange) &#123;&#125;int main() &#123;Apple a;//! f(a); // Error: ambiguous conversion  两种情况都有，会出错，要去掉其中一种方法   可以在15行代码前面加explicit&#125; ///:~</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Do you want to use them?</p><ul><li>In General, no!尽量少用这种自动替你做的事情<ul><li>Cause lots of problems when functions are called unexpectedly.</li><li>See: CopyingVsInitialization2.cpp</li></ul></li><li>Use explicit conversion functions. For example, in class Rational instead of the conversion operator,declare a member function://更倾向于使用显式转换函数，阅读代码容易理解。例如，在Rational类中，而不是在转换操作符中，也不是声明一个成员函数<br>double toDouble() const;</li></ul></li></ul><h3 id="模板">模板</h3><ul><li><p>Why templates?</p><ul><li>Suppose you need a list of X and a list of Y<ul><li>The lists would use similar code</li><li>They differ by the type stored in the list  它们区别在于列表里存放的类型不同</li></ul></li><li>Choices<ul><li>Require common base class  X和Y有共同的基类<ul><li>May not be desirable  这可能做不到，eg.苹果和榔头，基类只能是东西</li></ul></li><li>Clone code  克隆代码<ul><li>preserves type-safety  类型是安全的</li><li>hard to manage  难以维护、管理，调整代码，两处都要改</li></ul></li><li>Untyped lists  创一个list，是void*，任何东西就可以往里面放<ul><li>type unsafe</li></ul></li></ul></li></ul></li><li><p>Templates</p><ul><li>Reuse source code<ul><li>generic programming</li><li>use types as parameters in class or function definitions</li></ul></li><li>Template functions<ul><li>Example: sort function  用这“一个”去sort不同类型</li></ul></li><li>Template classes<ul><li>Example: containers such as stack, list, queue…<ul><li>Stack operations are independent of the type of items in the stack</li></ul></li><li>template member functions</li></ul></li></ul></li><li><p>区别一下：</p><ul><li><p>function template函数模板:是一种模板，用来做出函数</p></li><li><p>类模板：是一种模板，用来做出类</p></li><li><hr></li><li><p>Template function：用template做出来的function</p></li><li><p>Template class：用template做出来的class</p></li></ul></li><li><p>Function Templates</p><ul><li><p>Perform similar operations on different types of data.</p></li><li><p>Swap function for two int arguments:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">( <span class="keyword">int</span>&amp; x，<span class="keyword">int</span>&amp; y )</span> </span>&#123;    <span class="keyword">int</span> temp = x;    x=y;    y = temp;&#125;</span><br></pre></td></tr></table></figure></li><li><p>What if we want to swap floats, strings,Currency, Person?</p></li></ul></li><li><p>Example:swap function template</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span><span class="comment">//template，class是关键字不能换。一般情况只有一个类型参数的话，习惯用T//template表示我的下一行那个东西是模板，如果下一行是函数，那个函数就是template，如果是类，那个类就是templatevoid swap( T&amp; x，T&amp; y )//在这个函数里可以使用T，来代表一个类型&#123;T temp=x;x=y;y = temp;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>The <strong>template</strong> keyword introduces the template</li><li>The <strong>class T</strong> specifies a parameterized type name<ul><li>class means any built-in type or user-defined type</li></ul></li><li>Inside the template, use T as a type name</li></ul></li><li><p>Function Template Syntax</p><ul><li>Parameter types represent:<ul><li>types of arguments to the function</li><li>return type of the function</li><li>declare variables within the function</li></ul></li></ul></li><li><p>Template Instantiation</p><ul><li>Generating a declaration from a template class/function and template arguments:<ul><li>Types are substituted into template</li><li>New body of function or class definition is created<ul><li>syntax errors,type checking</li></ul></li><li>Specialization – a version of a template for a particular arguments(s)</li></ul></li></ul></li><li><p>Example:Using swap</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">3</span>; <span class="keyword">int</span> j=<span class="number">4</span>;<span class="built_in">swap</span>(i, j) ;<span class="comment">// use explicit int swapfloat k = 4.5;float m = 3.7;swap(k, m) ; // instanstiate float swap   templateshi是一个declaration，编译器看到template什么也不干，它只会记住这个template。等编译器读到这一行，float不能用int的那个swap函数，窄不能转换到宽，然后你又有一个swap函数的模板，于是编译器会替你种出一个接受两个float作为输入的swap函数std::string s (&quot;Hel1o&quot;) ;std::string t (&quot;World&quot;) ;swap(s，t) ; // std::string swap</span></span><br></pre></td></tr></table></figure><ul><li>A template function is an instantiation of a function template</li></ul></li><li><p>Interactions</p><ul><li>Only exact match on types is used</li><li>No conversion operations are applied<ul><li>swap(int, int);// ok</li><li>swap(double, double); // ok</li><li>swap(int, double);// error!  不能作类型转换，因为你没有这种swap函数的模板</li></ul></li><li>Even implicit conversions are ignored  有函数模板后不会作类型转换，因为你已经明确有模板了，可以做出你想要的模板函数。所以编译器不会让你做自动类型转换，因为它认为这是对你意志的一种违背</li><li>Template functions and regular functions coexist</li></ul></li><li><p>Overloading rules</p><ul><li><p>Check first unique function match</p></li><li><p>Then check for unique function template match</p></li><li><p>Then do overloading on functions</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i,<span class="keyword">float</span> k)</span></span>&#123;&#125;;<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T t, T u)</span></span>&#123;&#125;:<span class="built_in">f</span>(<span class="number">1.0</span>,<span class="number">2.0</span>);<span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Function Instantiation</p><ul><li><p>The compiler deduces the template type from the actual arguments passed into the function.编译器从传递给函数的实际参数中推断模板类型。</p></li><li><p>Can be explicit:</p><ul><li><p>for example, if the parameter is not in the function signature (older compilers won’t allow this…)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123; <span class="comment">/*...*/</span>&#125;<span class="comment">//形参里没用到第1行中的Tfoo&lt;int&gt; () ; // type T is int    用&lt;&gt;再()，表示这次我就要种一个int出来foo&lt;float&gt; () ;// type T is float</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Class templates</p><ul><li><p>Classes parameterized by types</p><ul><li>Abstract operations from the types being operated upon</li><li>Define potentially infinite set of classes</li><li>Another step towards reuse!</li></ul></li><li><p>Typical use: container classes</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack &lt;<span class="keyword">int</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>is a stack that is parameterized over int</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list &lt;Person&amp;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue &lt;Job&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Example:Vetor</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span><span class="keyword">public</span>:    <span class="built_in">Vector</span> (<span class="keyword">int</span>) ;    ~<span class="built_in">Vector</span>() ;    <span class="built_in">Vector</span> (<span class="keyword">const</span> Vector&amp;) ;    Vector&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Vector&amp;) ;    T&amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span>) ;<span class="keyword">private</span>:    T* m_elements;    <span class="keyword">int</span> m_size;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Usage</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span> <span class="params">(<span class="number">100</span>)</span> </span>;<span class="function">Vector&lt;Complex&gt; <span class="title">v2</span> <span class="params">(<span class="number">256</span>)</span> </span>;v1 [<span class="number">20</span>] = <span class="number">10</span>;v2 [<span class="number">20</span>] = v1[<span class="number">20</span>] ; <span class="comment">// ok if int-&gt;Complex// defined</span></span><br></pre></td></tr></table></figure></li><li><p>Vector menbers  类里的成员函数都要写成函数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>Vector&lt;T&gt;::<span class="built_in">Vector</span> (<span class="keyword">int</span> size) : <span class="built_in">m_size</span> (size) &#123;<span class="comment">//注意这行的&lt;T&gt;m_elements = new T[m_size] ;&#125;template &lt;class T&gt;T&amp; Vector&lt;T&gt;::operator[] (int indx) &#123;        if(indx &lt; m_size&amp;&amp;indx&gt;0)        &#123;        return m_ elements [ indx] ;        &#125;    else         &#123;            ...        &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>A simple sort function</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bubble sort -- don&#x27;t use it!template &lt; class T &gt;void sort( vector&lt;T&gt;&amp; arr ) &#123;const size_t last = arr.size() -1;for(int i=0;i&lt;last;i++)    &#123;for(int j=last;i&lt;j;j--)        &#123;if (arr[j] &lt; arr[j - 1])            &#123;//这个&lt;就需要T要有overload operator的&lt;，如果没有编译会出错。出错说这个&lt;无法完成，你很难发觉怎么去修改                //int，string可以完成，有自己的类库                //如果是你自己写的类用了这个模板，要注意要有overloaded的operator的&lt;            // which swap?swap(arr[j]，arr[j - 1]) ;&#125;&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Sorting the vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vi</span> <span class="params">(<span class="number">4</span>)</span> </span>;vi[<span class="number">0</span>]=<span class="number">4</span>;vi[<span class="number">1</span>]=<span class="number">3</span>;vi[<span class="number">2</span>]=<span class="number">7</span>;vi[<span class="number">3</span>]=<span class="number">1</span>;<span class="built_in">sort</span> ( vi ) ; <span class="comment">// sort( vector&lt;int&gt;&amp; )vector&lt;string&gt; VS;vs.push_back (&quot;Fred&quot;) ;vs.push_back (&quot;Wilma&quot;) ;vs .push_back (&quot;Barney&quot;) ;vs .push_back (&quot;Dino&quot;) ;vs.push_back (&quot;Prince&quot;) ;sort( vs ) ; // sort( vector&lt;string&gt;&amp; )//<span class="doctag">NOTE:</span> sort uses operator&lt; for comparison</span></span><br></pre></td></tr></table></figure></li><li><p>Templates</p><ul><li><p>Templates can use multiple types</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>&gt;</span><span class="comment">//最好还是用单个大写字母，整单词给人阅读起来很难想象未来它是要被替换成其他的class HashTable &#123;    const Value&amp; lookup (const Key&amp;) const;    void install (const Key&amp;， const Value&amp;) ;    ...&#125;;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Templates nest —they’re just types!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt; Vector&lt; <span class="keyword">double</span> *&gt; &gt; <span class="comment">// note space&gt;&gt;  有的编译器要求中间要有空格,否则&gt;&gt;表示右移</span></span><br></pre></td></tr></table></figure></li><li><p>Type arguments can be complicated</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt; <span class="built_in"><span class="keyword">int</span></span> (*) (Vector&lt;<span class="keyword">double</span>&gt;&amp;，<span class="keyword">int</span>) &gt;<span class="comment">//Vector里面的成员是函数指针，这个函数指针返回类型是int    它的参数有两项，Vector的&amp;，这个Vector里面放的是double，第二项是int</span></span><br></pre></td></tr></table></figure></li><li><p>Expression parameters</p><ul><li><p>Template arguments can be constant expressions</p></li><li><p>Non-Type parameters</p><ul><li><p>can have a default argument</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">int</span> <span class="title">bounds</span> =</span> <span class="number">100</span>&gt;<span class="class"><span class="keyword">class</span> <span class="title">FixedVector</span> &#123;</span><span class="keyword">public</span>:<span class="built_in">FixedVector</span>() ;<span class="comment">//T&amp; operator[] (int) ;private:T elements [bounds]; // fixed size array!&#125;;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Templates and inheritance</p><ul><li><p>Templates can inherit from non-template classes</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">A</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;...<span class="comment">//将来种的每一个类都是Base的子类</span></span><br></pre></td></tr></table></figure></li><li><p>Templates can inherit from template classes</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">A</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> List&lt;A&gt;&#123;...<span class="comment">//父类是函数模板种出来的一个模板函数</span></span><br></pre></td></tr></table></figure></li><li><p>Non-template classes can inherit from templates某个类继承了模板种出来的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SupervisorGroup</span>:</span><span class="keyword">public</span> List&lt;Employee*&gt;&#123;...</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Writing templates</p><ul><li>Get a non-template version working first</li><li>Establish a good set of test cases</li><li>Measure performance and tune</li></ul></li><li><p>Usage:Non-type parameters</p><ul><li><p>Usage</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FixedVector&lt;<span class="keyword">int</span>， <span class="number">50</span>&gt; v1 ;FixedVector&lt;<span class="keyword">int</span>，<span class="number">10</span>*<span class="number">5</span>&gt; v2;FixedVector&lt;<span class="keyword">int</span>&gt; v3;<span class="comment">// uses default</span></span><br></pre></td></tr></table></figure></li><li><p>Summary</p><ul><li>Embedding sizes not necessarily a good idea</li></ul><ul><li>Can make code faster</li><li>Makes use more complicated<br>●size argument appears everywhere!<br>-Can lead to (even more) code bloat</li></ul></li></ul></li></ul><p>视频结尾的问题？？有空查下</p><h2 id="异常">异常</h2><h3 id="异常基本概念">异常基本概念</h3><ul><li><p>Run-time Error</p><ul><li>The basic philosophy of C++ is that“badly formed code will not be run.&quot;</li><li>There’s always something happen in run-time.</li><li>It is very important to deal with all possible situation in the future running.</li></ul></li><li><p>read a file出现的问题，不是由于你程序的问题，而是外界因素导致的</p><ul><li><p>open the file;</p></li><li><p>文件是否存在？</p><ul><li>Unix下另外一个进程独占这个文件？</li></ul></li><li><p>determine its size;</p></li><li><p>网络数据流，连接着远端服务器，还在往这个文件里写东西</p><ul><li>另一个进程打开这个文件正在写这个文件</li></ul></li><li><p>windows和Unix把外部设备都当文件，比如有一个串口，串口上接了一个moudle，moudle上可能有数据来，也可能没有</p></li><li><p>allocate thet much memory;</p><ul><li>文件可以很大，电影4g，你得不到那么大的内存</li></ul></li><li><p>read the file into memory;</p><ul><li>软盘、光盘、硬盘、U盘中有部分损坏，读不出来</li></ul></li><li><p>close the file;<br>+</p></li></ul></li><li><p>C的基础上写出一个强壮的程序，应对出错的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">errorCodeType readFile&#123;    initialize errorCode=<span class="number">0</span>;    open the file;    <span class="keyword">if</span>(the FilesOped)    &#123;        determine its size;        <span class="keyword">if</span>(gotTheFileLength)        &#123;            allocate that much memory;            <span class="keyword">if</span>(gotEnoughMemory)            &#123;                read the file into memory;                <span class="keyword">if</span>(readFailed)                &#123;                    errorCode=<span class="number">-1</span>;                &#125;            &#125;            <span class="keyword">else</span>            &#123;                errorCode=<span class="number">-2</span>;            &#125;        &#125;        <span class="keyword">else</span>        &#123;            errorCode=<span class="number">-3</span>;        &#125;        close the file;        <span class="keyword">if</span>(theFILEDidntClose&amp;&amp;errorCode==<span class="number">0</span>)        &#123;            errorCode=<span class="number">-4</span>;        &#125;        <span class="keyword">else</span>        &#123;            errorCode=errorCode <span class="keyword">and</span> <span class="number">-4</span>;        &#125;    &#125;    <span class="keyword">else</span>    &#123;        errorCode=<span class="number">-5</span>;    &#125;    <span class="keyword">return</span> errorCode;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Working w/ exception</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;    open the file;    determine its size;    allocate that much memory;    read the file into memory;    close the file;&#125; <span class="built_in"><span class="keyword">catch</span></span> ( fileOpenFailed ) &#123;doSomething;&#125; <span class="built_in"><span class="keyword">catch</span></span> ( sizeDeterminationFailed ) &#123;doSomething;&#125; <span class="built_in"><span class="keyword">catch</span></span> ( memory AllocationFailed ) &#123;doSomething;&#125; <span class="built_in"><span class="keyword">catch</span></span> ( readFailed ) &#123;doSomething;&#125; <span class="built_in"><span class="keyword">catch</span></span> ( fileCloseFailed ) &#123;doSomething;</span><br></pre></td></tr></table></figure></li><li><p>exception</p><ul><li>I take exception to that</li><li>At the point where the problem occurs, you might not know what to do with it, but you do know that you can’t just continue on merrily;出现问题后你不能悄无声息地继续（因为中途出错，你后面的步骤是无意义的）you must stop, and somebody, somewhere must figure out what to do.</li></ul></li><li><p>Why exception?</p><ul><li>The significant benefit of exceptions is that they clean up error handling code.</li><li>It separates the code that describes what you want to do from the code that is executed.</li><li>exception业务逻辑清晰，发生了问题你会知道该怎么做</li></ul></li></ul><h3 id="异常的抛出和捕捉">异常的抛出和捕捉</h3><ul><li><p>Exanple:Vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&#123;</span><span class="keyword">private</span>:    T* m_elements;    <span class="keyword">int</span> m_size;<span class="keyword">public</span>:<span class="built_in">Vector</span> (<span class="keyword">int</span> size=<span class="number">0</span>):<span class="built_in">m_size</span>(size)...    ~<span class="built_in">Vector</span>()    &#123;        <span class="keyword">delete</span>[] m_elements;    &#125;<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>    </span>&#123;        <span class="keyword">return</span> m_size;    &#125;T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span>);&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Poblem</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[] (<span class="keyword">int</span> indx) &#123;</span><br></pre></td></tr></table></figure><ul><li><p>What shoule the [] operator do if the index is not valid?[]越界了怎么办</p><ul><li><p>1.)Return random memory object</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> m_elements[indx];<span class="comment">//返回一个random值，但你可能拿它作左值，写到别人内存里去了，这是不能接受的</span></span><br></pre></td></tr></table></figure></li><li><p>2.)Return s apecial error value</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (indx &lt; <span class="number">0</span> || indx &gt;= m_size)&#123;    T* error_marker=<span class="keyword">new</span> <span class="built_in">T</span>(<span class="string">&quot;some magic value&quot;</span>);    <span class="keyword">return</span> *erroe_marker;&#125;<span class="keyword">return</span> m_elements[indx];</span><br></pre></td></tr></table></figure></li></ul></li><li><p>But this throws the baby out with the bath!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=v[<span class="number">2</span>]+v[<span class="number">4</span>];<span class="comment">//not safe code!  返回特定的错误值，但你这样要检查每个数是否是这个错误值，因为不能让这些错误值参与运算</span></span><br></pre></td></tr></table></figure><ul><li>3.)Just die!</li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (indx &lt; <span class="number">0</span> || indx &gt;= m_size)&#123;      <span class="built_in">exit</span>(<span class="number">22</span>);  &#125;  <span class="keyword">return</span> m_elements[indx];</span><br></pre></td></tr></table></figure><ul><li><p>4.)Die gracefully (with autopsy!)优雅地死</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(indx &gt;= <span class="number">0</span> &amp;&amp; indx &lt; m_size);<span class="comment">//assert其作用是如果它的条件返回错误，则终止程序执行。//https://www.cnblogs.com/lvchaoshun/p/7816288.html//assert表示的是代码的错误，数组越界可能不是代码问题，所以assert放这里不合适return m_elements[indx];</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>When to use exceptions</p><ul><li>Many times,you don’t know what shoule be done</li><li>If you do anything you’ll be wrong</li><li>Solutin:turf the problem</li><li>Make your caller(or its caller…)responsible</li></ul></li><li><p>How to raise an exception</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[] (<span class="keyword">int</span> indx) &#123;<span class="keyword">if</span>(indx &lt; <span class="number">0</span> || indx &gt;= m_size)    &#123;<span class="comment">// throw is a keyword// exception is raised at this pointthrow &lt; &lt;some thing&gt; &gt;;//出错就throw个东西出去，告诉别人这里出问题了&#125;return m_elements [indx] ;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>What do you throw?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// What do you have? Data!// Define a class to represent the error//原始类型和对象都是可以扔的，但一般扔对象。可以通过这个对象的类型知道里面发生了什么error，并且对象可以携带一定的数据（比如导致里面数组越界的index是多少）class VectorIndexError &#123;public:    VectorIndexError(int v) : m_badValue (v) &#123; &#125;    ~VectorIndexError () &#123; &#125;    void diagnostic()     &#123;    cerr&lt;&lt; &quot;index &quot; &lt;&lt; m_badValue    &lt;&lt; &quot;out of range!&quot;;     &#125;private :    int m_badValue;&#125;;</span></span><br></pre></td></tr></table></figure></li><li><p>How to raise an exception</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[] (<span class="keyword">int</span> indx) &#123;<span class="keyword">if</span> (indx &lt; <span class="number">0</span>|| indx &gt;= m_size) &#123;<span class="comment">// VectorIndexError(indx) ;// throw e;throw VectorIndexError(indx) ;//VectorIndexError这个类的对象在堆栈里（在函数内部产生的本地变量）        //throw作用是终止，离开当前大括号&#123;&#125;的函数        //第6行抛出异常，这个函数里throw后面的语句不被执行（这里if函数里throw后面没语句了）；然后退出整个if函数，此时整个if函数相当于throw，throw后语句不被执行(operator[]函数里第10行不被执行；然后退出operator[]函数，回到调用operator[]函数的地方、、转下个代码块    &#125;return m_elements [indx] ;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>What about your caller?</p><ul><li><p>Case 1)Doesn’t care<br>-Code never even suspects a problem</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">V</span><span class="params">(<span class="number">12</span>)</span> </span>;    v[<span class="number">3</span>] = <span class="number">5</span>;    <span class="keyword">int</span> i = v[<span class="number">42</span>]; <span class="comment">// out of range//退回到了这个，此时这句话相当于throw，再看throw所处的大括号是啥，第6行又被跳过，然后程序继续带着VectorIndexError的对象离开func（）函数（知道这个对象的地址就可以带走它）    // control never gets here !    return i * 5;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Case 2)Cares deeply</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outer</span><span class="params">()</span> </span>&#123;<span class="keyword">try</span> &#123;  <span class="built_in">func</span>() ; <span class="built_in">func2</span>() ;<span class="comment">//此时func()又相当于throw,func2()被跳过。此时throw在的大括号是try，它不着急离开了，而是去看后面的catch能否处理它这种异常，如果可以，就离开try，进catch，做catch里的事情，处理完以后不回到try()，而是继续往下走，如果你想回去自己写个循环  &#125; catch (VectorIndexError&amp; e) &#123;//这个catch捕捉的是VectorIndexError对象的&amp;  e.diagnostic() ;  // This exception does not propagate&#125; cout &lt;&lt; &quot;Control is here after exception&quot;;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Case 3)Mildly interested</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outer2</span> <span class="params">()</span> </span>&#123;<span class="function">String <span class="title">err</span> <span class="params">(<span class="string">&quot;exception caught&quot;</span>)</span> </span>;<span class="keyword">try</span> &#123;<span class="built_in">func</span>() ;&#125; <span class="built_in"><span class="keyword">catch</span></span> (VectorIndexError) &#123;cout &lt;&lt; err;<span class="keyword">throw</span>; <span class="comment">// propagate the exception  异常的传播        //第7行的意思是我要把刚刚捉到的异常再扔出去（在catch里，所以这里的throw不需要带对象和数值），这样整个try又相当于throw，这个函数又要被打断，回到调用try的地方      //为啥需要异常的传播？可能你只能处理一点点问题，需要更高层次的人去解决，或是寻找一个适当的时机再处理，这就需要不断向上报告，即把这个异常传播出去&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Case 4)Doesn’t care about the particulars</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outer3</span> <span class="params">()</span> </span>&#123;<span class="keyword">try</span> &#123;<span class="built_in">outer2</span> () ;&#125; <span class="built_in"><span class="keyword">catch</span></span> (...) &#123;<span class="comment">//...表示万能的，所有异常类型都能捕捉//.. . catches ALL exceptions !cout &lt;&lt; &quot;The exception stops here!&quot;;&#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>What happened?</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200609103617989.png" alt="image-20200609103617989" style="zoom: 80%;" /><ul><li>沿着调用的链条回去，直到遇到某个try里有匹配的catch能处理它为止</li></ul></li><li><p>Review</p><ul><li><p>Throw statement <strong>raises</strong> the exception</p><ul><li>Control propagates back to first handler for that exception</li><li>Propagation follows the <strong>call</strong> chain</li><li>Objects on <strong>stack</strong>are properly destroyed</li></ul></li><li><pre><code class="language-c++">throw exp;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + throws value for matching</span><br><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  throw;</span><br></pre></td></tr></table></figure>+ **reraises** the exception being handled+ valid only within a handler</code></pre></li></ul></li></ul><h3 id="异常语句">异常语句</h3><ul><li><p>Try blocks</p><ul><li><p>Try block</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;...&#125;<span class="keyword">catch</span> ...<span class="keyword">catch</span> ...</span><br></pre></td></tr></table></figure></li><li><p>Establishes any number of handlers</p></li><li><p>Not needed if you don’t use any handlers</p></li><li><p>Shows where you expect to handle exceptions</p></li><li><p>Costs cycles</p></li></ul></li><li><p>Exception handlers</p><ul><li><p>Select exception by type</p></li><li><p>Can re-raise exceptions</p></li><li><p>Two forms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SomeType v) &#123;<span class="comment">//handler code&#125;    catch (...) &#123;//handler code  但...你拿不到对象，这是万般无奈下的补救措施&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Take a single argument (like a formal parameter)</p></li></ul></li><li><p>Selecting a handler</p><ul><li><p>Can have any number of handlers</p></li><li><p>Handlers are checked in order of appearance  按你书写catch顺序针对每一条catch作下面123</p><ol><li><p>Check for exact match</p></li><li><p>Apply base class conversions</p><p>Reference and pointer types, only</p></li><li><p>Ellipses (…) match all</p></li></ol></li><li><p>Inheritance can be used to structure exceptions</p></li></ul></li><li><p>Example:using inheritance</p><ul><li><p>Hierarchy of exception types</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathErr</span>&#123;</span>    ...    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">diagnostic</span><span class="params">()</span></span>;&#125;;<span class="class"><span class="keyword">class</span> <span class="title">OverflowErr</span>:</span><span class="keyword">public</span> MathErr&#123;...&#125;<span class="class"><span class="keyword">class</span> <span class="title">UnderfolwErr</span>:</span><span class="keyword">public</span> MathErr&#123;...&#125;<span class="class"><span class="keyword">class</span> <span class="title">ZeroDivideErr</span>:</span><span class="keyword">public</span> MathErr&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Using handlers</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;<span class="comment">// code to exercise math optionsthrow UnderFlowErr () ;&#125; catch (ZeroDivideErr&amp; e) &#123;// handle zero divide case&#125; catch (MathErr&amp; e) &#123;// handle other math errors&#125; catch (...) &#123;//第三个如果是UnderfolwErr&amp; e,编译出错，因为永远被第6行捕捉，留不到第8行    //http://c.biancheng.net/view/2331.html// any other exceptions&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Exception specifications</p><ul><li><p>Declare which exceptions function might raise</p></li><li><p>Part of function prototypes</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abc</span><span class="params">(<span class="keyword">int</span> a)</span> : throw (MathErr) &#123;</span><span class="comment">//throw()里可以有一到多个类。告诉别的程序abc函数运行时最多会（“可能”）抛出哪些异常，如果抛出的异常不在这个清单里，会抛出unexpexted异常，这反而是对abc函数的一种限制。我们需要的是警告那些调用abc()的人自己最好有处理这些异常的机制，（JAVA里如果调用的人没有处理机制编译通不过，而C++编译不管）//throw()表示我不抛任何异常//不写throw(),什么都有可能抛出    ...&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Not checked at compile time</p></li><li><p>At run time,</p><ul><li>if an exception not in the list propagates out,the <strong>unexpected</strong> exception is raised</li></ul></li></ul></li></ul><p>​</p><ul><li><p>Examples</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Printer::<span class="built_in">print</span> (Document&amp;):<span class="keyword">throw</span> (PrinterOf fLine, BadDocument)&#123;...    PrintManager::<span class="built_in">print</span> (Document&amp;) :<span class="built_in"><span class="keyword">throw</span></span> (BadDocument) &#123; ...<span class="comment">// raises or doesn&#x27;t handle BadDocument    void goodguy() : throw () &#123;// handles all exceptions        void average() &#123; &#125; // no spec，no checking,</span></span><br></pre></td></tr></table></figure></li><li><p>Exceptions and new</p><ul><li><p>new does NOT returned 0 on failure</p></li><li><p>new raises a bad_alloc() exception</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="keyword">try</span> &#123;<span class="keyword">while</span>(<span class="number">1</span>) &#123;<span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="number">10000</span>] ;        &#125;&#125; <span class="built_in"><span class="keyword">catch</span></span> (bad_ alloc&amp; e) &#123;<span class="comment">//c里mallorca，内存不空是返回NULL；c++是返回bad_alloc异常    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Failure in constructors:</p><ul><li>No return value is possible</li><li>Use an“uninitialized flag”</li><li>Defer work to an Init() function</li></ul></li><li><p>Failure in constructors…</p><p>if you constructor can’t complete,throw an exception.</p><ul><li><p>Dtors for objects whose ctor didn’t complete won’t be called.</p></li><li><p>Clean up allocated resources before throwing.</p><ul><li><pre><code class="language-c++">class A&#123;public:A()    &#123;        throw 0;//加入你在构造函数里new了空间，在析构里delete，但构造函数抛出异常，导致析构无法调用（没构造就没析构），先前那块new的内存又变垃圾了        //所以在构造函数里抛出异常时比较麻烦的一件事情    &#125;&#125;;   int notmain()&#123;    A* p= new A();//new是先分配内存，然后将这块内存交给构造函数去用。但构造函数里抛出异常，你无法找到然后删掉这块内存，这块内存变垃圾了        delete p;        return 0;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">+ Programming with exceptions</span><br><span class="line"></span><br><span class="line">  Prefer catching exceptions by reference</span><br><span class="line"></span><br><span class="line">  + Throwing/catching by value involves slicing://slicing：子类对象交给父类（不是指针、引用），会丢掉一些东西</span><br><span class="line"></span><br><span class="line">    ~~~c++</span><br><span class="line">    struct X &#123;&#125;;struct Y : public X &#123;&#125;;try&#123;throw Y () ;&#125; catch(X x) &#123;//was it X or Y?&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>Throwing/catching by pointer introduces coupling between normal and handler code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Y</span>();&#125;<span class="built_in"><span class="keyword">catch</span></span>(Y* p)&#123;    <span class="comment">//whoops,forgot to delete.. 对象交给指针，这是可以的，但别忘了在catch里delete它，但这有点复杂了&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Catch exceptions by reference:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span>    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;&#125;;<span class="class"><span class="keyword">struct</span> <span class="title">D</span>:</span><span class="keyword">public</span> B&#123;<span class="comment">/*...*/</span>&#125;;<span class="keyword">try</span>&#123;    <span class="keyword">throw</span> <span class="built_in">D</span>(<span class="string">&quot;D error&quot;</span>);&#125;<span class="built_in"><span class="keyword">catch</span></span>(B&amp; b)&#123;    b.<span class="built_in">print</span>()<span class="comment">//print D&#x27;s error.&#125;</span></span><br></pre></td></tr></table></figure><ul><li>所以我们更倾向于你抛的是一个堆栈里很高的对象，catch是对象的引用（开销小），做完事情后不用做别的动作，反正那个高高在上的对象将来会被别人覆盖掉</li></ul></li></ul></li></ul><h2 id="流">流</h2><h3 id="流的概念">流的概念</h3><ul><li><p>Why streams?</p><ul><li>Original C I/O used printf, scanf</li><li>Streams invented for C++<ul><li>C I/O libraries still work</li></ul></li><li>Advantages of streams<ul><li>Better type safety</li><li>Extensible</li><li>More object oriented</li></ul></li><li>Disadvantages<ul><li>More verbose  啰嗦</li><li>Often slower</li></ul></li></ul></li><li><p>C VS. C++</p><ul><li>C stdio operations work<ul><li>Don’t provide“object-oriented&quot; features</li><li>No overloadable operators</li></ul></li><li>C++<ul><li>Can overload inserters(&lt;&lt;) and extractors(&gt;&gt;)</li></ul></li><li>Moral<ul><li>When converting C to C++, leave the I/O intact</li></ul></li></ul></li><li><p>What is a stream?</p><ul><li>Common logical interface to a device  流，一维单方向</li></ul></li><li><p>Stream naming conventions</p><p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++%E7%AC%94%E8%AE%B0-%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82%E7%BF%81%E6%81%BA%E8%80%81%E5%B8%88/image-20200430203758312.png" alt="image-20200430203758312"></p><ul><li>理解成fstream有i和o两种</li><li>第三行过时的， 对内存里char数组进行读写，这是不安全的，因为有下标检查，往里写东西可能会越界</li></ul></li><li><p>Stream operations</p><ul><li>Extractors<ul><li>Read a value from the stream（c++重载了&gt;&gt;，如果运算符左边是istream，作extractor；receive是整数作右移。&lt;&lt;同理）</li><li>Overload the &gt;&gt; operator</li></ul></li><li>Inserters<ul><li>Insert a value into a stream</li><li>Overload the &lt;&lt; operator</li></ul></li><li>Manipulators  操纵流怎样写的东西<ul><li>Change the stream state</li></ul></li><li>Others  在这些cin，cout上仍然有函数可以进行</li></ul></li><li><p>Kinds of streams</p><ul><li><p>Text streams  对文本进行操作，所有的输入输出其实都在作解析parse，输出在作format</p><ul><li><p>Deal in ASCII text</p></li><li><p>Perform some character translation</p><p>●e.g: newline -&gt; actual OS file representation</p></li><li><p>Include</p><ul><li>Files</li><li>Character buffers</li></ul></li></ul></li><li><p>Binary streams  二进制文件（不以人阅读为目的的文件）</p><ul><li>Binary data</li><li>No translations  输入输出不经过解析和格式化</li></ul></li></ul></li></ul><h3 id="流的运算符">流的运算符</h3><ul><li><p>Predefined streams</p><ul><li>cin<ul><li>standard input</li></ul></li><li>cout<ul><li>standard output</li></ul></li><li>cerr  标准错误<ul><li>unbuffered error (debugging) output</li></ul></li><li>clog  标准日志<ul><li>buffered error (debugging) output</li></ul></li></ul></li><li><p>Example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>int i; float f; char C;char buffer[80] ;</span></span><br></pre></td></tr></table></figure><ul><li><p>Read the next character</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;c;</span><br></pre></td></tr></table></figure></li><li><p>Read an integer</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; i; <span class="comment">// skips whitespace</span></span><br></pre></td></tr></table></figure></li><li><p>Read a float and a string separated by whitespace</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; f &gt;&gt; buffer;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Predefined extractors</p><ul><li><p>istream&gt;&gt;lvalue  根据你给的变量的类型来决定在文本中如何解析</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200506145332777.png" alt="image-20200506145332777" style="zoom:67%;" /></li><li><p>Extractors skip leading whitespace, in general</p></li></ul></li><li><p>Defining a stream extractor  自己写</p><ul><li><p>Has to be a 2-argument free function  写成全局函数</p><ul><li><p>First argument is an i stream&amp;</p></li><li><p>Second argument is a reference to a value</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, T&amp; obj) &#123;                    <span class="comment">//is里的position改了，读到哪个位置，所以istream&amp; is前没const// specific code to read objreturn is ;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Return an <strong>istream&amp;</strong> for chaining</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;( (cin &gt;&gt; a) &gt;&gt; b) &gt;&gt; c;<span class="comment">//cin &gt;&gt; a的结果要作下一个&gt;&gt;的receiver,所以cin &gt;&gt; a还得是istream。所以上面代码块函数的返回类型得是istream</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Other input operators</p><ul><li><p>int get()</p><ul><li><p>Returns the next character in the stream</p></li><li><p>Returns EOF if no characters left</p></li><li><p>Example: copy input to output</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;<span class="keyword">while</span> ( (ch = cin.<span class="built_in">get</span>()) != EOF)cout.<span class="built_in">put</span> (ch) ;</span><br></pre></td></tr></table></figure></li></ul></li><li><pre><code class="language-c++">istream&amp; get(char&amp; ch)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    + Puts the next character into argument//返回类型是istream，可以放在一连串中用</span><br><span class="line">    + Similar to int get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ More input operators</span><br><span class="line"></span><br><span class="line">  + ~~~c++</span><br><span class="line">    get (char *buf， int limit, char delim = &#x27;\n&#x27;)</span><br></pre></td></tr></table></figure>+ **read up to** limit **characters, or to** delim+ **Appends a null character to** buf+ **&lt;u&gt;Does&lt;/u&gt;** not consume the **delimiter**</code></pre></li><li><pre><code class="language-c++">getline(char *buf, int limit, char delim = '\n')<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + **read up to** limit **characters, or to** delim</span><br><span class="line">  + **Appends a null character to** buf</span><br><span class="line">  + &lt;u&gt;**Does**&lt;/u&gt; **consume the delimiter**</span><br><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  ignore (int limit = 1，int delim = EOF)//跳过多少个东西不去读或者读到delim为止</span><br></pre></td></tr></table></figure>+ **Skip over limit characters or to delimiter**+ **Skip over delimiter if found**</code></pre></li><li><pre><code class="language-c++">int gcount ()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ returns number of characters just read//返回刚才读到的多少个东西</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  char buffer[100] ;cin.getline (buffer, sizeof (buffer) ) ;cout &lt;&lt; &quot;read &quot; &lt;&lt; cin.gcount ()&lt;&lt; &quot; characters&quot;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="language-c++">void putback (char)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + pushes a single character back into the stream</span><br><span class="line"></span><br><span class="line">+ ~~~c++</span><br><span class="line">  char peek()//偷窥，看一眼但不读</span><br></pre></td></tr></table></figure>+ examines next character without reading it  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (cin.<span class="built_in">peek</span>())...</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>Predefined inserters</p><ul><li><p>Usage</p><p>-ostream&lt;&lt;expression</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200506150546190.png" alt="image-20200506150546190" style="zoom:67%;" /></li></ul></li><li><p>Creating a stream inserter</p><ul><li><p>Has to be a 2-argument free function</p><ul><li><p>First argument is an ostream&amp;</p></li><li><p>Second argument is any value</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; os， <span class="keyword">const</span> T&amp; obj) &#123;                                 <span class="comment">//这里有const，因为我只是要把obj往&lt;&lt;里inserter// specific code to write objreturn OS ;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Return an ostream&amp; for chaining</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt;c;((cout &lt;&lt; a) &lt;&lt; b) &lt;&lt; c;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Other output operators</p><ul><li><pre><code class="language-c++">put (char)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ prints a single character</span><br><span class="line"></span><br><span class="line">+ Examples</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  cout.put(&#x27;a&#x27;) ;cerr.put (&#x27;!&#x27;) ;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>flush()</p><ul><li><p>Force output of stream contents 保证这个输出能忘物理地址上写</p></li><li><p>Example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Enter a number&quot;</span> ;cout.<span class="built_in">flush</span>() ;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Formatting using manipulators</p><ul><li><p>Manipulators modify the state of the stream</p><ul><li>#include <iomanip></li><li>Effects hold (usually)</li></ul></li><li><p>Example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;cout &lt;&lt; <span class="string">&quot;enter number in hexadecimal&quot;</span> &lt;&lt; flush;cin &gt;&gt; hex &gt;&gt; n;<span class="comment">//用hex告诉cin下一个读到的东西是十六进制</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Example</p><ul><li><p>A simple program</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span>main() &#123;cout &lt;&lt; setprecision(2) &lt;&lt; 1000.243 &lt;&lt;endl;<span class="comment">//精度为2cout &lt;&lt; setw(20) &lt;&lt; &quot;OK!&quot;;//宽度为20return 0;&#125;</span></span></span><br></pre></td></tr></table></figure></li><li><p>Prints</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">le03                 OK!</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Manipulators</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200506151405912.png" alt="image-20200506151405912" style="zoom:67%;" /><ul><li>type上，I指Input可用，O指输出可用</li><li>setw(int)最少多宽</li><li>setfill(ch)填充什么</li><li>setbase(int)，任何数制</li><li>ws，跳过空格</li><li>setprecision(int)，精度多少，有多少位有效数字</li><li>setiosflags(long),在计算机，set就是置1，reset是置0</li></ul></li><li><p>Creating manipulators</p><ul><li><p>You can define your own manipulators!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skeleton for an output stream manipulatorostream&amp; manip (ostream&amp; out) &#123;    ...return out ;&#125;ostream&amp; tab ( ostream&amp; out )&#123;return out &lt;&lt; &#x27;\t&#x27; ;&#125;cout &lt;&lt; &quot;Hello&quot; &lt;&lt; tab &lt;&lt; &quot;World!&quot; &lt;&lt; endl ;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Stream flags control formatting</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200506151547193.png" alt="image-20200506151547193" style="zoom:67%;" /></li><li><p>Setting flags</p><ul><li>Using manipulators<ul><li>setiosflags(flags);</li><li>resetiosflags(flags);</li></ul></li><li>Using stream member functions<ul><li>setf(flags)</li><li>unsetf(flags)</li></ul></li></ul></li></ul><h2 id="STL简述">STL简述</h2><ul><li><p>What is STL</p><ul><li>STL = Standard Template Library</li><li>Part of the ISO Standard C++ Library</li><li>Data Structures数据结构 and algorithms算法 for C++.</li></ul></li><li><p>Why should I use STL?</p><ul><li>Reduce development time.<ul><li>Data-structures already written and debugged.</li></ul></li><li>Code readability  可读性。另一层意思，和其他程序员有共同语言<ul><li>Fit more meaningful stuff on one page.一页上有更多有意义的东西</li></ul></li><li>Robustness  强壮性<ul><li>STL data structures grow automatically.</li></ul></li><li>Portable code.可移植</li><li>Maintainable code可维护</li><li>Easy</li></ul></li><li><p>C++ Standard Library</p><ul><li><p>Library includes:</p><ul><li>A <strong>Pair</strong> class (pairs of anything, int/int, int/char, etc)表达两个东西之间的关系</li><li>Containers<ul><li>Vector (expandable array可拓展数组，下标会自动拓展，不会有越界问题)</li><li>Deque (expandable array, expands at both ends两头增长)</li><li>List (double-linked双向链表)</li><li>Sets（集合，重复，无序） and Maps（映射，key和value）</li></ul></li><li>Basic Algorithms 基础算法(sort, search, etc)</li></ul></li><li><p>All identifiers in library are in <strong>std</strong> namespace</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>The three parts of STL</p><ul><li>Containers</li><li>Algorithms</li><li>Iterators枚举器</li></ul></li><li><p>The ‘Top 3’ data stryctures</p><ul><li>map<ul><li>Any key type,any value type.</li><li>Sorted.</li></ul></li><li>vector<ul><li>Like c array,but auto-extending.</li></ul></li><li>list<ul><li>doubly-linked list</li></ul></li></ul></li><li><p>Example using the vector class</p><img src= "/img/loading.gif" data-lazy-src="/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200609203610775.png" alt="image-20200609203610775" style="zoom: 80%;" /><ul><li>vector<int>::iterator p;//vector<int>里的一种数据类型iterator</li><li>运算符重载，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">∗</span></span></span></span>重载过，vector里说iterator是int类型，所以iterator*返回的就是int</li><li>++肯定也重载过</li></ul></li><li><p>Basic Vector Operations</p><ul><li><p>Constryctors</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Elem&gt; c;<span class="function">vector&lt;Elem&gt; <span class="title">c1</span><span class="params">(c2)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Simple Methods</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V.<span class="built_in">size</span>()<span class="comment">//num itemsV.empty()//empty?==,!=,&lt;,&gt;,&lt;=,&gt;=  //重载了一些比较两个Vector的运算符V.swap(v2)//swap  交换两个Vector的所有元素</span></span><br></pre></td></tr></table></figure></li><li><p>Iterators</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I.<span class="built_in">begin</span>()<span class="comment">//first positonI.end()//lase position</span></span><br></pre></td></tr></table></figure></li><li><p>Element access</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V.<span class="built_in">at</span>(index)V[index]V.<span class="built_in">front</span>()<span class="comment">//first itemV.back()//last item</span></span><br></pre></td></tr></table></figure></li><li><p>Add/Remove/Find</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V.<span class="built_in">push_back</span>(e)V.<span class="built_in">pop_back</span>()<span class="comment">//有push，pop，相当于实现了stackv.insert(pos,e)V.erase(pos)//删除V.clear()//清空V.find(first,last,item)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>List Class</p><ul><li><p>Same basic concepts as vector</p><ul><li><p>Constructors</p></li><li><p>Ability to compare lists(==,!=,&lt;,&lt;=,&gt;,&gt;=)</p></li><li><p>Ability to access front and back of list</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="built_in">front</span>(),x.<span class="built_in">back</span>()</span><br></pre></td></tr></table></figure></li><li><p>Ability to assign items to a list,remove items</p><ul><li><pre><code class="language-c++">x.push_back(item),x.push_front(item)x.pop_back(),x.pop_front()x.remove(item)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Sample List Application</span><br><span class="line"></span><br><span class="line">  ![image-20200610100902057](/Typora_images/C++笔记-网易云课堂翁恺老师/image-20200610100902057.png)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">+ Example Program</span><br><span class="line"></span><br><span class="line">  ~~~c++</span><br><span class="line">  #include &lt;map&gt;#include &lt;string&gt;map&lt;string,float&gt; price;price[&quot;snapple&quot;] = 0.75;price[&quot;coke&quot;]= 0.50;string item;double total=0;while ( cin &gt;&gt; item )total += price[item];</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
